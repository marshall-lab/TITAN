{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview TITAN (Treatment of Infectious Transmissions through Agent-based Network) is an agent-based simulation model used to explore contact transmission in complex social networks. Starting with the initializing agent population, TITAN iterates over a series of stochastic interactions where agents can interact with one another, transmit infections through various medium, and enter and exit the care continuum. The purpose of TITAN is to evaluate the impact of prevention and treatment models on incidence and prevalence rates of the targeted disease(s) through the use of data fitting simulated trajectories and rich statistics of primary/sub-population attributable proportions. Agent populations are defined as graphs (nodes connected by edges). Nodes in the graph are used to represent the attributes (or collection of attributes) of an agent (person), and edges define the type of relationship between agents. In practice, a graph represents a social network of connected people through various relationship types, and provides the medium for which agents can interact.","title":"Overview"},{"location":"#overview","text":"TITAN (Treatment of Infectious Transmissions through Agent-based Network) is an agent-based simulation model used to explore contact transmission in complex social networks. Starting with the initializing agent population, TITAN iterates over a series of stochastic interactions where agents can interact with one another, transmit infections through various medium, and enter and exit the care continuum. The purpose of TITAN is to evaluate the impact of prevention and treatment models on incidence and prevalence rates of the targeted disease(s) through the use of data fitting simulated trajectories and rich statistics of primary/sub-population attributable proportions. Agent populations are defined as graphs (nodes connected by edges). Nodes in the graph are used to represent the attributes (or collection of attributes) of an agent (person), and edges define the type of relationship between agents. In practice, a graph represents a social network of connected people through various relationship types, and provides the medium for which agents can interact.","title":"Overview"},{"location":"contributing/","text":"We welcome issues and pull requests to help improve the TITAN model. We use the following guidelines to ensure standards are met. GitHub Workflow When working on TITAN, make a branch from develop to make changes in, then make a pull request to develop when ready for review. Branches develop is the primary working branch for the project main is the branch releases are made off of and is in stable condition at all times topic branches are created for new features, fixes, or really any changes Commitizen All commits should use the angular style. Commitizen makes this easy. pip install --user commitizen Then use cz commit where you would have previously done git commit . Code Standards Testing We strive to have test coverage for all of the features of TITAN. When adding a new feature or fixing a bug, add tests for the new feature or that test the bug condition to make sure that the bug doesn't crop up agin. pytest is the library used for testing. To run all of the tests: python -m pytest To run only the unit tests: python -m pytest -m unit Code Style black The code must conform to black 's standards and this is automatically checked via github actions. To automatically fix files, run black . from the root of the TITAN directory. flake8 The code must not have any egregious linting errors. And others should be minimized as reasonable. Check for egregious errors: flake8 titan --count --select=E9,F63,F7,F82 --show-source --statistics Check for all warnings: flake8 titan --count --exit-zero --max-complexity=12 --max-line-length=88 --statistics Typing Please use type hints on all signatures where reasonable. This will make sure the code is more readable, can be statically tested for type soundness, and helps fill in the documentation. Run the below to check for type errors: mypy titan Documentation All functions and methods should have an up to date google style docstring . These docstrings are used to build TITAN's documentation website. Additional prose can be added to the website by editing the appropriate markdown file in the docs/ directory. To develop/see the docs locally, run: mkdocs serve then navigate to http://localhost:8000 to see your docs. They will automoatically reload as you make changes to files.","title":"Contributing"},{"location":"contributing/#github-workflow","text":"When working on TITAN, make a branch from develop to make changes in, then make a pull request to develop when ready for review.","title":"GitHub Workflow"},{"location":"contributing/#branches","text":"develop is the primary working branch for the project main is the branch releases are made off of and is in stable condition at all times topic branches are created for new features, fixes, or really any changes","title":"Branches"},{"location":"contributing/#commitizen","text":"All commits should use the angular style. Commitizen makes this easy. pip install --user commitizen Then use cz commit where you would have previously done git commit .","title":"Commitizen"},{"location":"contributing/#code-standards","text":"","title":"Code Standards"},{"location":"contributing/#testing","text":"We strive to have test coverage for all of the features of TITAN. When adding a new feature or fixing a bug, add tests for the new feature or that test the bug condition to make sure that the bug doesn't crop up agin. pytest is the library used for testing. To run all of the tests: python -m pytest To run only the unit tests: python -m pytest -m unit","title":"Testing"},{"location":"contributing/#code-style","text":"","title":"Code Style"},{"location":"contributing/#black","text":"The code must conform to black 's standards and this is automatically checked via github actions. To automatically fix files, run black . from the root of the TITAN directory.","title":"black"},{"location":"contributing/#flake8","text":"The code must not have any egregious linting errors. And others should be minimized as reasonable. Check for egregious errors: flake8 titan --count --select=E9,F63,F7,F82 --show-source --statistics Check for all warnings: flake8 titan --count --exit-zero --max-complexity=12 --max-line-length=88 --statistics","title":"flake8"},{"location":"contributing/#typing","text":"Please use type hints on all signatures where reasonable. This will make sure the code is more readable, can be statically tested for type soundness, and helps fill in the documentation. Run the below to check for type errors: mypy titan","title":"Typing"},{"location":"contributing/#documentation","text":"All functions and methods should have an up to date google style docstring . These docstrings are used to build TITAN's documentation website. Additional prose can be added to the website by editing the appropriate markdown file in the docs/ directory. To develop/see the docs locally, run: mkdocs serve then navigate to http://localhost:8000 to see your docs. They will automoatically reload as you make changes to files.","title":"Documentation"},{"location":"getting_started/","text":"Getting Started To get started, install the requirements listed in the requirements.txt using a local python install or virtual env. Once installed, the model can be run using the run_titan.py program and configured using the params.py file. Tip Running a large job locally? Look into using pypy instead of python for MOAR performance. This is what we use on OSCAR. Otherwise, all of the instructions hold, just using pypy and pypy's pip. Installing the Dependencies In order for TITAN to run, you must install Python3.x and the necessary python packages listed in the requirements.txt . Package installation can be done by using pip via: pip install -r requirements.txt Dev Dependencies If you are planning to contribute to the package, also install the dev dependencies. These packages help with code style, linting, typing, and building documentation. pip install -r dev_requirements.txt","title":"Installation"},{"location":"getting_started/#getting-started","text":"To get started, install the requirements listed in the requirements.txt using a local python install or virtual env. Once installed, the model can be run using the run_titan.py program and configured using the params.py file. Tip Running a large job locally? Look into using pypy instead of python for MOAR performance. This is what we use on OSCAR. Otherwise, all of the instructions hold, just using pypy and pypy's pip.","title":"Getting Started"},{"location":"getting_started/#installing-the-dependencies","text":"In order for TITAN to run, you must install Python3.x and the necessary python packages listed in the requirements.txt . Package installation can be done by using pip via: pip install -r requirements.txt","title":"Installing the Dependencies"},{"location":"getting_started/#dev-dependencies","text":"If you are planning to contribute to the package, also install the dev dependencies. These packages help with code style, linting, typing, and building documentation. pip install -r dev_requirements.txt","title":"Dev Dependencies"},{"location":"run_local/","text":"Running the Model The model has a wrapper script called run_titan.py that makes running a full simulation easy. TITAN can also be run from an interactive repl or a custom script. run_titan.py To run the model, execute the run_titan.py program within the /titan/ directory. See TITAN params for documentation on how to set and use parameters. Results of the model are generated and aggregated into the /results/ directory by default. If the model is re-run, the existing results will be overwritten. Usage Below are the results of python run_titan.py --help . It highlights all of the command line arguments that can be passed to the script. usage : run_titan . py [ -h ] [ -n [NMC ] ] [ -S SETTING ] - p PARAMS [ -o OUTDIR ] [ -b BASE ] [ -e ] [ --savepop SAVEPOP ] [ --poppath POPPATH ] [ -w SWEEP [SWEEP ... ] ] [ -W SWEEPFILE ] [ -r ROWS ] [ -F ] Run TITAN model optional arguments : - h , --help show this help message and exit - n [ NMC ] , --nMC [NMC] number of monte carlo runs to complete - S SETTING , --setting SETTING setting directory to use - p PARAMS , --params PARAMS directory or file with params yaml ( s ) - o OUTDIR , --outdir OUTDIR directory name to save results to - b BASE , --base BASE whether to use base setting - e , --error Error on unused parameters instead of warning --savepop SAVEPOP Save population after creation, but before model run. 'all' = save all atributes , 'core' = save core ( non - intervention ) attributes . --poppath POPPATH Path to saved population (directory or .tar.gz file) - w SWEEP [ SWEEP ... ] , --sweep SWEEP [SWEEP ...] Optional and repeatable definitions of numeric params to sweep . Expected format is param : start : stop [ :step ] - W SWEEPFILE , --sweepfile SWEEPFILE Optional . CSV file with param sweep definitions . Header row must contain param paths , with data rows containing values . If this is passed , any ` - w ` args will be ignored . - r ROWS , --rows ROWS Optional. Which data rows of sweepfile to use in format start : stop . - F , --force Run model even if number of sweeps exceeds 100 run_titan.main ( setting , params_path , num_reps , outdir , use_base , sweeps , force , sweepfile = None , rows = None , error_on_unused = False , save_pop = None , pop_path = None ) Run TITAN! Parameters: Name Type Description Default setting str setting name to use, matches a folder name in settings/ required params_path str path to params file or directory required num_reps int number of time to repeat each sweep required outdir str directory where results are to be saved required use_base bool whether to use the \"base\" setting (includes some more complicated defaults) required sweeps List[str] array of strings in param:start:stop:step format required force bool if true, will run even if combination of sweeps results in greater than 100 runs required sweepfile Optional[str] path to csv file of sweep definitions None rows Optional[str] which rows of the csv to load to create sweeps in start:stop format None error_on_unused bool error if there are parameters that are unused by the model False save_pop Optional[str] 'all' or 'core' will save the population with agents have all or core attributes saved None pop_path Optional[str] path to a population to load instead of creating a new population for each run None Source code in TITAN/run_titan.py def main ( setting : str , params_path : str , num_reps : int , outdir : str , use_base : bool , sweeps : List [ str ], force : bool , sweepfile : Optional [ str ] = None , rows : Optional [ str ] = None , error_on_unused : bool = False , save_pop : Optional [ str ] = None , pop_path : Optional [ str ] = None , ): \"\"\" Run TITAN! args: setting: setting name to use, matches a folder name in `settings/` params_path: path to params file or directory num_reps: number of time to repeat each sweep outdir: directory where results are to be saved use_base: whether to use the \"base\" setting (includes some more complicated defaults) sweeps: array of strings in param:start:stop:step format force: if true, will run even if combination of sweeps results in greater than 100 runs sweepfile: path to csv file of sweep definitions rows: which rows of the csv to load to create sweeps in start:stop format error_on_unused: error if there are parameters that are unused by the model save_pop: 'all' or 'core' will save the population with agents have all or core attributes saved pop_path: path to a population to load instead of creating a new population for each run \"\"\" # delete old results before overwriting with new results outfile_dir = os . path . join ( os . getcwd (), outdir ) if os . path . isdir ( outfile_dir ): shutil . rmtree ( outfile_dir ) os . mkdir ( outfile_dir ) os . mkdir ( os . path . join ( outfile_dir , \"network\" )) if save_pop in ( \"all\" , \"core\" ): os . mkdir ( os . path . join ( outfile_dir , \"pop\" )) # generate params - if no setting, set to none setting = setting . lower () if setting == \"custom\" : setting = None else : setting = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ )), \"settings\" , setting ) assert os . path . isdir ( setting ), f \" { setting } is not a directory\" params = create_params ( setting , params_path , outfile_dir , use_base = use_base , error_on_unused = error_on_unused , ) # set up sweeps if sweepfile is not None : sweep_defs = setup_sweeps_file ( sweepfile , rows ) elif sweeps : sweep_defs = setup_sweeps ( sweeps ) else : sweep_defs = [{}] # make sure runs once if len ( sweep_defs ) > 100 and not force : raise ValueError ( \"Sweeping more than 100 models. Set `-F` (force) flag if you really want to do this.\" ) sweep_defs *= num_reps tic = time_mod . time () wct = [] # wall clock times with Pool ( processes = NCORES ) as pool : results = [ pool . apply_async ( single_run , ( sweep_def , outfile_dir , params , save_pop , pop_path ) ) for sweep_def in sweep_defs ] while True : if all ([ r . ready () for r in results ]): break else : time_mod . sleep ( 1 ) for r in results : try : t = r . get () wct . append ( t ) except Exception as e : traceback . print_exc () toc = time_mod . time () - tic consolidate_files ( outfile_dir ) for task , time_t in enumerate ( wct ): print (( \"wall clock time on for simulation %d : %8.4f seconds\" % ( task , time_t ))) def mean ( seq ): return sum ( seq ) / len ( seq ) print (( \" \\n SUMMARY: \\n all tasks - mean: %8.4f seconds\" % mean ( wct ))) print (( \"all tasks - min: %8.4f seconds\" % min ( wct ))) print (( \"all tasks - max: %8.4f seconds\" % max ( wct ))) print (( \"all tasks - sum: %8.4f seconds\" % sum ( wct ))) print ( f \"all tasks - total: { toc } seconds\" ) Running Interactively The model can also be run interactively in the repl. Start a python session from the root directory of TITAN , and follow along! We'll use the sample params file tests/params/basic.yml in all of these examples, but feel free to use a different one. Here is how to perform the basic steps of running the model: from .titan.parse_params import create_params from .titan.model import HIVModel outdir = 'results' params = create_params ( None , 'tests/params/basic.yml' , outdir ) model = HIVModel ( params ) model . run ( outdir ) This creates a params object using no setting (the None ), our test params, and tells create_params to put our computed params file in a directory called results . the 'results' directory must already be created We then use those params to create our model, and run it. We also have the model results saved to our results directory. We should now see a params.yml in our 'results' directory, and some reports showing what happened at different timesteps in the model. If we wanted to debug something, or look at a very specific metric that wasn't in our reports, we could instead step through the model one time-step at a time. Resuming from our code above, here's how we could do that. model2 = HIVModel ( params ) start_time = 0 end_time = 10 for i in range ( start_time , end_time ): model2 . time = i # update the model's time model2 . step ( outdir ) # do some introspection here, like... print ( model2 . pop . haart_counts ) # make sure the model state is reset for a new time step model2 . reset_trackets () If we want to write and read in a population instead of letting the model create one... from .titan import population_io as pio from .titan.population import Population from copy import deepcopy # let's make a copy of our params and tinker with the population a bit params2 = deepcopy ( params ) params2 . demographics . white . MSM . hiv . prob = 0.4 pop = Population ( params2 ) poppath = pio . write ( pop , outdir ) pop2 = pio . read ( poppath ) # this should be the same population as pop # pass a population to the model to use that instead of creating a new one model3 = HIVModel ( param2 , pop2 ) model3 . run ( outdir ) Running the Tests To make sure everything is working, run the tests. A few of the tests (marked integration_stochastic ) sometimes fail as they are testing for general behavior and not specific correctness, but all other tests should always pass. python -m pytest","title":"Running locally"},{"location":"run_local/#running-the-model","text":"The model has a wrapper script called run_titan.py that makes running a full simulation easy. TITAN can also be run from an interactive repl or a custom script.","title":"Running the Model"},{"location":"run_local/#run_titanpy","text":"To run the model, execute the run_titan.py program within the /titan/ directory. See TITAN params for documentation on how to set and use parameters. Results of the model are generated and aggregated into the /results/ directory by default. If the model is re-run, the existing results will be overwritten.","title":"run_titan.py"},{"location":"run_local/#usage","text":"Below are the results of python run_titan.py --help . It highlights all of the command line arguments that can be passed to the script. usage : run_titan . py [ -h ] [ -n [NMC ] ] [ -S SETTING ] - p PARAMS [ -o OUTDIR ] [ -b BASE ] [ -e ] [ --savepop SAVEPOP ] [ --poppath POPPATH ] [ -w SWEEP [SWEEP ... ] ] [ -W SWEEPFILE ] [ -r ROWS ] [ -F ] Run TITAN model optional arguments : - h , --help show this help message and exit - n [ NMC ] , --nMC [NMC] number of monte carlo runs to complete - S SETTING , --setting SETTING setting directory to use - p PARAMS , --params PARAMS directory or file with params yaml ( s ) - o OUTDIR , --outdir OUTDIR directory name to save results to - b BASE , --base BASE whether to use base setting - e , --error Error on unused parameters instead of warning --savepop SAVEPOP Save population after creation, but before model run. 'all' = save all atributes , 'core' = save core ( non - intervention ) attributes . --poppath POPPATH Path to saved population (directory or .tar.gz file) - w SWEEP [ SWEEP ... ] , --sweep SWEEP [SWEEP ...] Optional and repeatable definitions of numeric params to sweep . Expected format is param : start : stop [ :step ] - W SWEEPFILE , --sweepfile SWEEPFILE Optional . CSV file with param sweep definitions . Header row must contain param paths , with data rows containing values . If this is passed , any ` - w ` args will be ignored . - r ROWS , --rows ROWS Optional. Which data rows of sweepfile to use in format start : stop . - F , --force Run model even if number of sweeps exceeds 100","title":"Usage"},{"location":"run_local/#run_titan.main","text":"Run TITAN! Parameters: Name Type Description Default setting str setting name to use, matches a folder name in settings/ required params_path str path to params file or directory required num_reps int number of time to repeat each sweep required outdir str directory where results are to be saved required use_base bool whether to use the \"base\" setting (includes some more complicated defaults) required sweeps List[str] array of strings in param:start:stop:step format required force bool if true, will run even if combination of sweeps results in greater than 100 runs required sweepfile Optional[str] path to csv file of sweep definitions None rows Optional[str] which rows of the csv to load to create sweeps in start:stop format None error_on_unused bool error if there are parameters that are unused by the model False save_pop Optional[str] 'all' or 'core' will save the population with agents have all or core attributes saved None pop_path Optional[str] path to a population to load instead of creating a new population for each run None Source code in TITAN/run_titan.py def main ( setting : str , params_path : str , num_reps : int , outdir : str , use_base : bool , sweeps : List [ str ], force : bool , sweepfile : Optional [ str ] = None , rows : Optional [ str ] = None , error_on_unused : bool = False , save_pop : Optional [ str ] = None , pop_path : Optional [ str ] = None , ): \"\"\" Run TITAN! args: setting: setting name to use, matches a folder name in `settings/` params_path: path to params file or directory num_reps: number of time to repeat each sweep outdir: directory where results are to be saved use_base: whether to use the \"base\" setting (includes some more complicated defaults) sweeps: array of strings in param:start:stop:step format force: if true, will run even if combination of sweeps results in greater than 100 runs sweepfile: path to csv file of sweep definitions rows: which rows of the csv to load to create sweeps in start:stop format error_on_unused: error if there are parameters that are unused by the model save_pop: 'all' or 'core' will save the population with agents have all or core attributes saved pop_path: path to a population to load instead of creating a new population for each run \"\"\" # delete old results before overwriting with new results outfile_dir = os . path . join ( os . getcwd (), outdir ) if os . path . isdir ( outfile_dir ): shutil . rmtree ( outfile_dir ) os . mkdir ( outfile_dir ) os . mkdir ( os . path . join ( outfile_dir , \"network\" )) if save_pop in ( \"all\" , \"core\" ): os . mkdir ( os . path . join ( outfile_dir , \"pop\" )) # generate params - if no setting, set to none setting = setting . lower () if setting == \"custom\" : setting = None else : setting = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ )), \"settings\" , setting ) assert os . path . isdir ( setting ), f \" { setting } is not a directory\" params = create_params ( setting , params_path , outfile_dir , use_base = use_base , error_on_unused = error_on_unused , ) # set up sweeps if sweepfile is not None : sweep_defs = setup_sweeps_file ( sweepfile , rows ) elif sweeps : sweep_defs = setup_sweeps ( sweeps ) else : sweep_defs = [{}] # make sure runs once if len ( sweep_defs ) > 100 and not force : raise ValueError ( \"Sweeping more than 100 models. Set `-F` (force) flag if you really want to do this.\" ) sweep_defs *= num_reps tic = time_mod . time () wct = [] # wall clock times with Pool ( processes = NCORES ) as pool : results = [ pool . apply_async ( single_run , ( sweep_def , outfile_dir , params , save_pop , pop_path ) ) for sweep_def in sweep_defs ] while True : if all ([ r . ready () for r in results ]): break else : time_mod . sleep ( 1 ) for r in results : try : t = r . get () wct . append ( t ) except Exception as e : traceback . print_exc () toc = time_mod . time () - tic consolidate_files ( outfile_dir ) for task , time_t in enumerate ( wct ): print (( \"wall clock time on for simulation %d : %8.4f seconds\" % ( task , time_t ))) def mean ( seq ): return sum ( seq ) / len ( seq ) print (( \" \\n SUMMARY: \\n all tasks - mean: %8.4f seconds\" % mean ( wct ))) print (( \"all tasks - min: %8.4f seconds\" % min ( wct ))) print (( \"all tasks - max: %8.4f seconds\" % max ( wct ))) print (( \"all tasks - sum: %8.4f seconds\" % sum ( wct ))) print ( f \"all tasks - total: { toc } seconds\" )","title":"main()"},{"location":"run_local/#running-interactively","text":"The model can also be run interactively in the repl. Start a python session from the root directory of TITAN , and follow along! We'll use the sample params file tests/params/basic.yml in all of these examples, but feel free to use a different one. Here is how to perform the basic steps of running the model: from .titan.parse_params import create_params from .titan.model import HIVModel outdir = 'results' params = create_params ( None , 'tests/params/basic.yml' , outdir ) model = HIVModel ( params ) model . run ( outdir ) This creates a params object using no setting (the None ), our test params, and tells create_params to put our computed params file in a directory called results . the 'results' directory must already be created We then use those params to create our model, and run it. We also have the model results saved to our results directory. We should now see a params.yml in our 'results' directory, and some reports showing what happened at different timesteps in the model. If we wanted to debug something, or look at a very specific metric that wasn't in our reports, we could instead step through the model one time-step at a time. Resuming from our code above, here's how we could do that. model2 = HIVModel ( params ) start_time = 0 end_time = 10 for i in range ( start_time , end_time ): model2 . time = i # update the model's time model2 . step ( outdir ) # do some introspection here, like... print ( model2 . pop . haart_counts ) # make sure the model state is reset for a new time step model2 . reset_trackets () If we want to write and read in a population instead of letting the model create one... from .titan import population_io as pio from .titan.population import Population from copy import deepcopy # let's make a copy of our params and tinker with the population a bit params2 = deepcopy ( params ) params2 . demographics . white . MSM . hiv . prob = 0.4 pop = Population ( params2 ) poppath = pio . write ( pop , outdir ) pop2 = pio . read ( poppath ) # this should be the same population as pop # pass a population to the model to use that instead of creating a new one model3 = HIVModel ( param2 , pop2 ) model3 . run ( outdir )","title":"Running Interactively"},{"location":"run_local/#running-the-tests","text":"To make sure everything is working, run the tests. A few of the tests (marked integration_stochastic ) sometimes fail as they are testing for general behavior and not specific correctness, but all other tests should always pass. python -m pytest","title":"Running the Tests"},{"location":"run_oscar/","text":"Use the subTitan.sh script to submit slurm batch jobs.","title":"Running on Oscar"},{"location":"api/agent/","text":"This class constructs and represents an agent within the population __init__ ( self , sex_type , age , race , drug_use , location , id = None ) special Initialize an agent based on given properties Parameters: Name Type Description Default id Optional[int] Unique agent ID None sex_type str Name of defined sex type (e.g. MSM) [params.classes.sex_types] required age int Agents initialization age required race str Race of agent [params.classes.races] required drug_use str Drug use flag [params.classes.drug_types] required Source code in titan/agent.py def __init__ ( self , sex_type : str , age : int , race : str , drug_use : str , location : Location , id : Optional [ int ] = None , ) -> None : \"\"\" Initialize an agent based on given properties Args: id: Unique agent ID sex_type: Name of defined sex type (e.g. MSM) [params.classes.sex_types] age: Agents initialization age race: Race of agent [params.classes.races] drug_use: Drug use flag [params.classes.drug_types] \"\"\" # self.id is unique ID number used to track each person agent. if id is not None : self . id = id else : self . id = self . next_agent_id self . update_id_counter ( self . id ) # agent properties self . sex_type = sex_type self . age = age self . age_bin = 0 self . race = race self . drug_type = drug_use self . location = location if self . drug_type == \"Inj\" : self . population = \"PWID\" else : self . population = self . sex_type self . msmw = False self . sex_role = \"versatile\" # agent-partner params self . relationships : Set [ Relationship ] = set () self . partners : Dict [ str , Set ] = {} self . mean_num_partners : Dict [ str , int ] = {} self . target_partners : Dict [ str , int ] = {} # agent STI params self . hiv = False self . hiv_time = 0 self . hiv_dx = False self . aids = False # agent treatment params self . haart = False self . haart_time = 0 self . haart_adherence = 0 self . ssp = False self . prep = False self . prep_adherence = 0 self . intervention_ever = False self . random_trial_enrolled = False self . vaccine = False self . vaccine_time = 0 self . vaccine_type = \"\" self . partner_traced = False self . trace_time = 0 self . prep_awareness = False self . prep_opinion = 0.0 self . prep_type = \"\" self . pca = False self . pca_suitable = False # PrEP pharmacokinetics self . prep_load = 0.0 self . prep_last_dose = 0 # agent high risk params self . high_risk = False self . high_risk_time = 0 self . high_risk_ever = False # agent incarcartion params self . incar = False self . incar_time = 0 __repr__ ( self ) special Repr formatting of agent object Returns: Type Description str agent ID as str Source code in titan/agent.py def __repr__ ( self ) -> str : \"\"\" Repr formatting of agent object returns: agent ID as str \"\"\" return str ( self . id ) __str__ ( self ) special String formatting of agent object Returns: Type Description str String formatted tab-deliminated agent properties Source code in titan/agent.py def __str__ ( self ) -> str : \"\"\" String formatting of agent object returns: String formatted tab-deliminated agent properties \"\"\" return ( f \" \\t { self . id } \\t { self . age } \\t { self . sex_type } \\t { self . drug_type } \\t \" f \" { self . race } \\t { self . hiv } \" ) cdc_eligible ( self ) Determine agent eligibility for PrEP under CDC criteria Returns: Type Description bool cdc eligibility Source code in titan/agent.py def cdc_eligible ( self ) -> bool : \"\"\" Determine agent eligibility for PrEP under CDC criteria returns: cdc eligibility \"\"\" if self . is_msm (): return True ongoing_duration = self . location . params . partnership . ongoing_duration for rel in self . relationships : partner = rel . get_partner ( self ) if rel . duration > ongoing_duration and partner . hiv_dx : return True if partner . drug_type == \"Inj\" or partner . is_msm (): return True return False enroll_prep ( self , rand_gen ) Enroll an agent in PrEP Parameters: Name Type Description Default rand_gen random number generator required Source code in titan/agent.py def enroll_prep ( self , rand_gen ): \"\"\" Enroll an agent in PrEP args: rand_gen: random number generator \"\"\" params = self . location . params self . prep = True self . prep_load = params . prep . peak_load self . prep_last_dose = 0 if ( rand_gen . random () < params . demographics [ self . race ][ self . sex_type ] . prep . adherence ): self . prep_adherence = 1 else : self . prep_adherence = 0 # set PrEP load and dosestep for PCK if \"Inj\" in params . prep . type and \"Oral\" in params . prep . type : if rand_gen . random () < params . prep . lai . prob : self . prep_type = \"Inj\" else : self . prep_type = \"Oral\" else : self . prep_type = params . prep . type [ 0 ] get_acute_status ( self , acute_time_period ) Get acute status of agent at time Parameters: Name Type Description Default acute_time_period How long an agent with HIV is acute for required Returns: Type Description bool whether an agent is acute Source code in titan/agent.py def get_acute_status ( self , acute_time_period ) -> bool : \"\"\" Get acute status of agent at time args: acute_time_period: How long an agent with HIV is acute for returns: whether an agent is acute \"\"\" hiv_t = self . hiv_time if acute_time_period >= hiv_t > 0 : return True else : return False get_num_partners ( self , bond_types = None ) Get the number of partners an agent has, optionally filtered by bond type Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise total number of partners returned None Returns: Type Description int the number of partners the agent has Source code in titan/agent.py def get_num_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> int : \"\"\" Get the number of partners an agent has, optionally filtered by bond type args: bond_types: list of bond types which will filter the partners, otherwise total number of partners returned returns: the number of partners the agent has \"\"\" return len ( self . get_partners ( bond_types )) get_number_of_sex_acts ( self , rand_gen ) Number of sexActs an agent has done. Parameters: Name Type Description Default rand_gen random number generator (e.g. self.run_random in model) required Returns: Type Description int number of sex acts Source code in titan/agent.py def get_number_of_sex_acts ( self , rand_gen ) -> int : \"\"\" Number of sexActs an agent has done. args: rand_gen: random number generator (e.g. self.run_random in model) returns: number of sex acts \"\"\" freq_params = self . location . params . partnership . sex . frequency if freq_params . type == \"bins\" : rv = rand_gen . random () for i in range ( 1 , 6 ): p = freq_params . bins [ i ] . prob if rv <= p : break min_frequency = freq_params . bins [ i ] . min max_frequency = freq_params . bins [ i ] . max return rand_gen . randint ( min_frequency , max_frequency ) elif freq_params . type == \"distribution\" : return round ( safe_dist ( freq_params . distribution , rand_gen )) else : raise Exception ( \"Sex acts must be defined as bin or distribution\" ) get_partners ( self , bond_types = None ) Get all of an agents partners or those with specific bond types Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise all partners returned None Returns: Type Description Set[Agent] set of agent's partners Source code in titan/agent.py def get_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> Set [ \"Agent\" ]: \"\"\" Get all of an agents partners or those with specific bond types args: bond_types: list of bond types which will filter the partners, otherwise all partners returned returns: set of agent's partners \"\"\" if bond_types : partners = set () for bond in bond_types : partners . update ( self . partners [ bond ]) else : partners = { partner for partner in self . iter_partners ()} return partners has_partners ( self ) Determine whether an agent has any partners Returns: Type Description bool whether an agent has at least one partner Source code in titan/agent.py def has_partners ( self ) -> bool : \"\"\" Determine whether an agent has any partners returns: whether an agent has at least one partner \"\"\" return any ( self . iter_partners ()) is_msm ( self ) Determine whether an agent is a man who can have sex with men Returns: Type Description bool if agent is MSM Source code in titan/agent.py def is_msm ( self ) -> bool : \"\"\" Determine whether an agent is a man who can have sex with men returns: if agent is MSM \"\"\" sex_dict = self . location . params . classes . sex_types if sex_dict [ self . sex_type ] . gender != \"M\" : return False for sex_type in sex_dict [ self . sex_type ] . sleeps_with : if sex_dict [ sex_type ] . gender == \"M\" : return True return False iter_partners ( self ) Get an iterator over an agent's partners Returns: Type Description Iterator[Agent] iterator of agent partners Source code in titan/agent.py def iter_partners ( self ) -> Iterator [ \"Agent\" ]: \"\"\" Get an iterator over an agent's partners returns: iterator of agent partners \"\"\" for partner_set in self . partners . values (): for partner in partner_set : yield partner prep_eligible ( self ) Determine if an agent is eligible for PrEP Returns: Type Description bool prep eligibility Source code in titan/agent.py def prep_eligible ( self ) -> bool : \"\"\" Determine if an agent is eligible for PrEP returns: prep eligibility \"\"\" target_model = self . location . params . prep . target_model gender = self . location . params . classes . sex_types [ self . sex_type ] . gender # if agent is already on prep, not eligible to enroll if self . prep or self . vaccine : return False all_eligible_models = { \"Allcomers\" , \"Racial\" } if all_eligible_models . intersection ( target_model ): return True if \"cdc_women\" in target_model : if gender == \"F\" : if self . cdc_eligible (): return True if \"cdc_msm\" in target_model : if gender == \"M\" and self . cdc_eligible (): return True if \"pwid_sex\" in target_model : if self . drug_type == \"Inj\" and self . cdc_eligible (): return True if \"pwid\" in target_model : if self . drug_type == \"Inj\" : return True if \"ssp_sex\" in target_model : if self . ssp and self . cdc_eligible (): return True if \"ssp\" in target_model : if self . ssp : return True return False update_prep_load ( self ) Determine and update load of PrEP concentration in agent. Source code in titan/agent.py def update_prep_load ( self ): \"\"\" Determine and update load of PrEP concentration in agent. \"\"\" params = self . location . params # N(t) = N0 (0.5)^(t/t_half) self . prep_last_dose += 1 if self . prep_last_dose > params . model . time . steps_per_year : self . prep_load = 0.0 self . prep = False self . prep_type = \"\" self . prep_last_dose = 0 else : annualized_last_dose = ( self . prep_last_dose / params . model . time . steps_per_year ) annualized_half_life = params . prep . half_life / 365 self . prep_load = params . prep . peak_load * ( ( 0.5 ) ** ( annualized_last_dose / annualized_half_life ) ) vaccinate ( self ) Vaccinate an agent and update relevant fields. Source code in titan/agent.py def vaccinate ( self ) -> None : \"\"\" Vaccinate an agent and update relevant fields. \"\"\" self . vaccine = True self . vaccine_type = self . location . params . vaccine . type self . vaccine_time = 1","title":"Agent"},{"location":"api/agent/#titan.agent.Agent.__init__","text":"Initialize an agent based on given properties Parameters: Name Type Description Default id Optional[int] Unique agent ID None sex_type str Name of defined sex type (e.g. MSM) [params.classes.sex_types] required age int Agents initialization age required race str Race of agent [params.classes.races] required drug_use str Drug use flag [params.classes.drug_types] required Source code in titan/agent.py def __init__ ( self , sex_type : str , age : int , race : str , drug_use : str , location : Location , id : Optional [ int ] = None , ) -> None : \"\"\" Initialize an agent based on given properties Args: id: Unique agent ID sex_type: Name of defined sex type (e.g. MSM) [params.classes.sex_types] age: Agents initialization age race: Race of agent [params.classes.races] drug_use: Drug use flag [params.classes.drug_types] \"\"\" # self.id is unique ID number used to track each person agent. if id is not None : self . id = id else : self . id = self . next_agent_id self . update_id_counter ( self . id ) # agent properties self . sex_type = sex_type self . age = age self . age_bin = 0 self . race = race self . drug_type = drug_use self . location = location if self . drug_type == \"Inj\" : self . population = \"PWID\" else : self . population = self . sex_type self . msmw = False self . sex_role = \"versatile\" # agent-partner params self . relationships : Set [ Relationship ] = set () self . partners : Dict [ str , Set ] = {} self . mean_num_partners : Dict [ str , int ] = {} self . target_partners : Dict [ str , int ] = {} # agent STI params self . hiv = False self . hiv_time = 0 self . hiv_dx = False self . aids = False # agent treatment params self . haart = False self . haart_time = 0 self . haart_adherence = 0 self . ssp = False self . prep = False self . prep_adherence = 0 self . intervention_ever = False self . random_trial_enrolled = False self . vaccine = False self . vaccine_time = 0 self . vaccine_type = \"\" self . partner_traced = False self . trace_time = 0 self . prep_awareness = False self . prep_opinion = 0.0 self . prep_type = \"\" self . pca = False self . pca_suitable = False # PrEP pharmacokinetics self . prep_load = 0.0 self . prep_last_dose = 0 # agent high risk params self . high_risk = False self . high_risk_time = 0 self . high_risk_ever = False # agent incarcartion params self . incar = False self . incar_time = 0","title":"__init__()"},{"location":"api/agent/#titan.agent.Agent.__repr__","text":"Repr formatting of agent object Returns: Type Description str agent ID as str Source code in titan/agent.py def __repr__ ( self ) -> str : \"\"\" Repr formatting of agent object returns: agent ID as str \"\"\" return str ( self . id )","title":"__repr__()"},{"location":"api/agent/#titan.agent.Agent.__str__","text":"String formatting of agent object Returns: Type Description str String formatted tab-deliminated agent properties Source code in titan/agent.py def __str__ ( self ) -> str : \"\"\" String formatting of agent object returns: String formatted tab-deliminated agent properties \"\"\" return ( f \" \\t { self . id } \\t { self . age } \\t { self . sex_type } \\t { self . drug_type } \\t \" f \" { self . race } \\t { self . hiv } \" )","title":"__str__()"},{"location":"api/agent/#titan.agent.Agent.cdc_eligible","text":"Determine agent eligibility for PrEP under CDC criteria Returns: Type Description bool cdc eligibility Source code in titan/agent.py def cdc_eligible ( self ) -> bool : \"\"\" Determine agent eligibility for PrEP under CDC criteria returns: cdc eligibility \"\"\" if self . is_msm (): return True ongoing_duration = self . location . params . partnership . ongoing_duration for rel in self . relationships : partner = rel . get_partner ( self ) if rel . duration > ongoing_duration and partner . hiv_dx : return True if partner . drug_type == \"Inj\" or partner . is_msm (): return True return False","title":"cdc_eligible()"},{"location":"api/agent/#titan.agent.Agent.enroll_prep","text":"Enroll an agent in PrEP Parameters: Name Type Description Default rand_gen random number generator required Source code in titan/agent.py def enroll_prep ( self , rand_gen ): \"\"\" Enroll an agent in PrEP args: rand_gen: random number generator \"\"\" params = self . location . params self . prep = True self . prep_load = params . prep . peak_load self . prep_last_dose = 0 if ( rand_gen . random () < params . demographics [ self . race ][ self . sex_type ] . prep . adherence ): self . prep_adherence = 1 else : self . prep_adherence = 0 # set PrEP load and dosestep for PCK if \"Inj\" in params . prep . type and \"Oral\" in params . prep . type : if rand_gen . random () < params . prep . lai . prob : self . prep_type = \"Inj\" else : self . prep_type = \"Oral\" else : self . prep_type = params . prep . type [ 0 ]","title":"enroll_prep()"},{"location":"api/agent/#titan.agent.Agent.get_acute_status","text":"Get acute status of agent at time Parameters: Name Type Description Default acute_time_period How long an agent with HIV is acute for required Returns: Type Description bool whether an agent is acute Source code in titan/agent.py def get_acute_status ( self , acute_time_period ) -> bool : \"\"\" Get acute status of agent at time args: acute_time_period: How long an agent with HIV is acute for returns: whether an agent is acute \"\"\" hiv_t = self . hiv_time if acute_time_period >= hiv_t > 0 : return True else : return False","title":"get_acute_status()"},{"location":"api/agent/#titan.agent.Agent.get_num_partners","text":"Get the number of partners an agent has, optionally filtered by bond type Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise total number of partners returned None Returns: Type Description int the number of partners the agent has Source code in titan/agent.py def get_num_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> int : \"\"\" Get the number of partners an agent has, optionally filtered by bond type args: bond_types: list of bond types which will filter the partners, otherwise total number of partners returned returns: the number of partners the agent has \"\"\" return len ( self . get_partners ( bond_types ))","title":"get_num_partners()"},{"location":"api/agent/#titan.agent.Agent.get_number_of_sex_acts","text":"Number of sexActs an agent has done. Parameters: Name Type Description Default rand_gen random number generator (e.g. self.run_random in model) required Returns: Type Description int number of sex acts Source code in titan/agent.py def get_number_of_sex_acts ( self , rand_gen ) -> int : \"\"\" Number of sexActs an agent has done. args: rand_gen: random number generator (e.g. self.run_random in model) returns: number of sex acts \"\"\" freq_params = self . location . params . partnership . sex . frequency if freq_params . type == \"bins\" : rv = rand_gen . random () for i in range ( 1 , 6 ): p = freq_params . bins [ i ] . prob if rv <= p : break min_frequency = freq_params . bins [ i ] . min max_frequency = freq_params . bins [ i ] . max return rand_gen . randint ( min_frequency , max_frequency ) elif freq_params . type == \"distribution\" : return round ( safe_dist ( freq_params . distribution , rand_gen )) else : raise Exception ( \"Sex acts must be defined as bin or distribution\" )","title":"get_number_of_sex_acts()"},{"location":"api/agent/#titan.agent.Agent.get_partners","text":"Get all of an agents partners or those with specific bond types Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise all partners returned None Returns: Type Description Set[Agent] set of agent's partners Source code in titan/agent.py def get_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> Set [ \"Agent\" ]: \"\"\" Get all of an agents partners or those with specific bond types args: bond_types: list of bond types which will filter the partners, otherwise all partners returned returns: set of agent's partners \"\"\" if bond_types : partners = set () for bond in bond_types : partners . update ( self . partners [ bond ]) else : partners = { partner for partner in self . iter_partners ()} return partners","title":"get_partners()"},{"location":"api/agent/#titan.agent.Agent.has_partners","text":"Determine whether an agent has any partners Returns: Type Description bool whether an agent has at least one partner Source code in titan/agent.py def has_partners ( self ) -> bool : \"\"\" Determine whether an agent has any partners returns: whether an agent has at least one partner \"\"\" return any ( self . iter_partners ())","title":"has_partners()"},{"location":"api/agent/#titan.agent.Agent.is_msm","text":"Determine whether an agent is a man who can have sex with men Returns: Type Description bool if agent is MSM Source code in titan/agent.py def is_msm ( self ) -> bool : \"\"\" Determine whether an agent is a man who can have sex with men returns: if agent is MSM \"\"\" sex_dict = self . location . params . classes . sex_types if sex_dict [ self . sex_type ] . gender != \"M\" : return False for sex_type in sex_dict [ self . sex_type ] . sleeps_with : if sex_dict [ sex_type ] . gender == \"M\" : return True return False","title":"is_msm()"},{"location":"api/agent/#titan.agent.Agent.iter_partners","text":"Get an iterator over an agent's partners Returns: Type Description Iterator[Agent] iterator of agent partners Source code in titan/agent.py def iter_partners ( self ) -> Iterator [ \"Agent\" ]: \"\"\" Get an iterator over an agent's partners returns: iterator of agent partners \"\"\" for partner_set in self . partners . values (): for partner in partner_set : yield partner","title":"iter_partners()"},{"location":"api/agent/#titan.agent.Agent.prep_eligible","text":"Determine if an agent is eligible for PrEP Returns: Type Description bool prep eligibility Source code in titan/agent.py def prep_eligible ( self ) -> bool : \"\"\" Determine if an agent is eligible for PrEP returns: prep eligibility \"\"\" target_model = self . location . params . prep . target_model gender = self . location . params . classes . sex_types [ self . sex_type ] . gender # if agent is already on prep, not eligible to enroll if self . prep or self . vaccine : return False all_eligible_models = { \"Allcomers\" , \"Racial\" } if all_eligible_models . intersection ( target_model ): return True if \"cdc_women\" in target_model : if gender == \"F\" : if self . cdc_eligible (): return True if \"cdc_msm\" in target_model : if gender == \"M\" and self . cdc_eligible (): return True if \"pwid_sex\" in target_model : if self . drug_type == \"Inj\" and self . cdc_eligible (): return True if \"pwid\" in target_model : if self . drug_type == \"Inj\" : return True if \"ssp_sex\" in target_model : if self . ssp and self . cdc_eligible (): return True if \"ssp\" in target_model : if self . ssp : return True return False","title":"prep_eligible()"},{"location":"api/agent/#titan.agent.Agent.update_prep_load","text":"Determine and update load of PrEP concentration in agent. Source code in titan/agent.py def update_prep_load ( self ): \"\"\" Determine and update load of PrEP concentration in agent. \"\"\" params = self . location . params # N(t) = N0 (0.5)^(t/t_half) self . prep_last_dose += 1 if self . prep_last_dose > params . model . time . steps_per_year : self . prep_load = 0.0 self . prep = False self . prep_type = \"\" self . prep_last_dose = 0 else : annualized_last_dose = ( self . prep_last_dose / params . model . time . steps_per_year ) annualized_half_life = params . prep . half_life / 365 self . prep_load = params . prep . peak_load * ( ( 0.5 ) ** ( annualized_last_dose / annualized_half_life ) )","title":"update_prep_load()"},{"location":"api/agent/#titan.agent.Agent.vaccinate","text":"Vaccinate an agent and update relevant fields. Source code in titan/agent.py def vaccinate ( self ) -> None : \"\"\" Vaccinate an agent and update relevant fields. \"\"\" self . vaccine = True self . vaccine_type = self . location . params . vaccine . type self . vaccine_time = 1","title":"vaccinate()"},{"location":"api/agent_set/","text":"Container for agents into heirarchical sets (e.g. all_agents > hiv_agents) __contains__ ( self , item ) special Is an agent a member of this agent set Examples: if agent in agent_set : # do something Returns: Type Description bool whether agent is part of set Source code in titan/agent.py def __contains__ ( self , item ) -> bool : \"\"\" Is an agent a member of this agent set example: ```py if agent in agent_set: # do something ``` returns: whether agent is part of set \"\"\" return self . members . __contains__ ( item ) __init__ ( self , id , parent = None ) special Constructor of an AgentSet Parameters: Name Type Description Default id str name of the set required parent Optional[AgentSet] the set this set is a subset of None Source code in titan/agent.py def __init__ ( self , id : str , parent : Optional [ \"AgentSet\" ] = None , ): \"\"\" Constructor of an AgentSet args: id: name of the set parent: the set this set is a subset of \"\"\" # members stores agent set members in a dictionary keyed by ID self . id = id self . members : Set [ Agent ] = set () self . subset : Dict [ str , AgentSet ] = {} # parent_set stores the parent set if this set is a member of an # AgentSet class instance. For example, for a set that is a # member of a larger set, the _parent_set for that set would # be that larger set. self . parent_set = parent if parent : parent . add_subset ( self ) __iter__ ( self ) special Iterate over the memers in the set Examples: for agent in agent_set : # do something with agent Returns: Type Description Iterator[titan.agent.Agent] iterator over member agents Source code in titan/agent.py def __iter__ ( self ) -> Iterator [ Agent ]: \"\"\" Iterate over the memers in the set example: ```py for agent in agent_set: # do something with agent ``` returns: iterator over member agents \"\"\" return self . members . __iter__ () add_agent ( self , agent ) Adds an agent to the set and any parent sets Parameters: Name Type Description Default agent Agent agent to add required Source code in titan/agent.py def add_agent ( self , agent : Agent ) -> None : \"\"\" Adds an agent to the set and any parent sets args: agent: agent to add \"\"\" self . members . add ( agent ) if self . parent_set is not None : self . parent_set . add_agent ( agent ) add_subset ( self , subset ) Adds a new AgentSet to the current sets subset. Parameters: Name Type Description Default subset AgentSet subset to add to this set required Source code in titan/agent.py def add_subset ( self , subset : \"AgentSet\" ) -> None : \"\"\" Adds a new AgentSet to the current sets subset. args: subset: subset to add to this set \"\"\" if subset . id not in self . subset : self . subset [ subset . id ] = subset clear_set ( self ) Clears a set of any members and subsets Source code in titan/agent.py def clear_set ( self ): \"\"\" Clears a set of any members and subsets \"\"\" self . members : Set [ Agent ] = set () self . subset : Dict [ str , str ] = {} iter_subset ( self ) Iterate over the subsets of this agent set Returns: Type Description Iterator[AgentSet] iterator of agent sets Source code in titan/agent.py def iter_subset ( self ) -> Iterator [ \"AgentSet\" ]: \"\"\" Iterate over the subsets of this agent set returns: iterator of agent sets \"\"\" for subset in list ( self . subset . values ()): yield subset num_members ( self ) Number of members in the set Returns: Type Description int number of members Source code in titan/agent.py def num_members ( self ) -> int : \"\"\" Number of members in the set returns: number of members \"\"\" return len ( self . members ) print_subsets ( self ) Pretty print the subsets of this agent set Source code in titan/agent.py def print_subsets ( self ): \"\"\" Pretty print the subsets of this agent set \"\"\" print ( f \" \\t __________ { self . id } __________\" ) print ( \" \\t ID \\t\\t N \\t\\t %\" ) for set in self . iter_subset (): print ( \" \\t {:6} \\t\\t {:5} \\t\\t {:.2} \" . format ( set . id , set . num_members (), safe_divide ( set . num_members (), set . parent_set . num_members ()), ) ) for subset in set . iter_subset (): print ( \" \\t {:4} \\t\\t {:5} \\t\\t {:.2} \" . format ( subset . id , subset . num_members (), safe_divide ( subset . num_members (), subset . parent_set . num_members () ), ) ) print ( \" \\t ______________ END ______________\" ) remove_agent ( self , agent ) Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. Parameters: Name Type Description Default agent Agent agent to remove required Source code in titan/agent.py def remove_agent ( self , agent : Agent ) -> None : \"\"\" Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. args: agent: agent to remove \"\"\" if agent in self . members : self . members . remove ( agent ) for subset in self . iter_subset (): subset . remove_agent ( agent )","title":"AgentSet"},{"location":"api/agent_set/#titan.agent.AgentSet.__contains__","text":"Is an agent a member of this agent set Examples: if agent in agent_set : # do something Returns: Type Description bool whether agent is part of set Source code in titan/agent.py def __contains__ ( self , item ) -> bool : \"\"\" Is an agent a member of this agent set example: ```py if agent in agent_set: # do something ``` returns: whether agent is part of set \"\"\" return self . members . __contains__ ( item )","title":"__contains__()"},{"location":"api/agent_set/#titan.agent.AgentSet.__init__","text":"Constructor of an AgentSet Parameters: Name Type Description Default id str name of the set required parent Optional[AgentSet] the set this set is a subset of None Source code in titan/agent.py def __init__ ( self , id : str , parent : Optional [ \"AgentSet\" ] = None , ): \"\"\" Constructor of an AgentSet args: id: name of the set parent: the set this set is a subset of \"\"\" # members stores agent set members in a dictionary keyed by ID self . id = id self . members : Set [ Agent ] = set () self . subset : Dict [ str , AgentSet ] = {} # parent_set stores the parent set if this set is a member of an # AgentSet class instance. For example, for a set that is a # member of a larger set, the _parent_set for that set would # be that larger set. self . parent_set = parent if parent : parent . add_subset ( self )","title":"__init__()"},{"location":"api/agent_set/#titan.agent.AgentSet.__iter__","text":"Iterate over the memers in the set Examples: for agent in agent_set : # do something with agent Returns: Type Description Iterator[titan.agent.Agent] iterator over member agents Source code in titan/agent.py def __iter__ ( self ) -> Iterator [ Agent ]: \"\"\" Iterate over the memers in the set example: ```py for agent in agent_set: # do something with agent ``` returns: iterator over member agents \"\"\" return self . members . __iter__ ()","title":"__iter__()"},{"location":"api/agent_set/#titan.agent.AgentSet.add_agent","text":"Adds an agent to the set and any parent sets Parameters: Name Type Description Default agent Agent agent to add required Source code in titan/agent.py def add_agent ( self , agent : Agent ) -> None : \"\"\" Adds an agent to the set and any parent sets args: agent: agent to add \"\"\" self . members . add ( agent ) if self . parent_set is not None : self . parent_set . add_agent ( agent )","title":"add_agent()"},{"location":"api/agent_set/#titan.agent.AgentSet.add_subset","text":"Adds a new AgentSet to the current sets subset. Parameters: Name Type Description Default subset AgentSet subset to add to this set required Source code in titan/agent.py def add_subset ( self , subset : \"AgentSet\" ) -> None : \"\"\" Adds a new AgentSet to the current sets subset. args: subset: subset to add to this set \"\"\" if subset . id not in self . subset : self . subset [ subset . id ] = subset","title":"add_subset()"},{"location":"api/agent_set/#titan.agent.AgentSet.clear_set","text":"Clears a set of any members and subsets Source code in titan/agent.py def clear_set ( self ): \"\"\" Clears a set of any members and subsets \"\"\" self . members : Set [ Agent ] = set () self . subset : Dict [ str , str ] = {}","title":"clear_set()"},{"location":"api/agent_set/#titan.agent.AgentSet.iter_subset","text":"Iterate over the subsets of this agent set Returns: Type Description Iterator[AgentSet] iterator of agent sets Source code in titan/agent.py def iter_subset ( self ) -> Iterator [ \"AgentSet\" ]: \"\"\" Iterate over the subsets of this agent set returns: iterator of agent sets \"\"\" for subset in list ( self . subset . values ()): yield subset","title":"iter_subset()"},{"location":"api/agent_set/#titan.agent.AgentSet.num_members","text":"Number of members in the set Returns: Type Description int number of members Source code in titan/agent.py def num_members ( self ) -> int : \"\"\" Number of members in the set returns: number of members \"\"\" return len ( self . members )","title":"num_members()"},{"location":"api/agent_set/#titan.agent.AgentSet.print_subsets","text":"Pretty print the subsets of this agent set Source code in titan/agent.py def print_subsets ( self ): \"\"\" Pretty print the subsets of this agent set \"\"\" print ( f \" \\t __________ { self . id } __________\" ) print ( \" \\t ID \\t\\t N \\t\\t %\" ) for set in self . iter_subset (): print ( \" \\t {:6} \\t\\t {:5} \\t\\t {:.2} \" . format ( set . id , set . num_members (), safe_divide ( set . num_members (), set . parent_set . num_members ()), ) ) for subset in set . iter_subset (): print ( \" \\t {:4} \\t\\t {:5} \\t\\t {:.2} \" . format ( subset . id , subset . num_members (), safe_divide ( subset . num_members (), subset . parent_set . num_members () ), ) ) print ( \" \\t ______________ END ______________\" )","title":"print_subsets()"},{"location":"api/agent_set/#titan.agent.AgentSet.remove_agent","text":"Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. Parameters: Name Type Description Default agent Agent agent to remove required Source code in titan/agent.py def remove_agent ( self , agent : Agent ) -> None : \"\"\" Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. args: agent: agent to remove \"\"\" if agent in self . members : self . members . remove ( agent ) for subset in self . iter_subset (): subset . remove_agent ( agent )","title":"remove_agent()"},{"location":"api/location/","text":"Location __init__ ( self , name , defn , params ) special This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. Parameters: Name Type Description Default name str name of the location required defn ObjMap definition for this location required params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , name : str , defn : ObjMap , params : ObjMap ): \"\"\" This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. args: name: name of the location defn: definition for this location params: model parameters \"\"\" # location properties self . name = name self . params = self . create_params ( params ) self . ppl = defn . ppl # percent of overall population assigned to this location # value/weight maps needed for creating new agents in this location self . pop_weights : Dict [ str , Dict [ str , List [ Any ]]] = {} self . role_weights : Dict [ str , Dict ] = {} self . drug_weights : Dict [ str , Dict ] = {} self . init_weights () self . edges : Set [ \"LocationEdge\" ] = set ({}) # or maybe edges instead create_params ( self , params ) Scale or override the generic parameters with any location based scaling from params.location.scaling Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description ObjMap new parameter object with scaled values for this location Source code in titan/location.py def create_params ( self , params : ObjMap ) -> ObjMap : \"\"\" Scale or override the generic parameters with any location based scaling from params.location.scaling args: params: model parameters returns: new parameter object with scaled values for this location \"\"\" new_params = deepcopy ( params ) defns = new_params . location . scaling [ self . name ] for param_path , defn in defns . items (): if param_path != \"ls_default\" : if defn . field == \"scalar\" : utils . scale_param ( new_params , param_path , defn . scalar ) elif defn . field == \"override\" : utils . override_param ( new_params , param_path , defn . override ) return new_params init_weights ( self ) Create the containers to hold values and weights for randomly selecting: sex_role drug_type race sex_type Source code in titan/location.py def init_weights ( self ): \"\"\" Create the containers to hold values and weights for randomly selecting: * sex_role * drug_type * race * sex_type \"\"\" for race in self . params . classes . races : self . role_weights [ race ] = {} self . drug_weights [ race ] = {} self . pop_weights [ race ] = {} self . pop_weights [ race ][ \"values\" ] = [] self . pop_weights [ race ][ \"weights\" ] = [] for st in self . params . classes . sex_types : self . pop_weights [ race ][ \"values\" ] . append ( st ) self . pop_weights [ race ][ \"weights\" ] . append ( self . params . demographics [ race ][ st ] . ppl ) self . role_weights [ race ][ st ] = {} self . role_weights [ race ][ st ][ \"values\" ] = [] self . role_weights [ race ][ st ][ \"weights\" ] = [] self . drug_weights [ race ][ st ] = {} self . drug_weights [ race ][ st ][ \"values\" ] = [] self . drug_weights [ race ][ st ][ \"weights\" ] = [] for role , prob in self . params . demographics [ race ][ st ] . sex_role . init . items (): self . role_weights [ race ][ st ][ \"values\" ] . append ( role ) self . role_weights [ race ][ st ][ \"weights\" ] . append ( prob ) for use_type , prob in self . params . demographics [ race ][ st ] . drug_type . items (): self . drug_weights [ race ][ st ][ \"values\" ] . append ( use_type ) self . drug_weights [ race ][ st ][ \"weights\" ] . append ( prob . init ) LocationEdge __init__ ( self , loc1 , loc2 , distance , id = None ) special Construct a location edge, which holds attributes that relate two Locations. Parameters: Name Type Description Default loc1 Location the first location required loc2 Location the other location required distance float a measure of distance between the locations required id Optional[int] a unique identifier for this edge None Source code in titan/location.py def __init__ ( self , loc1 : Location , loc2 : Location , distance : float , id : Optional [ int ] = None ): \"\"\" Construct a location edge, which holds attributes that relate two Locations. args: loc1: the first location loc2: the other location distance: a measure of distance between the locations id: a unique identifier for this edge \"\"\" assert loc1 != loc2 , \"can't have a location self-edge\" # self.id is unique ID number used to track each edge. if id is not None : self . id = id else : self . id = self . next_edge_id self . update_id_counter ( self . id ) self . edge = set ({ loc1 , loc2 }) self . distance = distance Geography __init__ ( self , params ) special Umbrella class to initialize/store locations and location edges for a population Parameters: Name Type Description Default params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , params : ObjMap ): \"\"\" Umbrella class to initialize/store locations and location edges for a population args: params: model parameters \"\"\" self . locations : Dict [ str , Location ] = { location : Location ( location , defn , params ) for location , defn in params . classes . locations . items () } self . edges : Set [ LocationEdge ] = set () for name , defn in params . location . edges . items (): if name != \"edge_default\" : loc1 = self . locations [ defn . location_1 ] loc2 = self . locations [ defn . location_2 ] self . edges . add ( LocationEdge ( loc1 , loc2 , defn . distance ))","title":"Location"},{"location":"api/location/#location","text":"","title":"Location"},{"location":"api/location/#titan.location.Location.__init__","text":"This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. Parameters: Name Type Description Default name str name of the location required defn ObjMap definition for this location required params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , name : str , defn : ObjMap , params : ObjMap ): \"\"\" This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. args: name: name of the location defn: definition for this location params: model parameters \"\"\" # location properties self . name = name self . params = self . create_params ( params ) self . ppl = defn . ppl # percent of overall population assigned to this location # value/weight maps needed for creating new agents in this location self . pop_weights : Dict [ str , Dict [ str , List [ Any ]]] = {} self . role_weights : Dict [ str , Dict ] = {} self . drug_weights : Dict [ str , Dict ] = {} self . init_weights () self . edges : Set [ \"LocationEdge\" ] = set ({}) # or maybe edges instead","title":"__init__()"},{"location":"api/location/#titan.location.Location.create_params","text":"Scale or override the generic parameters with any location based scaling from params.location.scaling Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description ObjMap new parameter object with scaled values for this location Source code in titan/location.py def create_params ( self , params : ObjMap ) -> ObjMap : \"\"\" Scale or override the generic parameters with any location based scaling from params.location.scaling args: params: model parameters returns: new parameter object with scaled values for this location \"\"\" new_params = deepcopy ( params ) defns = new_params . location . scaling [ self . name ] for param_path , defn in defns . items (): if param_path != \"ls_default\" : if defn . field == \"scalar\" : utils . scale_param ( new_params , param_path , defn . scalar ) elif defn . field == \"override\" : utils . override_param ( new_params , param_path , defn . override ) return new_params","title":"create_params()"},{"location":"api/location/#titan.location.Location.init_weights","text":"Create the containers to hold values and weights for randomly selecting: sex_role drug_type race sex_type Source code in titan/location.py def init_weights ( self ): \"\"\" Create the containers to hold values and weights for randomly selecting: * sex_role * drug_type * race * sex_type \"\"\" for race in self . params . classes . races : self . role_weights [ race ] = {} self . drug_weights [ race ] = {} self . pop_weights [ race ] = {} self . pop_weights [ race ][ \"values\" ] = [] self . pop_weights [ race ][ \"weights\" ] = [] for st in self . params . classes . sex_types : self . pop_weights [ race ][ \"values\" ] . append ( st ) self . pop_weights [ race ][ \"weights\" ] . append ( self . params . demographics [ race ][ st ] . ppl ) self . role_weights [ race ][ st ] = {} self . role_weights [ race ][ st ][ \"values\" ] = [] self . role_weights [ race ][ st ][ \"weights\" ] = [] self . drug_weights [ race ][ st ] = {} self . drug_weights [ race ][ st ][ \"values\" ] = [] self . drug_weights [ race ][ st ][ \"weights\" ] = [] for role , prob in self . params . demographics [ race ][ st ] . sex_role . init . items (): self . role_weights [ race ][ st ][ \"values\" ] . append ( role ) self . role_weights [ race ][ st ][ \"weights\" ] . append ( prob ) for use_type , prob in self . params . demographics [ race ][ st ] . drug_type . items (): self . drug_weights [ race ][ st ][ \"values\" ] . append ( use_type ) self . drug_weights [ race ][ st ][ \"weights\" ] . append ( prob . init )","title":"init_weights()"},{"location":"api/location/#locationedge","text":"","title":"LocationEdge"},{"location":"api/location/#titan.location.LocationEdge.__init__","text":"Construct a location edge, which holds attributes that relate two Locations. Parameters: Name Type Description Default loc1 Location the first location required loc2 Location the other location required distance float a measure of distance between the locations required id Optional[int] a unique identifier for this edge None Source code in titan/location.py def __init__ ( self , loc1 : Location , loc2 : Location , distance : float , id : Optional [ int ] = None ): \"\"\" Construct a location edge, which holds attributes that relate two Locations. args: loc1: the first location loc2: the other location distance: a measure of distance between the locations id: a unique identifier for this edge \"\"\" assert loc1 != loc2 , \"can't have a location self-edge\" # self.id is unique ID number used to track each edge. if id is not None : self . id = id else : self . id = self . next_edge_id self . update_id_counter ( self . id ) self . edge = set ({ loc1 , loc2 }) self . distance = distance","title":"__init__()"},{"location":"api/location/#geography","text":"","title":"Geography"},{"location":"api/location/#titan.location.Geography.__init__","text":"Umbrella class to initialize/store locations and location edges for a population Parameters: Name Type Description Default params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , params : ObjMap ): \"\"\" Umbrella class to initialize/store locations and location edges for a population args: params: model parameters \"\"\" self . locations : Dict [ str , Location ] = { location : Location ( location , defn , params ) for location , defn in params . classes . locations . items () } self . edges : Set [ LocationEdge ] = set () for name , defn in params . location . edges . items (): if name != \"edge_default\" : loc1 = self . locations [ defn . location_1 ] loc2 = self . locations [ defn . location_2 ] self . edges . add ( LocationEdge ( loc1 , loc2 , defn . distance ))","title":"__init__()"},{"location":"api/model/","text":"HIVModel The HIVModel class is used to model agent interactions as they progress through time. The model can be run on an existing Population or it can create a Population during its construction. The most common entry point to the model is run , which will run the model for all time steps. To run step by step, step can be iterated through instead, just be sure to reset_trackers between step s. __init__ ( self , params , population = None ) special This is the core class used to simulate the spread of HIV and drug use in one geography. Parameters: Name Type Description Default params ObjMap the parameter object for this model required population Optional[titan.population.Population] an initialized population to run the model on None Source code in titan/model.py def __init__ ( self , params : ObjMap , population : Optional [ Population ] = None , ): \"\"\" This is the core class used to simulate the spread of HIV and drug use in one geography. args: params: the parameter object for this model population: an initialized population to run the model on \"\"\" self . params = params # pre-fetch commonly used param sub-sets for performance self . features = params . features self . calibration = params . calibration print ( \"=== Begin Initialization Protocol === \\n \" ) if population is None : print ( \" \\t Generating new population\" ) self . pop = Population ( params ) else : print ( \" \\t Using provided population\" ) self . pop = population self . network_utils : Optional [ NetworkGraphUtils ] if params . model . network . enable : self . network_utils = NetworkGraphUtils ( self . pop . graph ) else : self . network_utils = None print ( \" \\n\\t Creating lists\" ) # Other lists / dictionaries self . new_infections = AgentSet ( \"new_infections\" ) self . new_dx = AgentSet ( \"new_dx\" ) self . new_incar_release = AgentSet ( \"new_incar_release\" ) self . new_high_risk = AgentSet ( \"new_high_risk\" ) self . new_prep = AgentSet ( \"new_prep\" ) self . ssp_enrolled_risk = 0.0 self . time = - 1 * self . params . model . time . burn_steps # burn is negative time self . id = nanoid . generate ( size = 8 ) # Set seed format. 0: pure random, else: fixed value self . run_seed = utils . get_check_rand_int ( params . model . seed . run ) print ( f \" \\t Run seed was set to: { self . run_seed } \" ) self . run_random = random . Random ( self . run_seed ) self . np_random = np . random . RandomState ( self . run_seed ) random . seed ( self . run_seed ) print (( \" \\t FIRST RANDOM CALL {} \" . format ( random . randint ( 0 , 100 )))) print ( \" \\t Resetting death count\" ) self . deaths : List [ Agent ] = [] # Number of death print ( \" \\n === Initialization Protocol Finished ===\" ) advance_vaccine ( self , agent ) Progress vaccine. Agents may receive injection or progress in time since injection. Parameters: Name Type Description Default agent Agent agent being updated required Source code in titan/model.py def advance_vaccine ( self , agent : Agent ): \"\"\" Progress vaccine. Agents may receive injection or progress in time since injection. args: agent: agent being updated \"\"\" if not self . features . vaccine : return None vaccine_params = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . vaccine if agent . vaccine : agent . vaccine_time += 1 if ( agent . location . params . vaccine . booster and agent . vaccine_time == vaccine_params . booster . interval and self . run_random . random () < vaccine_params . booster . prob ): agent . vaccinate () elif self . time == agent . location . params . vaccine . start_time : if self . run_random . random () < vaccine_params . prob : agent . vaccinate () agents_interact ( self , rel ) Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: Peer Change Agent Injection Sex Parameters: Name Type Description Default rel Relationship The relationship that the agents interact in required Returns: Type Description bool whether the agents interacted Source code in titan/model.py def agents_interact ( self , rel : Relationship ) -> bool : \"\"\" Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: * Peer Change Agent * Injection * Sex args: rel : The relationship that the agents interact in returns: whether the agents interacted \"\"\" interaction_types = self . params . classes . bond_types [ rel . bond_type ] . acts_allowed # If either agent is incarcerated, skip their interaction if rel . agent1 . incar or rel . agent2 . incar : return False # Agent 1 is HIV+, Agent 2 is not, Agent 2 is succept if rel . agent1 . hiv and not rel . agent2 . hiv : agent = rel . agent1 partner = rel . agent2 # If Agent 2 is HIV and Agent 1 is not, Agent 1 is succept elif not rel . agent1 . hiv and rel . agent2 . hiv : agent = rel . agent2 partner = rel . agent1 else : # neither agent is HIV or both are return False if self . params . features . pca and self . time >= self . params . prep . pca . start_time : if \"pca\" in interaction_types and rel . duration < rel . total_duration : self . pca_interaction ( rel ) if self . time >= self . params . hiv . start_time : if \"injection\" in interaction_types : self . injection_transmission ( agent , partner ) if \"sex\" in interaction_types : self . sex_transmission ( rel ) return True become_high_risk ( self , agent , duration = None ) Mark an agent as high risk and assign a duration to their high risk period Parameters: Name Type Description Default agent Agent agent becoming high risk required duration int duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] None Source code in titan/model.py def become_high_risk ( self , agent : Agent , duration : int = None ): \"\"\" Mark an agent as high risk and assign a duration to their high risk period args: agent: agent becoming high risk duration: duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] \"\"\" if not self . features . high_risk : return None if agent not in self . pop . high_risk_agents . members : self . pop . high_risk_agents . add_agent ( agent ) if not agent . high_risk_ever : self . new_high_risk . add_agent ( agent ) agent . high_risk = True agent . high_risk_ever = True if duration is not None : agent . high_risk_time = duration else : agent . high_risk_time = agent . location . params . high_risk . sex_based [ agent . sex_type ] . duration diagnose_hiv ( self , agent ) Stochastically test the agent for HIV. If tested, mark the agent as diagnosed and trace their partners (if partner tracing enabled). Parameters: Name Type Description Default agent Agent HIV positive agent to diagnose required Source code in titan/model.py def diagnose_hiv ( self , agent : Agent ): \"\"\" Stochastically test the agent for HIV. If tested, mark the agent as diagnosed and trace their partners (if partner tracing enabled). args: agent: HIV positive agent to diagnose \"\"\" sex_type = agent . sex_type race_type = agent . race diagnosed = agent . hiv_dx partner_tracing = agent . location . params . partner_tracing def diagnose ( agent , ): # agent's location's params used throughout as that is the agent who # would be interacting with the service agent . hiv_dx = True self . pop . dx_counts [ agent . race ][ agent . sex_type ] += 1 self . new_dx . add_agent ( agent ) if ( self . features . partner_tracing and partner_tracing . start_time <= self . time < partner_tracing . stop_time ): # Determine if each partner is found via partner tracing for ptnr in agent . get_partners ( partner_tracing . bond_type ): if ( not ptnr . hiv_dx and self . run_random . random () < partner_tracing . prob ): ptnr . partner_traced = True ptnr . trace_time = self . time if not diagnosed : test_prob = agent . location . params . demographics [ race_type ][ sex_type ] . hiv . dx . prob # Rescale based on calibration param test_prob *= self . calibration . test_frequency if self . run_random . random () < test_prob : diagnose ( agent ) elif ( agent . partner_traced and self . run_random . random () < partner_tracing . hiv . dx and self . time > agent . trace_time ): diagnose ( agent ) if self . time >= agent . trace_time + partner_tracing . trace_duration : # agents can only be traced during a specified period after their partner is # diagnosed. If past this time, remove ability to trace. agent . partner_traced = False die_and_replace ( self ) Let agents die and replace the dead agent with a new agent randomly. Source code in titan/model.py def die_and_replace ( self ): \"\"\" Let agents die and replace the dead agent with a new agent randomly. \"\"\" # die stage for agent in self . pop . all_agents : # agent incarcerated, don't evaluate for death if agent . incar : continue # death rate per 1 person-month p = ( prob . get_death_rate ( agent . hiv , agent . aids , agent . drug_type , agent . haart_adherence , agent . race , agent . location , self . params . model . time . steps_per_year , ) * self . calibration . mortality ) if self . run_random . random () < p : self . deaths . append ( agent ) # End all existing relationships for rel in copy ( agent . relationships ): rel . progress ( force = True ) self . pop . remove_relationship ( rel ) # replace stage for agent in self . deaths : # Remove agent from agent class and sub-sets self . pop . remove_agent ( agent ) new_agent = self . pop . create_agent ( agent . location , agent . race , self . time , agent . sex_type ) self . pop . add_agent ( new_agent ) discontinue_prep ( self , agent , force = False ) Update agent's PrEP status and discontinue stochastically or if force is True Parameters: Name Type Description Default agent Agent agent being updated required force bool whether to force discontinuation of PrEP False Source code in titan/model.py def discontinue_prep ( self , agent : Agent , force : bool = False ): \"\"\" Update agent's PrEP status and discontinue stochastically or if `force` is True args: agent: agent being updated force: whether to force discontinuation of PrEP \"\"\" # Agent must be on PrEP to discontinue PrEP assert agent . prep # If force flag set, auto kick off prep. if force : self . pop . prep_counts [ agent . race ] -= 1 agent . prep = False agent . prep_load = 0.0 agent . prep_last_dose = 0 return None # else if agent is on PrEP, see if they should discontinue if ( self . run_random . random () < agent . location . params . demographics [ agent . race ][ agent . sex_type ] . prep . discontinue and agent . prep_type == \"Oral\" ): self . pop . prep_counts [ agent . race ] -= 1 agent . prep = False agent . prep_type = \"\" if agent . prep_type == \"Inj\" : agent . update_prep_load () # agent timed out of prep if not agent . prep : self . pop . prep_counts [ agent . race ] -= 1 get_transmission_probability ( self , interaction , agent , partner ) Determines the probability of a transmission event based on interaction type. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction Parameters: Name Type Description Default interaction str \"injection\" or \"sex\" required agent HIV+ Agent required partner HIV- Agent required Returns: Type Description float probability of transmission from agent to partner Source code in titan/model.py def get_transmission_probability ( self , interaction : str , agent , partner ) -> float : \"\"\" Determines the probability of a transmission event based on interaction type. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction args: interaction : \"injection\" or \"sex\" agent: HIV+ Agent partner: HIV- Agent returns: probability of transmission from agent to partner \"\"\" # Logic for if needle or sex type interaction p : float assert interaction in ( \"injection\" , \"sex\" ), ( f \"Invalid interaction type { interaction } . Only sex and injection acts \" f \"supported. \" ) agent_sex_role = agent . sex_role partner_sex_role = partner . sex_role if interaction == \"injection\" : p = self . params . partnership . injection . transmission . base if agent . haart : p *= agent . location . params . partnership . injection . transmission . haart_scaling [ agent . haart_adherence ] . scale elif interaction == \"sex\" : # get partner's sex role during acts if partner_sex_role == \"versatile\" : # versatile partner takes # \"opposite\" position of agent if agent_sex_role == \"insertive\" : partner_sex_role = \"receptive\" elif agent_sex_role == \"receptive\" : partner_sex_role = \"insertive\" else : partner_sex_role = \"versatile\" # if both versatile, can switch # between receptive and insertive by act # get probability of sex acquisition given HIV- partner's position p = partner . location . params . partnership . sex . acquisition [ partner . sex_type ][ partner_sex_role ] # scale based on HIV+ agent's haart status/adherence if agent . haart : p *= agent . location . params . partnership . sex . haart_scaling [ agent . sex_type ][ agent . haart_adherence ] . prob # Scale if partner on PrEP if partner . prep : if partner . prep_type == \"Oral\" : if partner . prep_adherence == 1 : p *= 1.0 - partner . location . params . prep . efficacy . adherent else : p *= 1.0 - partner . location . params . prep . efficacy . non_adherant elif partner . prep_type == \"Inj\" and partner . prep_adherence == 1 : p *= - 1.0 * np . exp ( - 5.528636721 * partner . prep_load ) # Scale if partner vaccinated if partner . vaccine : vaccine_type = partner . location . params . vaccine . type vaccine_time_months = ( partner . vaccine_time / self . params . model . time . steps_per_year ) * 12 if vaccine_type == \"HVTN702\" : p *= np . exp ( - 2.88 + 0.76 * ( np . log (( vaccine_time_months + 0.001 ) * 30 ))) elif vaccine_type == \"RV144\" : p *= np . exp ( - 2.40 + 0.76 * ( np . log ( vaccine_time_months ))) # Scaling parameter for acute HIV infections if agent . get_acute_status ( agent . location . params . hiv . acute . duration ): p *= agent . location . params . hiv . acute . infectivity # Scaling parameter for positively identified HIV agents if agent . hiv_dx : p *= 1 - agent . location . params . hiv . dx . risk_reduction [ interaction ] # Tuning parameter for ART efficiency if agent . haart : p *= self . calibration . haart . transmission # Racial calibration parameter to attain proper race incidence disparity p *= partner . location . params . demographics [ partner . race ] . hiv . transmission # Scaling parameter for per act transmission. p *= self . calibration . acquisition return p hiv_convert ( self , agent ) Agent becomes HIV agent. Update all appropriate list and dictionaries. Parameters: Name Type Description Default agent Agent The agent being converted required Source code in titan/model.py def hiv_convert ( self , agent : Agent ): \"\"\" Agent becomes HIV agent. Update all appropriate list and dictionaries. args: agent: The agent being converted \"\"\" if not agent . hiv : agent . hiv = True agent . hiv_time = 1 agent . vaccine = False self . new_infections . add_agent ( agent ) self . pop . hiv_agents . add_agent ( agent ) if agent . prep : self . discontinue_prep ( agent , force = True ) incarcerate ( self , agent ) Incarcerate an agent or update their incarceration variables Parameters: Name Type Description Default agent Agent agent being updated required Source code in titan/model.py def incarcerate ( self , agent : Agent ): \"\"\" Incarcerate an agent or update their incarceration variables args: agent: agent being updated \"\"\" if not self . features . incar : return None hiv_bool = agent . hiv if hiv_bool : hiv_multiplier = agent . location . params . incar . hiv . multiplier else : hiv_multiplier = 1 if agent . incar : agent . incar_time -= 1 if agent . incar_time == 0 : # FREE AGENT self . new_incar_release . add_agent ( agent ) agent . incar = False if ( not agent . high_risk and self . features . high_risk ): # If behavioral treatment on and agent HIV, ignore HR period. self . become_high_risk ( agent ) for bond in agent . location . params . high_risk . partnership_types : agent . mean_num_partners [ bond ] += agent . location . params . high_risk . partner_scale agent . target_partners [ bond ] = utils . poisson ( agent . mean_num_partners [ bond ], self . np_random ) self . pop . update_partnerability ( agent ) if hiv_bool : if agent . haart : if ( self . run_random . random () <= agent . location . params . incar . haart . discontinue ): # 12% remain surpressed agent . haart = False agent . haart_adherence = 0 # END FORCE elif self . run_random . random () < ( agent . location . params . demographics [ agent . race ][ agent . sex_type ] . incar . prob * hiv_multiplier * self . calibration . incarceration ): incar_duration = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . incar . duration . prob bin = current_p_value = 1 p = self . run_random . random () while p >= current_p_value : current_p_value += incar_duration [ bin ] . prob bin += 1 timestay = self . run_random . randint ( incar_duration [ bin ] . min , incar_duration [ bin ] . max ) if hiv_bool : if not agent . hiv_dx : if self . run_random . random () < agent . location . params . incar . hiv . dx : agent . hiv_dx = True else : # Then tested and HIV, check to enroll in ART if ( self . run_random . random () < agent . location . params . incar . haart . prob ): tmp_rnd = self . run_random . random () haart_adh = agent . location . params . incar . haart . adherence if tmp_rnd < haart_adh : adherence = 5 else : adherence = self . run_random . randint ( 1 , 4 ) # Add agent to HAART class set, update agent params agent . haart = True agent . haart_adherence = adherence agent . haart_time = self . time agent . incar = True agent . incar_time = timestay # PUT PARTNERS IN HIGH RISK for bond in agent . location . params . high_risk . partnership_types : for partner in agent . partners [ bond ]: if not partner . high_risk and self . features . high_risk : if ( self . run_random . random () < partner . location . params . high_risk . prob ): self . become_high_risk ( partner ) initialize_random_trial ( self ) Initialize a random trial in the population Source code in titan/model.py def initialize_random_trial ( self ): \"\"\" Initialize a random trial in the population \"\"\" assert ( self . params . model . network . enable ), \"Network must be enabled for random trial\" print ( \"Starting random trial\" ) components = self . pop . connected_components () total_nodes = 0 print ( \"Number of components\" , len ([ 1 for comp in components if comp . number_of_nodes ()]), ) for comp in components : total_nodes += comp . number_of_nodes () if ( self . run_random . random () < self . params . prep . random_trial . intervention . prob ): # Component selected as treatment pod! if not self . features . pca : for ag in comp . nodes (): ag . random_trial_enrolled = True if not ag . hiv and not ag . prep : ag . intervention_ever = True if ( self . run_random . random () < ag . location . params . prep . target and not ag . vaccine ): self . initiate_prep ( ag , force = True ) elif self . params . prep . pca . choice == \"eigenvector\" : centrality = nx . algorithms . centrality . eigenvector_centrality ( comp ) assert len ( centrality ) >= 1 , \"Empty centrality\" ordered_centrality = sorted ( centrality , key = centrality . get ) intervention_agent = False for ag in ordered_centrality : ag . random_trial_enrolled = True if not ag . hiv and not intervention_agent : ag . prep_awareness = True ag . pca = True ag . pca_suitable = True ag . intervention_ever = True intervention_agent = True if not intervention_agent : ag = ordered_centrality [ 0 ] elif self . params . prep . pca . choice == \"bridge\" : # list all edges that are bridges for ag in comp . nodes : ag . random_trial_enrolled = True all_bridges = list ( nx . bridges ( comp )) comp_agents = [ agent for agents in all_bridges for agent in agents if not agent . hiv ] # all suitable agents in bridges if comp_agents : chosen_agent = utils . safe_random_choice ( comp_agents , self . run_random ) # select change agent chosen_agent . prep_awareness = True # make aware chosen_agent . pca = True chosen_agent . pca_suitable = True else : chosen_agent = list ( comp . nodes )[ 0 ] chosen_agent . pca = True elif self . params . prep . pca . choice == \"random\" : suitable_agent_choices = [] for ag in comp . nodes : ag . random_trial_enrolled = True if not ag . hiv : suitable_agent_choices . append ( ag ) if ( suitable_agent_choices ): # if there are agents who meet eligibility criteria, # select one randomly chosen_agent = utils . safe_random_choice ( suitable_agent_choices , self . run_random ) chosen_agent . pca = True chosen_agent . pca_suitable = True chosen_agent . prep_awareness = True # make aware chosen_agent . intervention_ever = True else : # if no suitable agents, mark a non-suitable agent chosen_agent = utils . safe_random_choice ( list ( comp . nodes ), self . run_random ) chosen_agent . pca = True print (( \"Total agents in trial: \" , total_nodes )) initiate_prep ( self , agent , force = False ) Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. Parameters: Name Type Description Default agent Agent agent being updated required force bool whether to force the agent to enroll instead of using the appropriate algorithm per the prep params False Source code in titan/model.py def initiate_prep ( self , agent : Agent , force : bool = False ): \"\"\" Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. args: agent : agent being updated force : whether to force the agent to enroll instead of using the appropriate algorithm per the prep params \"\"\" def enroll_prep ( self , agent : Agent ): agent . enroll_prep ( self . run_random ) self . new_prep . add_agent ( agent ) self . pop . prep_counts [ agent . race ] += 1 # agent must exist assert agent is not None # Prep only valid for agents not on prep and are HIV negative if agent . prep or agent . hiv : return # Determine probability of HIV treatment if force : enroll_prep ( self , agent ) else : if \"Racial\" in agent . location . params . prep . target_model : num_prep_agents = self . pop . prep_counts [ agent . race ] all_hiv_agents = self . pop . hiv_agents . members all_race = { a for a in self . pop . all_agents if a . race == agent . race } hiv_agents = len ( all_hiv_agents & all_race ) target_prep = ( len ( all_race ) - hiv_agents ) * agent . location . params . demographics [ agent . race ][ agent . sex_type ] . prep . coverage else : num_prep_agents = sum ( self . pop . prep_counts . values ()) target_prep = int ( ( self . pop . all_agents . num_members () - self . pop . hiv_agents . num_members () ) * agent . location . params . prep . target ) if ( num_prep_agents < target_prep and self . time >= agent . location . params . prep . start_time and agent . prep_eligible () ): enroll_prep ( self , agent ) injection_transmission ( self , agent , partner ) Simulate random transmission of HIV between two PWID agents through injection. Parameters: Name Type Description Default agent Agent PWID agent with HIV required partner Agent PWID agent without HIV required Source code in titan/model.py def injection_transmission ( self , agent : Agent , partner : Agent ): \"\"\" Simulate random transmission of HIV between two PWID agents through injection. args: agent: PWID agent with HIV partner: PWID agent without HIV \"\"\" assert agent . hiv assert not partner . hiv assert agent . drug_type == \"Inj\" assert partner . drug_type == \"Inj\" agent_race = agent . race agent_sex_type = agent . sex_type mean_num_acts = ( agent . location . params . demographics [ agent_race ][ agent_sex_type ] . injection . num_acts * self . calibration . injection . act ) share_acts = utils . poisson ( mean_num_acts , self . np_random ) if agent . ssp or partner . ssp : # syringe services program risk p_unsafe_injection = self . ssp_enrolled_risk else : # If sharing, minimum of 1 share act if share_acts < 1 : share_acts = 1 p_unsafe_injection = agent . location . params . demographics [ agent_race ][ agent_sex_type ] . injection . unsafe_prob if agent . hiv_dx or partner . hiv_dx : # diagnosis risk reduction p_unsafe_injection *= 1 - self . params . hiv . dx . risk_reduction . injection for n in range ( share_acts ): if self . run_random . random () > p_unsafe_injection : share_acts -= 1 if share_acts >= 1.0 : p = self . get_transmission_probability ( \"injection\" , agent , partner ) p_total_transmission : float if share_acts == 1 : p_total_transmission = p else : p_total_transmission = 1.0 - utils . binom_0 ( share_acts , p ) if self . run_random . random () < p_total_transmission : # if agent HIV+ partner becomes HIV+ self . hiv_convert ( partner ) make_agent_zero ( self ) Identify an agent as agent zero and HIV convert them Source code in titan/model.py def make_agent_zero ( self ): \"\"\" Identify an agent as agent zero and HIV convert them \"\"\" bonds = [ # Find what bond_types have the allowed interaction bond for bond , act_type in self . params . classes . bond_types . items () if self . params . agent_zero . interaction_type in act_type . acts_allowed ] max_partners = 0 max_agent = None zero_eligible = [] for agent in self . pop . all_agents : num_partners = agent . get_num_partners ( bond_types = bonds ) if num_partners >= self . params . agent_zero . num_partners : zero_eligible . append ( agent ) if num_partners > max_partners : max_partners = num_partners max_agent = agent agent_zero = utils . safe_random_choice ( zero_eligible , self . run_random ) if agent_zero : # if eligible agent, make agent 0 self . hiv_convert ( agent_zero ) elif self . params . agent_zero . fallback and max_agent is not None : self . hiv_convert ( max_agent ) else : raise ValueError ( \"No agent zero!\" ) pca_interaction ( self , rel , force = False ) Simulate peer change agent interactions. Knowledge if one agent is aware and one unaware, opinion if one agent swaying the other. Parameters: Name Type Description Default rel Relationship The relationship PCA is happening in required force Whether to force knowledge dissemination and influence False Source code in titan/model.py def pca_interaction ( self , rel : Relationship , force = False ): \"\"\" Simulate peer change agent interactions. Knowledge if one agent is aware and one unaware, opinion if one agent swaying the other. args: rel: The relationship PCA is happening in force: Whether to force knowledge dissemination and influence \"\"\" assert ( self . params . model . network . enable ), \"Network must be enabled for pca interactions\" def influence ( agent , partner ): agent_init_opinion = agent . prep_opinion partner_init_opinion = partner . prep_opinion agent_influence = nx . closeness_centrality ( self . pop . graph , agent ) partner_influence = nx . closeness_centrality ( self . pop . graph , partner ) if agent_influence > partner_influence : partner . prep_opinion = np . mean ( [ agent . prep_opinion , partner . prep_opinion ] ) elif agent_influence < partner_influence : agent . prep_opinion = np . mean ([ agent . prep_opinion , partner . prep_opinion ]) if ( agent_init_opinion < agent . location . params . prep . pca . opinion . threshold < agent . prep_opinion ): if self . run_random . random () < agent . location . params . prep . pca . prep . prob : self . initiate_prep ( agent , force = True ) elif ( partner_init_opinion < partner . location . params . prep . pca . opinion . threshold < partner . prep_opinion ): if ( self . run_random . random () < partner . location . params . prep . pca . prep . prob ): self . initiate_prep ( partner , force = True ) def knowledge_dissemination ( partner ): partner . prep_awareness = True if ( partner . prep_opinion > partner . location . params . prep . pca . opinion . threshold and self . run_random . random () < partner . location . params . prep . pca . prep . prob ): self . initiate_prep ( partner , force = True ) def knowledge_transmission_probability (): if rel . agent1 . prep_awareness and rel . agent2 . prep_awareness : p = self . params . prep . pca . opinion . transmission else : p = self . params . prep . pca . knowledge . transmission if num_acts == 1 : p_total_transmission = p elif num_acts >= 1 : p_total_transmission = 1.0 - utils . binom_0 ( num_acts , p ) else : p_total_transmission = 0 return p_total_transmission acts_prob = self . run_random . random () acts_bin = 0 current_p_value = 0.0 while acts_prob > current_p_value : acts_bin += 1 current_p_value += self . params . partnership . pca . frequency [ rel . bond_type ][ acts_bin ] . prob min = self . params . partnership . pca . frequency [ rel . bond_type ][ acts_bin ] . min max = self . params . partnership . pca . frequency [ rel . bond_type ][ acts_bin ] . max if min == max : num_acts = min else : num_acts = self . run_random . randrange ( min , max ) if num_acts < 1 and not force : return if rel . agent1 . prep_awareness and not rel . agent2 . prep_awareness : if self . run_random . random () < knowledge_transmission_probability () or force : knowledge_dissemination ( rel . agent2 ) elif not rel . agent1 . prep_awareness and rel . agent2 . prep_awareness : if self . run_random . random () < knowledge_transmission_probability () or force : knowledge_dissemination ( rel . agent1 ) elif rel . agent1 . prep_awareness and rel . agent2 . prep_awareness or force : if self . run_random . random () < knowledge_transmission_probability () or force : influence ( rel . agent1 , rel . agent2 ) print_stats ( self , stat , outdir ) Create/update all of the reports defined in the params Source code in titan/model.py def print_stats ( self , stat : Dict [ str , Dict [ str , int ]], outdir : str ): \"\"\" Create/update all of the reports defined in the params \"\"\" for report in self . params . outputs . reports : printer = getattr ( ao , report ) printer ( self . id , self . time , self . run_seed , self . pop . pop_seed , stat , self . params , outdir , ) # network-based reports if ( self . time % self . params . outputs . print_frequency == 0 and self . params . model . network . enable ): assert ( self . network_utils is not None ), \"Graph must be enabled to print network reports\" network_outdir = os . path . join ( outdir , \"network\" ) if self . params . outputs . network . draw_figures : self . network_utils . visualize_network ( network_outdir , curtime = self . time , label = f \" { self . id } \" ) if self . params . outputs . network . calc_component_stats : ao . print_components ( self . id , self . time , self . run_seed , self . pop . pop_seed , self . pop . connected_components (), network_outdir , self . params . classes . races , ) if self . params . outputs . network . calc_network_stats : self . network_utils . write_network_stats ( network_outdir , self . id , self . time ) if self . params . outputs . network . edge_list : self . network_utils . write_graph_edgelist ( network_outdir , self . id , self . time ) progress_to_aids ( self , agent ) Model the progression of HIV agents to AIDS agents Source code in titan/model.py def progress_to_aids ( self , agent : Agent ): \"\"\" Model the progression of HIV agents to AIDS agents \"\"\" # only valid for HIV agents assert agent . hiv p = prob . adherence_prob ( agent . haart_adherence ) if agent . haart else 1 if self . run_random . random () < p * agent . location . params . hiv . aids . prob : agent . aids = True run ( self , outdir ) Runs the model for the number of time steps defined in params, at each time step does: Increments time Takes one step Resets trackers Parameters: Name Type Description Default outdir str path to directory where results should be saved required Source code in titan/model.py def run ( self , outdir : str ): \"\"\" Runs the model for the number of time steps defined in params, at each time step does: 1. Increments time 2. Takes one step 3. Resets trackers args: outdir: path to directory where results should be saved \"\"\" if self . params . model . time . burn_steps > 0 : print ( \" \\t ===! Start Burn Loop !===\" ) else : # make sure t0 things get printed stats = ao . get_stats ( self . pop . all_agents , self . new_prep , self . new_infections , self . new_dx , self . new_high_risk , self . new_incar_release , self . deaths , self . params , ) self . print_stats ( stats , outdir ) # burn is negative time, model run starts at t = 1 for i in range ( - 1 * self . params . model . time . burn_steps , self . params . model . time . num_steps ): self . time += 1 self . step ( outdir ) self . reset_trackers () if self . time == 0 : if self . params . model . time . burn_steps > 0 : print ( \" \\t ===! Burn Loop Complete !===\" ) print ( \" \\t ===! Start Main Loop !===\" ) print ( \" \\t ===! Main Loop Complete !===\" ) sex_transmission ( self , rel ) Simulate random transmission of HIV between two agents through Sex. One of the agents must have HIV. Parameters: Name Type Description Default rel Relationship Relationship required Source code in titan/model.py def sex_transmission ( self , rel : Relationship ): \"\"\" Simulate random transmission of HIV between two agents through Sex. One of the agents must have HIV. args: rel : Relationship \"\"\" if rel . agent1 . hiv : agent = rel . agent1 partner = rel . agent2 elif rel . agent2 . hiv : agent = rel . agent2 partner = rel . agent1 else : raise ValueError ( \"rel must have an agent with HIV\" ) # HIV status of agent and partner # Everything from here is only run if one of them is HIV+ if partner . hiv : return # unprotected sex probabilities for primary partnerships mean_sex_acts = ( agent . get_number_of_sex_acts ( self . np_random ) * self . calibration . sex . act ) total_sex_acts = utils . poisson ( mean_sex_acts , self . np_random ) # Get condom usage p_safe_sex = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . safe_sex # increase condom usage if diagnosed if agent . hiv_dx or partner . hiv_dx : # Calculate probability of safe sex given risk reduction p_unsafe_sex = ( 1 - p_safe_sex ) * ( 1 - self . params . hiv . dx . risk_reduction . sex ) p_safe_sex *= 1 - p_unsafe_sex # Reduction of risk acts between partners for condom usage unsafe_sex_acts = total_sex_acts for n in range ( unsafe_sex_acts ): if self . run_random . random () < p_safe_sex : unsafe_sex_acts -= 1 if unsafe_sex_acts >= 1 : # agent is HIV+ rel . total_sex_acts += unsafe_sex_acts p_per_act = self . get_transmission_probability ( \"sex\" , agent , partner ) p_total_transmission : float if unsafe_sex_acts == 1 : p_total_transmission = p_per_act else : p_total_transmission = 1.0 - utils . binom_0 ( unsafe_sex_acts , p_per_act ) if self . run_random . random () < p_total_transmission : # if agent HIV+ partner becomes HIV+ self . hiv_convert ( partner ) step ( self , outdir ) A single time step in the model: Perform timeline_scaling updates to params if needed Update all agents Write/update reports with this timestep's data Parameters: Name Type Description Default outdir str path to directory where reports should be saved required Source code in titan/model.py def step ( self , outdir : str ): \"\"\" A single time step in the model: 1. Perform timeline_scaling updates to params if needed 2. Update all agents 3. Write/update reports with this timestep's data args: outdir: path to directory where reports should be saved \"\"\" print ( f \" \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t .: TIME { self . time } \" ) print ( \" \\t STARTING HIV count: {} \\t Total Incarcerated: {} \\t HR+: {} \\t \" \"PrEP: {} \" . format ( self . pop . hiv_agents . num_members (), sum ([ 1 for a in self . pop . all_agents if a . incar ]), self . pop . high_risk_agents . num_members (), sum ([ 1 for a in self . pop . all_agents if a . prep ]), ) ) self . timeline_scaling () self . update_all_agents () stats = ao . get_stats ( self . pop . all_agents , self . new_prep , self . new_infections , self . new_dx , self . new_high_risk , self . new_incar_release , self . deaths , self . params , ) self . print_stats ( stats , outdir ) print (( \"Number of relationships: {} \" . format ( len ( self . pop . relationships )))) self . pop . all_agents . print_subsets () timeline_scaling ( self ) Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). Source code in titan/model.py def timeline_scaling ( self ): \"\"\" Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). \"\"\" if not self . features . timeline_scaling : return None # gather all of the param objectss to be scaled params_set = { self . params } for location in self . pop . geography . locations . values (): params_set . add ( location . params ) # iterate over each param and update the values if the time is right for params in params_set : for defn in params . timeline_scaling . timeline . values (): param = defn . parameter if param != \"ts_default\" : if defn . start_time == self . time : print ( f \"timeline scaling - { param } \" ) utils . scale_param ( params , param , defn . scalar ) elif defn . stop_time == self . time : print ( f \"timeline un-scaling - { param } \" ) utils . scale_param ( params , param , 1 / defn . scalar ) update_all_agents ( self ) The core of the model. For a time step, update all of the agents and relationships: Create an agent zero (if enabled and the time is right) Update partner assignments (create new relationships as needed) Agents in relationships interact Update syringe services (if enabled) Update each agent's status for: age high risk prep incarceration hiv End relationships with no remaining duration Agent death/replacement Source code in titan/model.py def update_all_agents ( self ): \"\"\" The core of the model. For a time step, update all of the agents and relationships: 1. Create an agent zero (if enabled and the time is right) 2. Update partner assignments (create new relationships as needed) 3. Agents in relationships interact 4. Update syringe services (if enabled) 5. Update each agent's status for: * age * high risk * prep * incarceration * hiv 6. End relationships with no remaining duration 7. Agent death/replacement \"\"\" # If agent zero enabled, create agent zero at the beginning of main loop. if self . time == self . params . agent_zero . start_time and self . features . agent_zero : self . make_agent_zero () if not self . features . static_network : self . pop . update_partner_assignments ( t = self . time ) if self . pop . enable_graph : self . pop . trim_graph () for rel in self . pop . relationships : self . agents_interact ( rel ) if self . features . syringe_services : self . update_syringe_services () for agent in self . pop . all_agents : # happy birthday agents! if ( self . time > 0 and ( self . time % self . params . model . time . steps_per_year ) == 0 ): agent . age += 1 if self . features . high_risk : self . update_high_risk ( agent ) if ( self . features . pca and self . time >= self . params . prep . pca . start_time and ( self . run_random . random () < agent . location . params . prep . pca . awareness . prob ) ): agent . prep_awareness = True if self . run_random . random () < agent . location . params . prep . pca . prep . prob : self . initiate_prep ( agent , force = True ) if self . features . incar : self . incarcerate ( agent ) if ( agent . msmw and self . run_random . random () < agent . location . params . msmw . hiv . prob ): self . hiv_convert ( agent ) if agent . hiv : agent . hiv_time += 1 # If HIV hasn't started, ignore if self . time >= self . params . hiv . start_time : self . diagnose_hiv ( agent ) self . progress_to_aids ( agent ) if self . features . haart : self . update_haart ( agent ) else : if self . features . prep : if self . time >= agent . location . params . prep . start_time : if agent . prep : self . discontinue_prep ( agent ) elif agent . prep_eligible (): self . initiate_prep ( agent ) if self . features . vaccine and not agent . prep : self . advance_vaccine ( agent ) if ( self . features . prep and self . time == agent . location . params . prep . start_time and \"RandomTrial\" in agent . location . params . prep . target_model ): self . initialize_random_trial () # If static network, ignore relationship progression if not self . features . static_network : for rel in copy ( self . pop . relationships ): if rel . progress (): self . pop . remove_relationship ( rel ) if self . features . die_and_replace : self . die_and_replace () update_haart ( self , agent ) Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status ( dx is True). Parameters: Name Type Description Default agent Agent agent being updated required Source code in titan/model.py def update_haart ( self , agent : Agent ): \"\"\" Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status (`dx` is True). args: agent: agent being updated \"\"\" if not self . features . haart : return None def initiate ( agent ): haart_adh = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . haart . adherence if self . run_random . random () < haart_adh : adherence = 5 else : adherence = self . run_random . randint ( 1 , 4 ) # Add agent to HAART class set, update agent params agent . haart = True agent . haart_adherence = adherence agent . haart_time = self . time self . pop . haart_counts [ agent . race ][ agent . sex_type ] += 1 # Check valid input assert agent . hiv # Determine probability of HIV treatment if agent . hiv_dx : haart_params = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . haart # Go on HAART if not agent . haart : if agent . location . params . hiv . haart_cap : # if HAART is based on cap instead of prob, determine number of # HAART agents based on % of diagnosed agents num_dx_agents = self . pop . dx_counts [ agent . race ][ agent . sex_type ] num_haart_agents = self . pop . haart_counts [ agent . race ][ agent . sex_type ] if num_haart_agents < ( agent . location . params . demographics [ agent . race ][ agent . sex_type ] . haart . prob * num_dx_agents ): initiate ( agent ) else : if self . run_random . random () < ( haart_params . prob * self . calibration . haart . coverage ): initiate ( agent ) # Go off HAART elif agent . haart and self . run_random . random () < haart_params . discontinue : agent . haart = False agent . haart_adherence = 0 agent . haart_time = 0 self . pop . haart_counts [ agent . race ][ agent . sex_type ] -= 1 update_high_risk ( self , agent ) Update high risk agents or remove them from high risk pool Source code in titan/model.py def update_high_risk ( self , agent : Agent ): \"\"\" Update high risk agents or remove them from high risk pool \"\"\" if agent not in self . pop . high_risk_agents : return None if agent . high_risk_time > 0 : agent . high_risk_time -= 1 else : self . pop . high_risk_agents . remove_agent ( agent ) agent . high_risk = False if self . features . incar : for bond in agent . location . params . high_risk . partnership_types : agent . mean_num_partners [ bond ] -= agent . location . params . high_risk . partner_scale agent . mean_num_partners [ bond ] = max ( 0 , agent . mean_num_partners [ bond ] ) # make sure not negative agent . target_partners [ bond ] = utils . poisson ( agent . mean_num_partners [ bond ], self . np_random ) while len ( agent . partners [ bond ]) > agent . target_partners [ bond ]: rel = utils . safe_random_choice ( agent . relationships , self . run_random ) if rel is not None : rel . progress ( force = True ) self . pop . remove_relationship ( rel ) update_syringe_services ( self ) Enroll PWID agents in syringe services Source code in titan/model.py def update_syringe_services ( self ): \"\"\" Enroll PWID agents in syringe services \"\"\" print (( \" \\n\\n !!!!Engaging syringe services program\" )) ssp_num_slots = 0 ssp_agents = { agent for agent in self . pop . pwid_agents . members if agent . ssp } if self . features . syringe_services : for item in self . params . syringe_services . timeline . values (): if item . start_time <= self . time < item . stop_time : self . ssp_enrolled_risk = item . risk ssp_num_slots = ( item . num_slots_stop - item . num_slots_start ) / ( item . stop_time - item . start_time ) * ( self . time - item . start_time ) + item . num_slots_start # If cap indicates all or no agents, do not change # otherwise, find true number of slots through distribution if 0 < ssp_num_slots < self . pop . pwid_agents . num_members (): ssp_num_slots = round ( self . run_random . betavariate ( ssp_num_slots , self . pop . pwid_agents . num_members () - ssp_num_slots , ) * self . pop . pwid_agents . num_members () ) break target_set = utils . safe_shuffle ( ( self . pop . pwid_agents . members - ssp_agents ), self . run_random ) for agent in ssp_agents . copy (): if len ( ssp_agents ) > ssp_num_slots : agent . ssp = False ssp_agents . remove ( agent ) if target_set : for agent in target_set : if len ( ssp_agents ) < ssp_num_slots : agent . ssp = True ssp_agents . add ( agent ) print ( f \"SSP has { ssp_num_slots } target slots with \" f \" { len ( ssp_agents ) } slots filled\" )","title":"Model"},{"location":"api/model/#hivmodel","text":"The HIVModel class is used to model agent interactions as they progress through time. The model can be run on an existing Population or it can create a Population during its construction. The most common entry point to the model is run , which will run the model for all time steps. To run step by step, step can be iterated through instead, just be sure to reset_trackers between step s.","title":"HIVModel"},{"location":"api/model/#titan.model.HIVModel.__init__","text":"This is the core class used to simulate the spread of HIV and drug use in one geography. Parameters: Name Type Description Default params ObjMap the parameter object for this model required population Optional[titan.population.Population] an initialized population to run the model on None Source code in titan/model.py def __init__ ( self , params : ObjMap , population : Optional [ Population ] = None , ): \"\"\" This is the core class used to simulate the spread of HIV and drug use in one geography. args: params: the parameter object for this model population: an initialized population to run the model on \"\"\" self . params = params # pre-fetch commonly used param sub-sets for performance self . features = params . features self . calibration = params . calibration print ( \"=== Begin Initialization Protocol === \\n \" ) if population is None : print ( \" \\t Generating new population\" ) self . pop = Population ( params ) else : print ( \" \\t Using provided population\" ) self . pop = population self . network_utils : Optional [ NetworkGraphUtils ] if params . model . network . enable : self . network_utils = NetworkGraphUtils ( self . pop . graph ) else : self . network_utils = None print ( \" \\n\\t Creating lists\" ) # Other lists / dictionaries self . new_infections = AgentSet ( \"new_infections\" ) self . new_dx = AgentSet ( \"new_dx\" ) self . new_incar_release = AgentSet ( \"new_incar_release\" ) self . new_high_risk = AgentSet ( \"new_high_risk\" ) self . new_prep = AgentSet ( \"new_prep\" ) self . ssp_enrolled_risk = 0.0 self . time = - 1 * self . params . model . time . burn_steps # burn is negative time self . id = nanoid . generate ( size = 8 ) # Set seed format. 0: pure random, else: fixed value self . run_seed = utils . get_check_rand_int ( params . model . seed . run ) print ( f \" \\t Run seed was set to: { self . run_seed } \" ) self . run_random = random . Random ( self . run_seed ) self . np_random = np . random . RandomState ( self . run_seed ) random . seed ( self . run_seed ) print (( \" \\t FIRST RANDOM CALL {} \" . format ( random . randint ( 0 , 100 )))) print ( \" \\t Resetting death count\" ) self . deaths : List [ Agent ] = [] # Number of death print ( \" \\n === Initialization Protocol Finished ===\" )","title":"__init__()"},{"location":"api/model/#titan.model.HIVModel.advance_vaccine","text":"Progress vaccine. Agents may receive injection or progress in time since injection. Parameters: Name Type Description Default agent Agent agent being updated required Source code in titan/model.py def advance_vaccine ( self , agent : Agent ): \"\"\" Progress vaccine. Agents may receive injection or progress in time since injection. args: agent: agent being updated \"\"\" if not self . features . vaccine : return None vaccine_params = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . vaccine if agent . vaccine : agent . vaccine_time += 1 if ( agent . location . params . vaccine . booster and agent . vaccine_time == vaccine_params . booster . interval and self . run_random . random () < vaccine_params . booster . prob ): agent . vaccinate () elif self . time == agent . location . params . vaccine . start_time : if self . run_random . random () < vaccine_params . prob : agent . vaccinate ()","title":"advance_vaccine()"},{"location":"api/model/#titan.model.HIVModel.agents_interact","text":"Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: Peer Change Agent Injection Sex Parameters: Name Type Description Default rel Relationship The relationship that the agents interact in required Returns: Type Description bool whether the agents interacted Source code in titan/model.py def agents_interact ( self , rel : Relationship ) -> bool : \"\"\" Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: * Peer Change Agent * Injection * Sex args: rel : The relationship that the agents interact in returns: whether the agents interacted \"\"\" interaction_types = self . params . classes . bond_types [ rel . bond_type ] . acts_allowed # If either agent is incarcerated, skip their interaction if rel . agent1 . incar or rel . agent2 . incar : return False # Agent 1 is HIV+, Agent 2 is not, Agent 2 is succept if rel . agent1 . hiv and not rel . agent2 . hiv : agent = rel . agent1 partner = rel . agent2 # If Agent 2 is HIV and Agent 1 is not, Agent 1 is succept elif not rel . agent1 . hiv and rel . agent2 . hiv : agent = rel . agent2 partner = rel . agent1 else : # neither agent is HIV or both are return False if self . params . features . pca and self . time >= self . params . prep . pca . start_time : if \"pca\" in interaction_types and rel . duration < rel . total_duration : self . pca_interaction ( rel ) if self . time >= self . params . hiv . start_time : if \"injection\" in interaction_types : self . injection_transmission ( agent , partner ) if \"sex\" in interaction_types : self . sex_transmission ( rel ) return True","title":"agents_interact()"},{"location":"api/model/#titan.model.HIVModel.become_high_risk","text":"Mark an agent as high risk and assign a duration to their high risk period Parameters: Name Type Description Default agent Agent agent becoming high risk required duration int duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] None Source code in titan/model.py def become_high_risk ( self , agent : Agent , duration : int = None ): \"\"\" Mark an agent as high risk and assign a duration to their high risk period args: agent: agent becoming high risk duration: duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] \"\"\" if not self . features . high_risk : return None if agent not in self . pop . high_risk_agents . members : self . pop . high_risk_agents . add_agent ( agent ) if not agent . high_risk_ever : self . new_high_risk . add_agent ( agent ) agent . high_risk = True agent . high_risk_ever = True if duration is not None : agent . high_risk_time = duration else : agent . high_risk_time = agent . location . params . high_risk . sex_based [ agent . sex_type ] . duration","title":"become_high_risk()"},{"location":"api/model/#titan.model.HIVModel.diagnose_hiv","text":"Stochastically test the agent for HIV. If tested, mark the agent as diagnosed and trace their partners (if partner tracing enabled). Parameters: Name Type Description Default agent Agent HIV positive agent to diagnose required Source code in titan/model.py def diagnose_hiv ( self , agent : Agent ): \"\"\" Stochastically test the agent for HIV. If tested, mark the agent as diagnosed and trace their partners (if partner tracing enabled). args: agent: HIV positive agent to diagnose \"\"\" sex_type = agent . sex_type race_type = agent . race diagnosed = agent . hiv_dx partner_tracing = agent . location . params . partner_tracing def diagnose ( agent , ): # agent's location's params used throughout as that is the agent who # would be interacting with the service agent . hiv_dx = True self . pop . dx_counts [ agent . race ][ agent . sex_type ] += 1 self . new_dx . add_agent ( agent ) if ( self . features . partner_tracing and partner_tracing . start_time <= self . time < partner_tracing . stop_time ): # Determine if each partner is found via partner tracing for ptnr in agent . get_partners ( partner_tracing . bond_type ): if ( not ptnr . hiv_dx and self . run_random . random () < partner_tracing . prob ): ptnr . partner_traced = True ptnr . trace_time = self . time if not diagnosed : test_prob = agent . location . params . demographics [ race_type ][ sex_type ] . hiv . dx . prob # Rescale based on calibration param test_prob *= self . calibration . test_frequency if self . run_random . random () < test_prob : diagnose ( agent ) elif ( agent . partner_traced and self . run_random . random () < partner_tracing . hiv . dx and self . time > agent . trace_time ): diagnose ( agent ) if self . time >= agent . trace_time + partner_tracing . trace_duration : # agents can only be traced during a specified period after their partner is # diagnosed. If past this time, remove ability to trace. agent . partner_traced = False","title":"diagnose_hiv()"},{"location":"api/model/#titan.model.HIVModel.die_and_replace","text":"Let agents die and replace the dead agent with a new agent randomly. Source code in titan/model.py def die_and_replace ( self ): \"\"\" Let agents die and replace the dead agent with a new agent randomly. \"\"\" # die stage for agent in self . pop . all_agents : # agent incarcerated, don't evaluate for death if agent . incar : continue # death rate per 1 person-month p = ( prob . get_death_rate ( agent . hiv , agent . aids , agent . drug_type , agent . haart_adherence , agent . race , agent . location , self . params . model . time . steps_per_year , ) * self . calibration . mortality ) if self . run_random . random () < p : self . deaths . append ( agent ) # End all existing relationships for rel in copy ( agent . relationships ): rel . progress ( force = True ) self . pop . remove_relationship ( rel ) # replace stage for agent in self . deaths : # Remove agent from agent class and sub-sets self . pop . remove_agent ( agent ) new_agent = self . pop . create_agent ( agent . location , agent . race , self . time , agent . sex_type ) self . pop . add_agent ( new_agent )","title":"die_and_replace()"},{"location":"api/model/#titan.model.HIVModel.discontinue_prep","text":"Update agent's PrEP status and discontinue stochastically or if force is True Parameters: Name Type Description Default agent Agent agent being updated required force bool whether to force discontinuation of PrEP False Source code in titan/model.py def discontinue_prep ( self , agent : Agent , force : bool = False ): \"\"\" Update agent's PrEP status and discontinue stochastically or if `force` is True args: agent: agent being updated force: whether to force discontinuation of PrEP \"\"\" # Agent must be on PrEP to discontinue PrEP assert agent . prep # If force flag set, auto kick off prep. if force : self . pop . prep_counts [ agent . race ] -= 1 agent . prep = False agent . prep_load = 0.0 agent . prep_last_dose = 0 return None # else if agent is on PrEP, see if they should discontinue if ( self . run_random . random () < agent . location . params . demographics [ agent . race ][ agent . sex_type ] . prep . discontinue and agent . prep_type == \"Oral\" ): self . pop . prep_counts [ agent . race ] -= 1 agent . prep = False agent . prep_type = \"\" if agent . prep_type == \"Inj\" : agent . update_prep_load () # agent timed out of prep if not agent . prep : self . pop . prep_counts [ agent . race ] -= 1","title":"discontinue_prep()"},{"location":"api/model/#titan.model.HIVModel.get_transmission_probability","text":"Determines the probability of a transmission event based on interaction type. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction Parameters: Name Type Description Default interaction str \"injection\" or \"sex\" required agent HIV+ Agent required partner HIV- Agent required Returns: Type Description float probability of transmission from agent to partner Source code in titan/model.py def get_transmission_probability ( self , interaction : str , agent , partner ) -> float : \"\"\" Determines the probability of a transmission event based on interaction type. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction args: interaction : \"injection\" or \"sex\" agent: HIV+ Agent partner: HIV- Agent returns: probability of transmission from agent to partner \"\"\" # Logic for if needle or sex type interaction p : float assert interaction in ( \"injection\" , \"sex\" ), ( f \"Invalid interaction type { interaction } . Only sex and injection acts \" f \"supported. \" ) agent_sex_role = agent . sex_role partner_sex_role = partner . sex_role if interaction == \"injection\" : p = self . params . partnership . injection . transmission . base if agent . haart : p *= agent . location . params . partnership . injection . transmission . haart_scaling [ agent . haart_adherence ] . scale elif interaction == \"sex\" : # get partner's sex role during acts if partner_sex_role == \"versatile\" : # versatile partner takes # \"opposite\" position of agent if agent_sex_role == \"insertive\" : partner_sex_role = \"receptive\" elif agent_sex_role == \"receptive\" : partner_sex_role = \"insertive\" else : partner_sex_role = \"versatile\" # if both versatile, can switch # between receptive and insertive by act # get probability of sex acquisition given HIV- partner's position p = partner . location . params . partnership . sex . acquisition [ partner . sex_type ][ partner_sex_role ] # scale based on HIV+ agent's haart status/adherence if agent . haart : p *= agent . location . params . partnership . sex . haart_scaling [ agent . sex_type ][ agent . haart_adherence ] . prob # Scale if partner on PrEP if partner . prep : if partner . prep_type == \"Oral\" : if partner . prep_adherence == 1 : p *= 1.0 - partner . location . params . prep . efficacy . adherent else : p *= 1.0 - partner . location . params . prep . efficacy . non_adherant elif partner . prep_type == \"Inj\" and partner . prep_adherence == 1 : p *= - 1.0 * np . exp ( - 5.528636721 * partner . prep_load ) # Scale if partner vaccinated if partner . vaccine : vaccine_type = partner . location . params . vaccine . type vaccine_time_months = ( partner . vaccine_time / self . params . model . time . steps_per_year ) * 12 if vaccine_type == \"HVTN702\" : p *= np . exp ( - 2.88 + 0.76 * ( np . log (( vaccine_time_months + 0.001 ) * 30 ))) elif vaccine_type == \"RV144\" : p *= np . exp ( - 2.40 + 0.76 * ( np . log ( vaccine_time_months ))) # Scaling parameter for acute HIV infections if agent . get_acute_status ( agent . location . params . hiv . acute . duration ): p *= agent . location . params . hiv . acute . infectivity # Scaling parameter for positively identified HIV agents if agent . hiv_dx : p *= 1 - agent . location . params . hiv . dx . risk_reduction [ interaction ] # Tuning parameter for ART efficiency if agent . haart : p *= self . calibration . haart . transmission # Racial calibration parameter to attain proper race incidence disparity p *= partner . location . params . demographics [ partner . race ] . hiv . transmission # Scaling parameter for per act transmission. p *= self . calibration . acquisition return p","title":"get_transmission_probability()"},{"location":"api/model/#titan.model.HIVModel.hiv_convert","text":"Agent becomes HIV agent. Update all appropriate list and dictionaries. Parameters: Name Type Description Default agent Agent The agent being converted required Source code in titan/model.py def hiv_convert ( self , agent : Agent ): \"\"\" Agent becomes HIV agent. Update all appropriate list and dictionaries. args: agent: The agent being converted \"\"\" if not agent . hiv : agent . hiv = True agent . hiv_time = 1 agent . vaccine = False self . new_infections . add_agent ( agent ) self . pop . hiv_agents . add_agent ( agent ) if agent . prep : self . discontinue_prep ( agent , force = True )","title":"hiv_convert()"},{"location":"api/model/#titan.model.HIVModel.incarcerate","text":"Incarcerate an agent or update their incarceration variables Parameters: Name Type Description Default agent Agent agent being updated required Source code in titan/model.py def incarcerate ( self , agent : Agent ): \"\"\" Incarcerate an agent or update their incarceration variables args: agent: agent being updated \"\"\" if not self . features . incar : return None hiv_bool = agent . hiv if hiv_bool : hiv_multiplier = agent . location . params . incar . hiv . multiplier else : hiv_multiplier = 1 if agent . incar : agent . incar_time -= 1 if agent . incar_time == 0 : # FREE AGENT self . new_incar_release . add_agent ( agent ) agent . incar = False if ( not agent . high_risk and self . features . high_risk ): # If behavioral treatment on and agent HIV, ignore HR period. self . become_high_risk ( agent ) for bond in agent . location . params . high_risk . partnership_types : agent . mean_num_partners [ bond ] += agent . location . params . high_risk . partner_scale agent . target_partners [ bond ] = utils . poisson ( agent . mean_num_partners [ bond ], self . np_random ) self . pop . update_partnerability ( agent ) if hiv_bool : if agent . haart : if ( self . run_random . random () <= agent . location . params . incar . haart . discontinue ): # 12% remain surpressed agent . haart = False agent . haart_adherence = 0 # END FORCE elif self . run_random . random () < ( agent . location . params . demographics [ agent . race ][ agent . sex_type ] . incar . prob * hiv_multiplier * self . calibration . incarceration ): incar_duration = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . incar . duration . prob bin = current_p_value = 1 p = self . run_random . random () while p >= current_p_value : current_p_value += incar_duration [ bin ] . prob bin += 1 timestay = self . run_random . randint ( incar_duration [ bin ] . min , incar_duration [ bin ] . max ) if hiv_bool : if not agent . hiv_dx : if self . run_random . random () < agent . location . params . incar . hiv . dx : agent . hiv_dx = True else : # Then tested and HIV, check to enroll in ART if ( self . run_random . random () < agent . location . params . incar . haart . prob ): tmp_rnd = self . run_random . random () haart_adh = agent . location . params . incar . haart . adherence if tmp_rnd < haart_adh : adherence = 5 else : adherence = self . run_random . randint ( 1 , 4 ) # Add agent to HAART class set, update agent params agent . haart = True agent . haart_adherence = adherence agent . haart_time = self . time agent . incar = True agent . incar_time = timestay # PUT PARTNERS IN HIGH RISK for bond in agent . location . params . high_risk . partnership_types : for partner in agent . partners [ bond ]: if not partner . high_risk and self . features . high_risk : if ( self . run_random . random () < partner . location . params . high_risk . prob ): self . become_high_risk ( partner )","title":"incarcerate()"},{"location":"api/model/#titan.model.HIVModel.initialize_random_trial","text":"Initialize a random trial in the population Source code in titan/model.py def initialize_random_trial ( self ): \"\"\" Initialize a random trial in the population \"\"\" assert ( self . params . model . network . enable ), \"Network must be enabled for random trial\" print ( \"Starting random trial\" ) components = self . pop . connected_components () total_nodes = 0 print ( \"Number of components\" , len ([ 1 for comp in components if comp . number_of_nodes ()]), ) for comp in components : total_nodes += comp . number_of_nodes () if ( self . run_random . random () < self . params . prep . random_trial . intervention . prob ): # Component selected as treatment pod! if not self . features . pca : for ag in comp . nodes (): ag . random_trial_enrolled = True if not ag . hiv and not ag . prep : ag . intervention_ever = True if ( self . run_random . random () < ag . location . params . prep . target and not ag . vaccine ): self . initiate_prep ( ag , force = True ) elif self . params . prep . pca . choice == \"eigenvector\" : centrality = nx . algorithms . centrality . eigenvector_centrality ( comp ) assert len ( centrality ) >= 1 , \"Empty centrality\" ordered_centrality = sorted ( centrality , key = centrality . get ) intervention_agent = False for ag in ordered_centrality : ag . random_trial_enrolled = True if not ag . hiv and not intervention_agent : ag . prep_awareness = True ag . pca = True ag . pca_suitable = True ag . intervention_ever = True intervention_agent = True if not intervention_agent : ag = ordered_centrality [ 0 ] elif self . params . prep . pca . choice == \"bridge\" : # list all edges that are bridges for ag in comp . nodes : ag . random_trial_enrolled = True all_bridges = list ( nx . bridges ( comp )) comp_agents = [ agent for agents in all_bridges for agent in agents if not agent . hiv ] # all suitable agents in bridges if comp_agents : chosen_agent = utils . safe_random_choice ( comp_agents , self . run_random ) # select change agent chosen_agent . prep_awareness = True # make aware chosen_agent . pca = True chosen_agent . pca_suitable = True else : chosen_agent = list ( comp . nodes )[ 0 ] chosen_agent . pca = True elif self . params . prep . pca . choice == \"random\" : suitable_agent_choices = [] for ag in comp . nodes : ag . random_trial_enrolled = True if not ag . hiv : suitable_agent_choices . append ( ag ) if ( suitable_agent_choices ): # if there are agents who meet eligibility criteria, # select one randomly chosen_agent = utils . safe_random_choice ( suitable_agent_choices , self . run_random ) chosen_agent . pca = True chosen_agent . pca_suitable = True chosen_agent . prep_awareness = True # make aware chosen_agent . intervention_ever = True else : # if no suitable agents, mark a non-suitable agent chosen_agent = utils . safe_random_choice ( list ( comp . nodes ), self . run_random ) chosen_agent . pca = True print (( \"Total agents in trial: \" , total_nodes ))","title":"initialize_random_trial()"},{"location":"api/model/#titan.model.HIVModel.initiate_prep","text":"Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. Parameters: Name Type Description Default agent Agent agent being updated required force bool whether to force the agent to enroll instead of using the appropriate algorithm per the prep params False Source code in titan/model.py def initiate_prep ( self , agent : Agent , force : bool = False ): \"\"\" Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. args: agent : agent being updated force : whether to force the agent to enroll instead of using the appropriate algorithm per the prep params \"\"\" def enroll_prep ( self , agent : Agent ): agent . enroll_prep ( self . run_random ) self . new_prep . add_agent ( agent ) self . pop . prep_counts [ agent . race ] += 1 # agent must exist assert agent is not None # Prep only valid for agents not on prep and are HIV negative if agent . prep or agent . hiv : return # Determine probability of HIV treatment if force : enroll_prep ( self , agent ) else : if \"Racial\" in agent . location . params . prep . target_model : num_prep_agents = self . pop . prep_counts [ agent . race ] all_hiv_agents = self . pop . hiv_agents . members all_race = { a for a in self . pop . all_agents if a . race == agent . race } hiv_agents = len ( all_hiv_agents & all_race ) target_prep = ( len ( all_race ) - hiv_agents ) * agent . location . params . demographics [ agent . race ][ agent . sex_type ] . prep . coverage else : num_prep_agents = sum ( self . pop . prep_counts . values ()) target_prep = int ( ( self . pop . all_agents . num_members () - self . pop . hiv_agents . num_members () ) * agent . location . params . prep . target ) if ( num_prep_agents < target_prep and self . time >= agent . location . params . prep . start_time and agent . prep_eligible () ): enroll_prep ( self , agent )","title":"initiate_prep()"},{"location":"api/model/#titan.model.HIVModel.injection_transmission","text":"Simulate random transmission of HIV between two PWID agents through injection. Parameters: Name Type Description Default agent Agent PWID agent with HIV required partner Agent PWID agent without HIV required Source code in titan/model.py def injection_transmission ( self , agent : Agent , partner : Agent ): \"\"\" Simulate random transmission of HIV between two PWID agents through injection. args: agent: PWID agent with HIV partner: PWID agent without HIV \"\"\" assert agent . hiv assert not partner . hiv assert agent . drug_type == \"Inj\" assert partner . drug_type == \"Inj\" agent_race = agent . race agent_sex_type = agent . sex_type mean_num_acts = ( agent . location . params . demographics [ agent_race ][ agent_sex_type ] . injection . num_acts * self . calibration . injection . act ) share_acts = utils . poisson ( mean_num_acts , self . np_random ) if agent . ssp or partner . ssp : # syringe services program risk p_unsafe_injection = self . ssp_enrolled_risk else : # If sharing, minimum of 1 share act if share_acts < 1 : share_acts = 1 p_unsafe_injection = agent . location . params . demographics [ agent_race ][ agent_sex_type ] . injection . unsafe_prob if agent . hiv_dx or partner . hiv_dx : # diagnosis risk reduction p_unsafe_injection *= 1 - self . params . hiv . dx . risk_reduction . injection for n in range ( share_acts ): if self . run_random . random () > p_unsafe_injection : share_acts -= 1 if share_acts >= 1.0 : p = self . get_transmission_probability ( \"injection\" , agent , partner ) p_total_transmission : float if share_acts == 1 : p_total_transmission = p else : p_total_transmission = 1.0 - utils . binom_0 ( share_acts , p ) if self . run_random . random () < p_total_transmission : # if agent HIV+ partner becomes HIV+ self . hiv_convert ( partner )","title":"injection_transmission()"},{"location":"api/model/#titan.model.HIVModel.make_agent_zero","text":"Identify an agent as agent zero and HIV convert them Source code in titan/model.py def make_agent_zero ( self ): \"\"\" Identify an agent as agent zero and HIV convert them \"\"\" bonds = [ # Find what bond_types have the allowed interaction bond for bond , act_type in self . params . classes . bond_types . items () if self . params . agent_zero . interaction_type in act_type . acts_allowed ] max_partners = 0 max_agent = None zero_eligible = [] for agent in self . pop . all_agents : num_partners = agent . get_num_partners ( bond_types = bonds ) if num_partners >= self . params . agent_zero . num_partners : zero_eligible . append ( agent ) if num_partners > max_partners : max_partners = num_partners max_agent = agent agent_zero = utils . safe_random_choice ( zero_eligible , self . run_random ) if agent_zero : # if eligible agent, make agent 0 self . hiv_convert ( agent_zero ) elif self . params . agent_zero . fallback and max_agent is not None : self . hiv_convert ( max_agent ) else : raise ValueError ( \"No agent zero!\" )","title":"make_agent_zero()"},{"location":"api/model/#titan.model.HIVModel.pca_interaction","text":"Simulate peer change agent interactions. Knowledge if one agent is aware and one unaware, opinion if one agent swaying the other. Parameters: Name Type Description Default rel Relationship The relationship PCA is happening in required force Whether to force knowledge dissemination and influence False Source code in titan/model.py def pca_interaction ( self , rel : Relationship , force = False ): \"\"\" Simulate peer change agent interactions. Knowledge if one agent is aware and one unaware, opinion if one agent swaying the other. args: rel: The relationship PCA is happening in force: Whether to force knowledge dissemination and influence \"\"\" assert ( self . params . model . network . enable ), \"Network must be enabled for pca interactions\" def influence ( agent , partner ): agent_init_opinion = agent . prep_opinion partner_init_opinion = partner . prep_opinion agent_influence = nx . closeness_centrality ( self . pop . graph , agent ) partner_influence = nx . closeness_centrality ( self . pop . graph , partner ) if agent_influence > partner_influence : partner . prep_opinion = np . mean ( [ agent . prep_opinion , partner . prep_opinion ] ) elif agent_influence < partner_influence : agent . prep_opinion = np . mean ([ agent . prep_opinion , partner . prep_opinion ]) if ( agent_init_opinion < agent . location . params . prep . pca . opinion . threshold < agent . prep_opinion ): if self . run_random . random () < agent . location . params . prep . pca . prep . prob : self . initiate_prep ( agent , force = True ) elif ( partner_init_opinion < partner . location . params . prep . pca . opinion . threshold < partner . prep_opinion ): if ( self . run_random . random () < partner . location . params . prep . pca . prep . prob ): self . initiate_prep ( partner , force = True ) def knowledge_dissemination ( partner ): partner . prep_awareness = True if ( partner . prep_opinion > partner . location . params . prep . pca . opinion . threshold and self . run_random . random () < partner . location . params . prep . pca . prep . prob ): self . initiate_prep ( partner , force = True ) def knowledge_transmission_probability (): if rel . agent1 . prep_awareness and rel . agent2 . prep_awareness : p = self . params . prep . pca . opinion . transmission else : p = self . params . prep . pca . knowledge . transmission if num_acts == 1 : p_total_transmission = p elif num_acts >= 1 : p_total_transmission = 1.0 - utils . binom_0 ( num_acts , p ) else : p_total_transmission = 0 return p_total_transmission acts_prob = self . run_random . random () acts_bin = 0 current_p_value = 0.0 while acts_prob > current_p_value : acts_bin += 1 current_p_value += self . params . partnership . pca . frequency [ rel . bond_type ][ acts_bin ] . prob min = self . params . partnership . pca . frequency [ rel . bond_type ][ acts_bin ] . min max = self . params . partnership . pca . frequency [ rel . bond_type ][ acts_bin ] . max if min == max : num_acts = min else : num_acts = self . run_random . randrange ( min , max ) if num_acts < 1 and not force : return if rel . agent1 . prep_awareness and not rel . agent2 . prep_awareness : if self . run_random . random () < knowledge_transmission_probability () or force : knowledge_dissemination ( rel . agent2 ) elif not rel . agent1 . prep_awareness and rel . agent2 . prep_awareness : if self . run_random . random () < knowledge_transmission_probability () or force : knowledge_dissemination ( rel . agent1 ) elif rel . agent1 . prep_awareness and rel . agent2 . prep_awareness or force : if self . run_random . random () < knowledge_transmission_probability () or force : influence ( rel . agent1 , rel . agent2 )","title":"pca_interaction()"},{"location":"api/model/#titan.model.HIVModel.print_stats","text":"Create/update all of the reports defined in the params Source code in titan/model.py def print_stats ( self , stat : Dict [ str , Dict [ str , int ]], outdir : str ): \"\"\" Create/update all of the reports defined in the params \"\"\" for report in self . params . outputs . reports : printer = getattr ( ao , report ) printer ( self . id , self . time , self . run_seed , self . pop . pop_seed , stat , self . params , outdir , ) # network-based reports if ( self . time % self . params . outputs . print_frequency == 0 and self . params . model . network . enable ): assert ( self . network_utils is not None ), \"Graph must be enabled to print network reports\" network_outdir = os . path . join ( outdir , \"network\" ) if self . params . outputs . network . draw_figures : self . network_utils . visualize_network ( network_outdir , curtime = self . time , label = f \" { self . id } \" ) if self . params . outputs . network . calc_component_stats : ao . print_components ( self . id , self . time , self . run_seed , self . pop . pop_seed , self . pop . connected_components (), network_outdir , self . params . classes . races , ) if self . params . outputs . network . calc_network_stats : self . network_utils . write_network_stats ( network_outdir , self . id , self . time ) if self . params . outputs . network . edge_list : self . network_utils . write_graph_edgelist ( network_outdir , self . id , self . time )","title":"print_stats()"},{"location":"api/model/#titan.model.HIVModel.progress_to_aids","text":"Model the progression of HIV agents to AIDS agents Source code in titan/model.py def progress_to_aids ( self , agent : Agent ): \"\"\" Model the progression of HIV agents to AIDS agents \"\"\" # only valid for HIV agents assert agent . hiv p = prob . adherence_prob ( agent . haart_adherence ) if agent . haart else 1 if self . run_random . random () < p * agent . location . params . hiv . aids . prob : agent . aids = True","title":"progress_to_aids()"},{"location":"api/model/#titan.model.HIVModel.run","text":"Runs the model for the number of time steps defined in params, at each time step does: Increments time Takes one step Resets trackers Parameters: Name Type Description Default outdir str path to directory where results should be saved required Source code in titan/model.py def run ( self , outdir : str ): \"\"\" Runs the model for the number of time steps defined in params, at each time step does: 1. Increments time 2. Takes one step 3. Resets trackers args: outdir: path to directory where results should be saved \"\"\" if self . params . model . time . burn_steps > 0 : print ( \" \\t ===! Start Burn Loop !===\" ) else : # make sure t0 things get printed stats = ao . get_stats ( self . pop . all_agents , self . new_prep , self . new_infections , self . new_dx , self . new_high_risk , self . new_incar_release , self . deaths , self . params , ) self . print_stats ( stats , outdir ) # burn is negative time, model run starts at t = 1 for i in range ( - 1 * self . params . model . time . burn_steps , self . params . model . time . num_steps ): self . time += 1 self . step ( outdir ) self . reset_trackers () if self . time == 0 : if self . params . model . time . burn_steps > 0 : print ( \" \\t ===! Burn Loop Complete !===\" ) print ( \" \\t ===! Start Main Loop !===\" ) print ( \" \\t ===! Main Loop Complete !===\" )","title":"run()"},{"location":"api/model/#titan.model.HIVModel.sex_transmission","text":"Simulate random transmission of HIV between two agents through Sex. One of the agents must have HIV. Parameters: Name Type Description Default rel Relationship Relationship required Source code in titan/model.py def sex_transmission ( self , rel : Relationship ): \"\"\" Simulate random transmission of HIV between two agents through Sex. One of the agents must have HIV. args: rel : Relationship \"\"\" if rel . agent1 . hiv : agent = rel . agent1 partner = rel . agent2 elif rel . agent2 . hiv : agent = rel . agent2 partner = rel . agent1 else : raise ValueError ( \"rel must have an agent with HIV\" ) # HIV status of agent and partner # Everything from here is only run if one of them is HIV+ if partner . hiv : return # unprotected sex probabilities for primary partnerships mean_sex_acts = ( agent . get_number_of_sex_acts ( self . np_random ) * self . calibration . sex . act ) total_sex_acts = utils . poisson ( mean_sex_acts , self . np_random ) # Get condom usage p_safe_sex = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . safe_sex # increase condom usage if diagnosed if agent . hiv_dx or partner . hiv_dx : # Calculate probability of safe sex given risk reduction p_unsafe_sex = ( 1 - p_safe_sex ) * ( 1 - self . params . hiv . dx . risk_reduction . sex ) p_safe_sex *= 1 - p_unsafe_sex # Reduction of risk acts between partners for condom usage unsafe_sex_acts = total_sex_acts for n in range ( unsafe_sex_acts ): if self . run_random . random () < p_safe_sex : unsafe_sex_acts -= 1 if unsafe_sex_acts >= 1 : # agent is HIV+ rel . total_sex_acts += unsafe_sex_acts p_per_act = self . get_transmission_probability ( \"sex\" , agent , partner ) p_total_transmission : float if unsafe_sex_acts == 1 : p_total_transmission = p_per_act else : p_total_transmission = 1.0 - utils . binom_0 ( unsafe_sex_acts , p_per_act ) if self . run_random . random () < p_total_transmission : # if agent HIV+ partner becomes HIV+ self . hiv_convert ( partner )","title":"sex_transmission()"},{"location":"api/model/#titan.model.HIVModel.step","text":"A single time step in the model: Perform timeline_scaling updates to params if needed Update all agents Write/update reports with this timestep's data Parameters: Name Type Description Default outdir str path to directory where reports should be saved required Source code in titan/model.py def step ( self , outdir : str ): \"\"\" A single time step in the model: 1. Perform timeline_scaling updates to params if needed 2. Update all agents 3. Write/update reports with this timestep's data args: outdir: path to directory where reports should be saved \"\"\" print ( f \" \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t .: TIME { self . time } \" ) print ( \" \\t STARTING HIV count: {} \\t Total Incarcerated: {} \\t HR+: {} \\t \" \"PrEP: {} \" . format ( self . pop . hiv_agents . num_members (), sum ([ 1 for a in self . pop . all_agents if a . incar ]), self . pop . high_risk_agents . num_members (), sum ([ 1 for a in self . pop . all_agents if a . prep ]), ) ) self . timeline_scaling () self . update_all_agents () stats = ao . get_stats ( self . pop . all_agents , self . new_prep , self . new_infections , self . new_dx , self . new_high_risk , self . new_incar_release , self . deaths , self . params , ) self . print_stats ( stats , outdir ) print (( \"Number of relationships: {} \" . format ( len ( self . pop . relationships )))) self . pop . all_agents . print_subsets ()","title":"step()"},{"location":"api/model/#titan.model.HIVModel.timeline_scaling","text":"Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). Source code in titan/model.py def timeline_scaling ( self ): \"\"\" Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). \"\"\" if not self . features . timeline_scaling : return None # gather all of the param objectss to be scaled params_set = { self . params } for location in self . pop . geography . locations . values (): params_set . add ( location . params ) # iterate over each param and update the values if the time is right for params in params_set : for defn in params . timeline_scaling . timeline . values (): param = defn . parameter if param != \"ts_default\" : if defn . start_time == self . time : print ( f \"timeline scaling - { param } \" ) utils . scale_param ( params , param , defn . scalar ) elif defn . stop_time == self . time : print ( f \"timeline un-scaling - { param } \" ) utils . scale_param ( params , param , 1 / defn . scalar )","title":"timeline_scaling()"},{"location":"api/model/#titan.model.HIVModel.update_all_agents","text":"The core of the model. For a time step, update all of the agents and relationships: Create an agent zero (if enabled and the time is right) Update partner assignments (create new relationships as needed) Agents in relationships interact Update syringe services (if enabled) Update each agent's status for: age high risk prep incarceration hiv End relationships with no remaining duration Agent death/replacement Source code in titan/model.py def update_all_agents ( self ): \"\"\" The core of the model. For a time step, update all of the agents and relationships: 1. Create an agent zero (if enabled and the time is right) 2. Update partner assignments (create new relationships as needed) 3. Agents in relationships interact 4. Update syringe services (if enabled) 5. Update each agent's status for: * age * high risk * prep * incarceration * hiv 6. End relationships with no remaining duration 7. Agent death/replacement \"\"\" # If agent zero enabled, create agent zero at the beginning of main loop. if self . time == self . params . agent_zero . start_time and self . features . agent_zero : self . make_agent_zero () if not self . features . static_network : self . pop . update_partner_assignments ( t = self . time ) if self . pop . enable_graph : self . pop . trim_graph () for rel in self . pop . relationships : self . agents_interact ( rel ) if self . features . syringe_services : self . update_syringe_services () for agent in self . pop . all_agents : # happy birthday agents! if ( self . time > 0 and ( self . time % self . params . model . time . steps_per_year ) == 0 ): agent . age += 1 if self . features . high_risk : self . update_high_risk ( agent ) if ( self . features . pca and self . time >= self . params . prep . pca . start_time and ( self . run_random . random () < agent . location . params . prep . pca . awareness . prob ) ): agent . prep_awareness = True if self . run_random . random () < agent . location . params . prep . pca . prep . prob : self . initiate_prep ( agent , force = True ) if self . features . incar : self . incarcerate ( agent ) if ( agent . msmw and self . run_random . random () < agent . location . params . msmw . hiv . prob ): self . hiv_convert ( agent ) if agent . hiv : agent . hiv_time += 1 # If HIV hasn't started, ignore if self . time >= self . params . hiv . start_time : self . diagnose_hiv ( agent ) self . progress_to_aids ( agent ) if self . features . haart : self . update_haart ( agent ) else : if self . features . prep : if self . time >= agent . location . params . prep . start_time : if agent . prep : self . discontinue_prep ( agent ) elif agent . prep_eligible (): self . initiate_prep ( agent ) if self . features . vaccine and not agent . prep : self . advance_vaccine ( agent ) if ( self . features . prep and self . time == agent . location . params . prep . start_time and \"RandomTrial\" in agent . location . params . prep . target_model ): self . initialize_random_trial () # If static network, ignore relationship progression if not self . features . static_network : for rel in copy ( self . pop . relationships ): if rel . progress (): self . pop . remove_relationship ( rel ) if self . features . die_and_replace : self . die_and_replace ()","title":"update_all_agents()"},{"location":"api/model/#titan.model.HIVModel.update_haart","text":"Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status ( dx is True). Parameters: Name Type Description Default agent Agent agent being updated required Source code in titan/model.py def update_haart ( self , agent : Agent ): \"\"\" Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status (`dx` is True). args: agent: agent being updated \"\"\" if not self . features . haart : return None def initiate ( agent ): haart_adh = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . haart . adherence if self . run_random . random () < haart_adh : adherence = 5 else : adherence = self . run_random . randint ( 1 , 4 ) # Add agent to HAART class set, update agent params agent . haart = True agent . haart_adherence = adherence agent . haart_time = self . time self . pop . haart_counts [ agent . race ][ agent . sex_type ] += 1 # Check valid input assert agent . hiv # Determine probability of HIV treatment if agent . hiv_dx : haart_params = agent . location . params . demographics [ agent . race ][ agent . sex_type ] . haart # Go on HAART if not agent . haart : if agent . location . params . hiv . haart_cap : # if HAART is based on cap instead of prob, determine number of # HAART agents based on % of diagnosed agents num_dx_agents = self . pop . dx_counts [ agent . race ][ agent . sex_type ] num_haart_agents = self . pop . haart_counts [ agent . race ][ agent . sex_type ] if num_haart_agents < ( agent . location . params . demographics [ agent . race ][ agent . sex_type ] . haart . prob * num_dx_agents ): initiate ( agent ) else : if self . run_random . random () < ( haart_params . prob * self . calibration . haart . coverage ): initiate ( agent ) # Go off HAART elif agent . haart and self . run_random . random () < haart_params . discontinue : agent . haart = False agent . haart_adherence = 0 agent . haart_time = 0 self . pop . haart_counts [ agent . race ][ agent . sex_type ] -= 1","title":"update_haart()"},{"location":"api/model/#titan.model.HIVModel.update_high_risk","text":"Update high risk agents or remove them from high risk pool Source code in titan/model.py def update_high_risk ( self , agent : Agent ): \"\"\" Update high risk agents or remove them from high risk pool \"\"\" if agent not in self . pop . high_risk_agents : return None if agent . high_risk_time > 0 : agent . high_risk_time -= 1 else : self . pop . high_risk_agents . remove_agent ( agent ) agent . high_risk = False if self . features . incar : for bond in agent . location . params . high_risk . partnership_types : agent . mean_num_partners [ bond ] -= agent . location . params . high_risk . partner_scale agent . mean_num_partners [ bond ] = max ( 0 , agent . mean_num_partners [ bond ] ) # make sure not negative agent . target_partners [ bond ] = utils . poisson ( agent . mean_num_partners [ bond ], self . np_random ) while len ( agent . partners [ bond ]) > agent . target_partners [ bond ]: rel = utils . safe_random_choice ( agent . relationships , self . run_random ) if rel is not None : rel . progress ( force = True ) self . pop . remove_relationship ( rel )","title":"update_high_risk()"},{"location":"api/model/#titan.model.HIVModel.update_syringe_services","text":"Enroll PWID agents in syringe services Source code in titan/model.py def update_syringe_services ( self ): \"\"\" Enroll PWID agents in syringe services \"\"\" print (( \" \\n\\n !!!!Engaging syringe services program\" )) ssp_num_slots = 0 ssp_agents = { agent for agent in self . pop . pwid_agents . members if agent . ssp } if self . features . syringe_services : for item in self . params . syringe_services . timeline . values (): if item . start_time <= self . time < item . stop_time : self . ssp_enrolled_risk = item . risk ssp_num_slots = ( item . num_slots_stop - item . num_slots_start ) / ( item . stop_time - item . start_time ) * ( self . time - item . start_time ) + item . num_slots_start # If cap indicates all or no agents, do not change # otherwise, find true number of slots through distribution if 0 < ssp_num_slots < self . pop . pwid_agents . num_members (): ssp_num_slots = round ( self . run_random . betavariate ( ssp_num_slots , self . pop . pwid_agents . num_members () - ssp_num_slots , ) * self . pop . pwid_agents . num_members () ) break target_set = utils . safe_shuffle ( ( self . pop . pwid_agents . members - ssp_agents ), self . run_random ) for agent in ssp_agents . copy (): if len ( ssp_agents ) > ssp_num_slots : agent . ssp = False ssp_agents . remove ( agent ) if target_set : for agent in target_set : if len ( ssp_agents ) < ssp_num_slots : agent . ssp = True ssp_agents . add ( agent ) print ( f \"SSP has { ssp_num_slots } target slots with \" f \" { len ( ssp_agents ) } slots filled\" )","title":"update_syringe_services()"},{"location":"api/network/","text":"__init__ ( self , graph ) special This is the base class used to gather statistics from an exsting networkx graph object. Parameters: Name Type Description Default graph Graph NetworkX graph object (typically attached to a Population's graph attribute) required Source code in titan/network.py def __init__ ( self , graph : nx . Graph ): \"\"\" This is the base class used to gather statistics from an exsting networkx graph object. args: graph : NetworkX graph object (typically attached to a Population's `graph` attribute) \"\"\" self . G = graph connected_components ( self ) Get connected components in the graph Returns: Type Description List list of connected components Source code in titan/network.py def connected_components ( self ) -> List : \"\"\" Get connected components in the graph returns: list of connected components \"\"\" return list ( self . G . subgraph ( c ) . copy () for c in nx . connected_components ( self . G )) get_network_color ( self , coloring ) Get a vector of node colors for plotting this graph based on the type of coloring requested Parameters: Name Type Description Default coloring attribute to color nodes by (e.g. \"race\", \"diagnosed\") required Returns: Type Description List[str] list of colors in node order Source code in titan/network.py def get_network_color ( self , coloring ) -> List [ str ]: \"\"\" Get a vector of node colors for plotting this graph based on the type of coloring requested args: coloring: attribute to color nodes by (e.g. \"race\", \"diagnosed\") returns: list of colors in node order \"\"\" G = self . G node_color = [] # attribute based coloring color_order = [ \"b\" , \"g\" , \"c\" , \"r\" , \"y\" , \"purple\" , \"gray\" ] if hasattr ( list ( G . nodes )[ 0 ], coloring ): attrs : List [ str ] = [] for v in G : val = getattr ( v , coloring ) if val not in attrs : attrs . append ( val ) node_color . append ( color_order [ attrs . index ( val )]) return node_color # hard coded coloring schemes if coloring == \"Diagnosed\" : for v in G : if v . haart : node_color . append ( \"g\" ) elif v . hiv_dx : # tmp_hiv == 1: node_color . append ( \"y\" ) elif v . hiv : # tmp_aids == 1: node_color . append ( \"r\" ) elif v . prep : node_color . append ( \"b\" ) else : node_color . append ( \"purple\" ) elif coloring == \"Trtmt\" : for v in G : if v . hiv : # tmp_aids == 1: node_color . append ( \"r\" ) elif v . prep : node_color . append ( \"g\" ) elif v . intervention_ever : node_color . append ( \"y\" ) else : node_color . append ( \"gray\" ) elif coloring == \"HIV\" : for v in G : if v . aids : # tmp_hiv == 1: node_color . append ( \"purple\" ) elif v . hiv : # tmpaids == 1: node_color . append ( \"r\" ) else : node_color . append ( \"g\" ) elif coloring == \"HR\" : for v in G : if v . high_risk : # tmp_hiv == 1: node_color . append ( \"r\" ) elif v . high_risk_ever : # tmp_aids == 1: node_color . append ( \"y\" ) else : node_color . append ( \"g\" ) else : raise ValueError ( \"coloring value invalid! \\n {coloring} \\n \\ Only 'Diagnosed', 'Trtmt', 'HR', 'HIV', or an Agent attribute allowed!\" ) return node_color visualize_network ( self , outdir , coloring = 'sex_type' , pos = None , return_layout = False , node_size = None , curtime = 0 , infection_label = 0 , label = 'Network' ) Visualize the network using the spring layout (default). Parameters: Name Type Description Default outdir str directory the figure should be saved to required coloring str what attribute to color the nodes by 'sex_type' pos a graphviz_layout None return_layout bool whether to return the layout (if False , nothing is returned) False node_size Optional[float] size of the nodes in the graph None curtime int the current timestep of the model 0 infection_label int number of infections to list in figure's label 0 label str identifier for this network 'Network' Source code in titan/network.py def visualize_network ( self , outdir : str , coloring : str = \"sex_type\" , pos = None , return_layout : bool = False , node_size : Optional [ float ] = None , curtime : int = 0 , infection_label : int = 0 , label : str = \"Network\" , ): \"\"\" Visualize the network using the spring layout (default). args: outdir: directory the figure should be saved to coloring: what attribute to color the nodes by pos: a graphviz_layout return_layout: whether to return the layout (if `False`, nothing is returned) node_size: size of the nodes in the graph curtime: the current timestep of the model infection_label: number of infections to list in figure's label label: identifier for this network \"\"\" if node_size is None : node_size = 5000.0 / self . G . number_of_nodes () print (( \" \\t Plotting {} colored by {} ...\" ) . format ( label , coloring )) fig = plt . figure () ax = fig . add_axes ([ 0 , 0 , 1 , 1 ]) fig . clf () # build a rectangle in axes coords left , width = 0.0 , 1.0 bottom , height = 0.0 , 1.0 right = left + width top = bottom + height fig = plt . figure () ax = fig . add_axes ([ 0 , 0 , 1 , 1 ]) # axes coordinates are 0,0 is bottom left and 1,1 is upper right p = patches . Rectangle ( ( left , bottom ), width , height , fill = False , transform = ax . transAxes , clip_on = False , ) ax . add_patch ( p ) if not pos : pos = graphviz_layout ( self . G , prog = \"neato\" , args = \"\" ) edge_color = \"k\" node_shape = \"o\" # node color to by type node_color = self . get_network_color ( coloring ) # node size indicating node degree NodeSize = [] if node_size : for v in self . G : NodeSize . append ( node_size ) else : for v in self . G : NodeSize . append (( 10 * self . G . degree ( v )) ** ( 1.0 )) # draw: nx . draw ( self . G , pos , node_size = NodeSize , node_color = node_color , node_shape = node_shape , edge_color = edge_color , with_labels = False , linewidths = 0.5 , width = 0.5 , ) textstr = \" \\n \" . join ( ( r \"N infection= {:.2f} \" . format ( infection_label , ), r \"Time= {:.2f} \" . format ( curtime , ), ) ) # these are matplotlib.patch.Patch properties props = dict ( boxstyle = \"round\" , facecolor = \"wheat\" , alpha = 0.9 ) # place a text box in upper right in axes coords ax . text ( right - 0.025 , top - 0.025 , textstr , horizontalalignment = \"right\" , verticalalignment = \"top\" , transform = ax . transAxes , bbox = props , ) filename = os . path . join ( outdir , f \" { label } _ { self . G . number_of_nodes () } _ { coloring } _ { curtime } .png\" ) fig . savefig ( filename ) if return_layout : return pos write_graph_edgelist ( self , path , id , time ) Writes a pipe-delimited edge list to the file <id>_Edgelist_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/network.py def write_graph_edgelist ( self , path : str , id , time ): \"\"\" Writes a pipe-delimited edge list to the file `<id>_Edgelist_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _Edgelist_t { time } .txt\" ) # Write edgelist with bond type nx . write_edgelist ( self . G , file_path , delimiter = \"|\" , data = [ \"type\" ]) write_network_stats ( self , path , id , time ) Writes network statistics to the file <id>_NetworkStats_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/network.py def write_network_stats ( self , path : str , id , time ): \"\"\" Writes network statistics to the file `<id>_NetworkStats_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _NetworkStats_t { time } .txt\" ) components = sorted ( self . connected_components (), key = len , reverse = True ) outfile = open ( file_path , \"w\" ) outfile . write ( nx . info ( self . G )) cent_dict = nx . degree_centrality ( self . G ) outfile . write ( \" \\n Number of connected components: {} \\n \" . format ( nx . number_connected_components ( self . G ) ) ) tot_nodes = 0 for c in components : tot_nodes += c . number_of_nodes () outfile . write ( \"Average component size: {} \\n \" . format ( tot_nodes * 1.0 / nx . number_connected_components ( self . G ) ) ) outfile . write ( \"Maximum component size: {} \\n \" . format ( nx . number_of_nodes ( components [ 0 ])) ) outfile . write ( \"Degree Histogram: {} \\n \" . format ( nx . degree_histogram ( self . G ))) outfile . write ( \"Graph density: {} \\n \" . format ( nx . density ( self . G ))) outfile . write ( \"Average node degree centrality: {} \\n \" . format ( sum ( cent_dict . values ()) / len ( list ( cent_dict . values ())) ) ) outfile . write ( \"Average node clustering: {} \\n \" . format ( nx . average_clustering ( self . G )) ) outfile . close ()","title":"NetworkGraphUtils"},{"location":"api/network/#titan.network.NetworkGraphUtils.__init__","text":"This is the base class used to gather statistics from an exsting networkx graph object. Parameters: Name Type Description Default graph Graph NetworkX graph object (typically attached to a Population's graph attribute) required Source code in titan/network.py def __init__ ( self , graph : nx . Graph ): \"\"\" This is the base class used to gather statistics from an exsting networkx graph object. args: graph : NetworkX graph object (typically attached to a Population's `graph` attribute) \"\"\" self . G = graph","title":"__init__()"},{"location":"api/network/#titan.network.NetworkGraphUtils.connected_components","text":"Get connected components in the graph Returns: Type Description List list of connected components Source code in titan/network.py def connected_components ( self ) -> List : \"\"\" Get connected components in the graph returns: list of connected components \"\"\" return list ( self . G . subgraph ( c ) . copy () for c in nx . connected_components ( self . G ))","title":"connected_components()"},{"location":"api/network/#titan.network.NetworkGraphUtils.get_network_color","text":"Get a vector of node colors for plotting this graph based on the type of coloring requested Parameters: Name Type Description Default coloring attribute to color nodes by (e.g. \"race\", \"diagnosed\") required Returns: Type Description List[str] list of colors in node order Source code in titan/network.py def get_network_color ( self , coloring ) -> List [ str ]: \"\"\" Get a vector of node colors for plotting this graph based on the type of coloring requested args: coloring: attribute to color nodes by (e.g. \"race\", \"diagnosed\") returns: list of colors in node order \"\"\" G = self . G node_color = [] # attribute based coloring color_order = [ \"b\" , \"g\" , \"c\" , \"r\" , \"y\" , \"purple\" , \"gray\" ] if hasattr ( list ( G . nodes )[ 0 ], coloring ): attrs : List [ str ] = [] for v in G : val = getattr ( v , coloring ) if val not in attrs : attrs . append ( val ) node_color . append ( color_order [ attrs . index ( val )]) return node_color # hard coded coloring schemes if coloring == \"Diagnosed\" : for v in G : if v . haart : node_color . append ( \"g\" ) elif v . hiv_dx : # tmp_hiv == 1: node_color . append ( \"y\" ) elif v . hiv : # tmp_aids == 1: node_color . append ( \"r\" ) elif v . prep : node_color . append ( \"b\" ) else : node_color . append ( \"purple\" ) elif coloring == \"Trtmt\" : for v in G : if v . hiv : # tmp_aids == 1: node_color . append ( \"r\" ) elif v . prep : node_color . append ( \"g\" ) elif v . intervention_ever : node_color . append ( \"y\" ) else : node_color . append ( \"gray\" ) elif coloring == \"HIV\" : for v in G : if v . aids : # tmp_hiv == 1: node_color . append ( \"purple\" ) elif v . hiv : # tmpaids == 1: node_color . append ( \"r\" ) else : node_color . append ( \"g\" ) elif coloring == \"HR\" : for v in G : if v . high_risk : # tmp_hiv == 1: node_color . append ( \"r\" ) elif v . high_risk_ever : # tmp_aids == 1: node_color . append ( \"y\" ) else : node_color . append ( \"g\" ) else : raise ValueError ( \"coloring value invalid! \\n {coloring} \\n \\ Only 'Diagnosed', 'Trtmt', 'HR', 'HIV', or an Agent attribute allowed!\" ) return node_color","title":"get_network_color()"},{"location":"api/network/#titan.network.NetworkGraphUtils.visualize_network","text":"Visualize the network using the spring layout (default). Parameters: Name Type Description Default outdir str directory the figure should be saved to required coloring str what attribute to color the nodes by 'sex_type' pos a graphviz_layout None return_layout bool whether to return the layout (if False , nothing is returned) False node_size Optional[float] size of the nodes in the graph None curtime int the current timestep of the model 0 infection_label int number of infections to list in figure's label 0 label str identifier for this network 'Network' Source code in titan/network.py def visualize_network ( self , outdir : str , coloring : str = \"sex_type\" , pos = None , return_layout : bool = False , node_size : Optional [ float ] = None , curtime : int = 0 , infection_label : int = 0 , label : str = \"Network\" , ): \"\"\" Visualize the network using the spring layout (default). args: outdir: directory the figure should be saved to coloring: what attribute to color the nodes by pos: a graphviz_layout return_layout: whether to return the layout (if `False`, nothing is returned) node_size: size of the nodes in the graph curtime: the current timestep of the model infection_label: number of infections to list in figure's label label: identifier for this network \"\"\" if node_size is None : node_size = 5000.0 / self . G . number_of_nodes () print (( \" \\t Plotting {} colored by {} ...\" ) . format ( label , coloring )) fig = plt . figure () ax = fig . add_axes ([ 0 , 0 , 1 , 1 ]) fig . clf () # build a rectangle in axes coords left , width = 0.0 , 1.0 bottom , height = 0.0 , 1.0 right = left + width top = bottom + height fig = plt . figure () ax = fig . add_axes ([ 0 , 0 , 1 , 1 ]) # axes coordinates are 0,0 is bottom left and 1,1 is upper right p = patches . Rectangle ( ( left , bottom ), width , height , fill = False , transform = ax . transAxes , clip_on = False , ) ax . add_patch ( p ) if not pos : pos = graphviz_layout ( self . G , prog = \"neato\" , args = \"\" ) edge_color = \"k\" node_shape = \"o\" # node color to by type node_color = self . get_network_color ( coloring ) # node size indicating node degree NodeSize = [] if node_size : for v in self . G : NodeSize . append ( node_size ) else : for v in self . G : NodeSize . append (( 10 * self . G . degree ( v )) ** ( 1.0 )) # draw: nx . draw ( self . G , pos , node_size = NodeSize , node_color = node_color , node_shape = node_shape , edge_color = edge_color , with_labels = False , linewidths = 0.5 , width = 0.5 , ) textstr = \" \\n \" . join ( ( r \"N infection= {:.2f} \" . format ( infection_label , ), r \"Time= {:.2f} \" . format ( curtime , ), ) ) # these are matplotlib.patch.Patch properties props = dict ( boxstyle = \"round\" , facecolor = \"wheat\" , alpha = 0.9 ) # place a text box in upper right in axes coords ax . text ( right - 0.025 , top - 0.025 , textstr , horizontalalignment = \"right\" , verticalalignment = \"top\" , transform = ax . transAxes , bbox = props , ) filename = os . path . join ( outdir , f \" { label } _ { self . G . number_of_nodes () } _ { coloring } _ { curtime } .png\" ) fig . savefig ( filename ) if return_layout : return pos","title":"visualize_network()"},{"location":"api/network/#titan.network.NetworkGraphUtils.write_graph_edgelist","text":"Writes a pipe-delimited edge list to the file <id>_Edgelist_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/network.py def write_graph_edgelist ( self , path : str , id , time ): \"\"\" Writes a pipe-delimited edge list to the file `<id>_Edgelist_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _Edgelist_t { time } .txt\" ) # Write edgelist with bond type nx . write_edgelist ( self . G , file_path , delimiter = \"|\" , data = [ \"type\" ])","title":"write_graph_edgelist()"},{"location":"api/network/#titan.network.NetworkGraphUtils.write_network_stats","text":"Writes network statistics to the file <id>_NetworkStats_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/network.py def write_network_stats ( self , path : str , id , time ): \"\"\" Writes network statistics to the file `<id>_NetworkStats_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _NetworkStats_t { time } .txt\" ) components = sorted ( self . connected_components (), key = len , reverse = True ) outfile = open ( file_path , \"w\" ) outfile . write ( nx . info ( self . G )) cent_dict = nx . degree_centrality ( self . G ) outfile . write ( \" \\n Number of connected components: {} \\n \" . format ( nx . number_connected_components ( self . G ) ) ) tot_nodes = 0 for c in components : tot_nodes += c . number_of_nodes () outfile . write ( \"Average component size: {} \\n \" . format ( tot_nodes * 1.0 / nx . number_connected_components ( self . G ) ) ) outfile . write ( \"Maximum component size: {} \\n \" . format ( nx . number_of_nodes ( components [ 0 ])) ) outfile . write ( \"Degree Histogram: {} \\n \" . format ( nx . degree_histogram ( self . G ))) outfile . write ( \"Graph density: {} \\n \" . format ( nx . density ( self . G ))) outfile . write ( \"Average node degree centrality: {} \\n \" . format ( sum ( cent_dict . values ()) / len ( list ( cent_dict . values ())) ) ) outfile . write ( \"Average node clustering: {} \\n \" . format ( nx . average_clustering ( self . G )) ) outfile . close ()","title":"write_network_stats()"},{"location":"api/population/","text":"Population The Population class is used to represent the population of agents the model is running on. On construction, it stochastically creates the population described in the params . At its core, it is a graph with nodes ( all_agents ) and edges ( relationships ), it can be formally backed by a NetworkX graph by enabling the graph in the prams file. This allows for some graph-specific logic to be applied throughout the running of the model (e.g. trimming components, writing network statistics). __init__ ( self , params , id = None ) special Initialize Population object. Parameters: Name Type Description Default params ObjMap Model parameters required id Optional[str] 8 character identifier for a model None Source code in titan/population.py def __init__ ( self , params : ObjMap , id : Optional [ str ] = None ): \"\"\" Initialize Population object. args: params : Model parameters id: 8 character identifier for a model \"\"\" if id is None : self . id = nanoid . generate ( size = 8 ) else : self . id = id self . pop_seed = utils . get_check_rand_int ( params . model . seed . ppl ) # Init RNG for population creation to pop_seed self . pop_random = random . Random ( self . pop_seed ) self . np_random = np . random . RandomState ( self . pop_seed ) self . enable_graph = params . model . network . enable if self . enable_graph : self . graph = nx . Graph () else : self . graph = None self . params = params # pre-fetch param sub-sets for performance self . features = params . features # set up the population's locations and edges self . geography = Geography ( params ) # All agent set list self . all_agents = AgentSet ( \"AllAgents\" ) # HIV status agent sets self . hiv_agents = AgentSet ( \"HIV\" , parent = self . all_agents ) # High risk agent sets self . high_risk_agents = AgentSet ( \"HRisk\" , parent = self . all_agents ) # pwid agents (performance for partnering) self . pwid_agents = AgentSet ( \"PWID\" , parent = self . all_agents ) # agents who can take on a partner self . partnerable_agents : Dict [ str , Set [ Agent ]] = {} for bond_type in self . params . classes . bond_types . keys (): self . partnerable_agents [ bond_type ] = set () # who can sleep with whom self . sex_partners : Dict [ str , Set [ Agent ]] = {} for sex_type in self . params . classes . sex_types . keys (): self . sex_partners [ sex_type ] = set () self . relationships : Set [ Relationship ] = set () # keep track of prep agent counts by race self . prep_counts = { race : 0 for race in params . classes . races } agent_counts = { race : { so : 0 for so in params . classes . sex_types } for race in params . classes . races } self . dx_counts = deepcopy ( agent_counts ) self . haart_counts = deepcopy ( agent_counts ) # find average partnership durations self . mean_rel_duration : Dict [ str , int ] = get_mean_rel_duration ( self . params ) print ( \" \\t Creating agents\" ) # for each location in the population, create agents per that location's demographics init_time = - 1 * self . params . model . time . burn_steps for location in self . geography . locations . values (): for race in params . classes . races : for i in range ( round ( params . model . num_pop * location . ppl * location . params . demographics [ race ] . ppl ) ): agent = self . create_agent ( location , race , init_time ) self . add_agent ( agent ) if params . features . incar : print ( \" \\t Initializing Incarceration\" ) self . initialize_incarceration () # initialize relationships print ( \" \\t Creating Relationships\" ) self . update_partner_assignments ( 0 ) if self . enable_graph : self . trim_graph () add_agent ( self , agent ) Adds an agent to the population Parameters: Name Type Description Default agent Agent The agent to be added required Source code in titan/population.py def add_agent ( self , agent : Agent ): \"\"\" Adds an agent to the population args: agent : The agent to be added \"\"\" # Add to all agent set self . all_agents . add_agent ( agent ) if agent . hiv : self . hiv_agents . add_agent ( agent ) if agent . high_risk : self . high_risk_agents . add_agent ( agent ) if agent . drug_type == \"Inj\" : self . pwid_agents . add_agent ( agent ) # who can sleep with this agent for sex_type in self . params . classes . sex_types [ agent . sex_type ] . sleeps_with : self . sex_partners [ sex_type ] . add ( agent ) if agent . prep : self . prep_counts [ agent . race ] += 1 if self . enable_graph : self . graph . add_node ( agent ) add_relationship ( self , rel ) Add a new relationship to the population. Parameters: Name Type Description Default rel Relationship The Relationship to be added required Source code in titan/population.py def add_relationship ( self , rel : Relationship ): \"\"\" Add a new relationship to the population. args: rel : The Relationship to be added \"\"\" self . relationships . add ( rel ) if self . enable_graph : self . graph . add_edge ( rel . agent1 , rel . agent2 , type = rel . bond_type ) connected_components ( self ) Get connected components in graph (if enabled) Returns: Type Description List list of connected components Source code in titan/population.py def connected_components ( self ) -> List : \"\"\" Get connected components in graph (if enabled) returns: list of connected components \"\"\" if self . enable_graph : return list ( self . graph . subgraph ( c ) . copy () for c in nx . connected_components ( self . graph ) ) else : raise ValueError ( \"Can't get connected_components, population doesn't have graph enabled.\" ) create_agent ( self , location , race , time , sex_type = None ) Create a new agent with randomly assigned attributes according to population demographcis [params.demographics] Parameters: Name Type Description Default location Location location the agent will live in required race str race of the new agent required time int current time step of the model required sex_type Optional[str] sex_type of the new agent None Returns: Type Description Agent a new agent Source code in titan/population.py def create_agent ( self , location : Location , race : str , time : int , sex_type : Optional [ str ] = None ) -> Agent : \"\"\" Create a new agent with randomly assigned attributes according to population demographcis [params.demographics] args: location: location the agent will live in race : race of the new agent time: current time step of the model sex_type : sex_type of the new agent returns: a new agent \"\"\" if sex_type is None : sex_type = utils . safe_random_choice ( location . pop_weights [ race ][ \"values\" ], self . pop_random , weights = location . pop_weights [ race ][ \"weights\" ], ) if sex_type is None : raise ValueError ( \"Agent must have sex type\" ) # Determine drugtype drug_type = utils . safe_random_choice ( location . drug_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = location . drug_weights [ race ][ sex_type ][ \"weights\" ], ) if drug_type is None : raise ValueError ( \"Agent must have drug type\" ) age , age_bin = self . get_age ( location , race ) agent = Agent ( sex_type , age , race , drug_type , location ) agent . age_bin = age_bin sex_role = utils . safe_random_choice ( location . role_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = location . role_weights [ race ][ sex_type ][ \"weights\" ], ) if sex_role is None : raise ValueError ( \"Agent must have sex role\" ) else : agent . sex_role = sex_role if self . features . msmw and sex_type == \"HM\" : if self . pop_random . random () < location . params . msmw . prob : agent . msmw = True agent_params = agent . location . params . demographics [ race ][ agent . population ] # HIV if ( self . pop_random . random () < agent_params . hiv . init and time >= self . params . hiv . init ): agent . hiv = True if self . pop_random . random () < agent_params . aids . init : agent . aids = True if self . pop_random . random () < agent_params . hiv . dx . init : agent . hiv_dx = True self . dx_counts [ agent . race ][ agent . sex_type ] += 1 if self . pop_random . random () < agent_params . haart . init : agent . haart = True self . haart_counts [ agent . race ][ agent . sex_type ] += 1 haart_adh = location . params . demographics [ race ][ sex_type ] . haart . adherence if self . pop_random . random () < haart_adh : adherence = 5 else : adherence = self . pop_random . randint ( 1 , 4 ) agent . haart_adherence = adherence agent . haart_time = 0 # if HIV, how long has the agent had it? Random sample agent . hiv_time = self . pop_random . randint ( 1 , location . params . hiv . max_init_time ) else : if ( self . features . prep and agent . prep_eligible () and time >= location . params . prep . start_time and self . pop_random . random () < location . params . prep . target ): agent . enroll_prep ( self . pop_random ) elif ( self . features . vaccine and location . params . vaccine . on_init and self . pop_random . random () < location . params . demographics [ agent . race ][ agent . sex_type ] . vaccine . init ): agent . vaccinate () # Check if agent is HR as baseline. if ( self . features . high_risk and self . pop_random . random () < location . params . demographics [ race ][ sex_type ] . high_risk . init ): agent . high_risk = True agent . high_risk_ever = True agent . high_risk_time = self . pop_random . randint ( 1 , location . params . high_risk . sex_based [ agent . sex_type ] . duration ) for bond , bond_def in location . params . classes . bond_types . items (): agent . partners [ bond ] = set () dist_info = agent_params . num_partners [ bond ] agent . mean_num_partners [ bond ] = ceil ( utils . safe_dist ( dist_info , self . np_random ) * utils . safe_divide ( agent . location . params . calibration . sex . partner , self . mean_rel_duration [ bond ], ) ) # so not zero if added mid-year agent . target_partners [ bond ] = agent . mean_num_partners [ bond ] if \"injection\" in bond_def . acts_allowed : assert agent . drug_type == \"Inj\" or agent . mean_num_partners [ bond ] == 0 if agent . target_partners [ bond ] > 0 : self . partnerable_agents [ bond ] . add ( agent ) if self . features . pca : if self . pop_random . random () < location . params . prep . pca . awareness . init : agent . prep_awareness = True attprob = self . pop_random . random () pvalue = 0.0 for bin , fields in location . params . prep . pca . attitude . items (): pvalue += fields . prob if attprob < pvalue : agent . prep_opinion = bin break return agent get_age ( self , location , race ) Given the population characteristics, get a random age to assign to an agent given the race of that agent Parameters: Name Type Description Default race str race of the agent whose age is being generated required Returns: Type Description Tuple[int, int] age and the bin the age came from Source code in titan/population.py def get_age ( self , location : Location , race : str ) -> Tuple [ int , int ]: \"\"\" Given the population characteristics, get a random age to assign to an agent given the race of that agent args: race : race of the agent whose age is being generated returns: age and the bin the age came from \"\"\" rand = self . pop_random . random () bins = location . params . demographics [ race ] . age for i in range ( 1 , 6 ): if rand < bins [ i ] . prob : min_age = bins [ i ] . min max_age = bins [ i ] . max break age = self . pop_random . randrange ( min_age , max_age ) return age , i initialize_incarceration ( self ) Run incarceration assignment on a population. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. Source code in titan/population.py def initialize_incarceration ( self ): \"\"\" Run incarceration assignment on a population. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. \"\"\" for a in self . all_agents : incar_params = a . location . params . demographics [ a . race ][ a . sex_type ] . incar jail_duration = incar_params . duration . init prob_incar = incar_params . init if self . pop_random . random () < prob_incar : a . incar = True bin = current_p_value = 0 p = self . pop_random . random () while p > current_p_value : bin += 1 current_p_value += jail_duration [ bin ] . prob a . incar_time = self . pop_random . randrange ( jail_duration [ bin ] . min , jail_duration [ bin ] . max ) remove_agent ( self , agent ) Remove an agent from the population. Parameters: Name Type Description Default agent Agent Agent to remove required Source code in titan/population.py def remove_agent ( self , agent : Agent ): \"\"\" Remove an agent from the population. args: agent : Agent to remove \"\"\" self . all_agents . remove_agent ( agent ) for partner_type in self . sex_partners : if agent in self . sex_partners [ partner_type ]: self . sex_partners [ partner_type ] . remove ( agent ) if agent . prep : self . prep_counts [ agent . race ] -= 1 if agent . hiv_dx : self . dx_counts [ agent . race ][ agent . sex_type ] -= 1 if agent . haart : self . haart_counts [ agent . race ][ agent . sex_type ] -= 1 if self . enable_graph : self . graph . remove_node ( agent ) for bond in self . partnerable_agents . values (): if agent in bond : bond . remove ( agent ) remove_relationship ( self , rel ) Remove a relationship from the population. Parameters: Name Type Description Default rel Relationship Relationship to remove required Source code in titan/population.py def remove_relationship ( self , rel : Relationship ): \"\"\" Remove a relationship from the population. args: rel : Relationship to remove \"\"\" self . relationships . remove ( rel ) # without this relationship, are agents partnerable again? self . update_partnerability ( rel . agent1 ) self . update_partnerability ( rel . agent2 ) if self . enable_graph : self . graph . remove_edge ( rel . agent1 , rel . agent2 ) trim_graph ( self ) Initialize network with graph-based algorithm for relationship adding/pruning Source code in titan/population.py def trim_graph ( self ): \"\"\" Initialize network with graph-based algorithm for relationship adding/pruning \"\"\" if self . params . model . network . type == \"comp_size\" : def trim_component ( component , max_size ): for ag in component . nodes : if ( self . pop_random . random () < self . params . calibration . network . trim . prob ): for rel in copy ( ag . relationships ): if len ( ag . relationships ) == 1 : break # Make sure that agents stay part of the # network by keeping one bond rel . progress ( force = True ) self . remove_relationship ( rel ) component . remove_edge ( rel . agent1 , rel . agent2 ) # recurse on new sub-components sub_comps = list ( component . subgraph ( c ) . copy () for c in nx . connected_components ( component ) ) for sub_comp in sub_comps : if sub_comp . number_of_nodes () > max_size : trim_component ( component , max_size ) components = sorted ( self . connected_components (), key = len , reverse = True ) for comp in components : if ( comp . number_of_nodes () > self . params . model . network . component_size . max ): print ( \"TOO BIG\" , comp , comp . number_of_nodes ()) trim_component ( comp , self . params . model . network . component_size . max ) print ( \" \\t Total agents in graph: \" , self . graph . number_of_nodes ()) update_agent_partners ( self , agent , bond_type , components ) Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. Parameters: Name Type Description Default agent Agent Agent that is seeking a new partner required bond_type str What type of bond the agent is seeking to make required Returns: Type Description bool True if no match was found for agent (used for retries) Source code in titan/population.py def update_agent_partners ( self , agent : Agent , bond_type : str , components : List ) -> bool : \"\"\" Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. args: agent: Agent that is seeking a new partner bond_type: What type of bond the agent is seeking to make returns: True if no match was found for agent (used for retries) \"\"\" partnerable_agents = self . partnerable_agents [ bond_type ] if ( self . pop_random . random () < self . params . partnership . network . same_component . prob and agent . has_partners () ): # find agent's component agent_component : Set [ Agent ] = set () for comp in components : if agent in comp : agent_component = comp break partnerable_agents = partnerable_agents & agent_component partner = select_partner ( agent , partnerable_agents , self . sex_partners , self . pwid_agents , self . params , self . pop_random , bond_type , ) no_match = True if partner : duration = get_partnership_duration ( agent . location . params , self . np_random , bond_type ) relationship = Relationship ( agent , partner , duration , bond_type = bond_type ) self . add_relationship ( relationship ) # can partner still partner? if len ( partner . partners [ bond_type ]) > ( partner . target_partners [ bond_type ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond_type ] . remove ( partner ) no_match = False return no_match update_partner_assignments ( self , t ) Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. Parameters: Name Type Description Default t int current time step of the model required Source code in titan/population.py def update_partner_assignments ( self , t : int ): \"\"\" Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. args: t: current time step of the model \"\"\" # update agent targets annually if t % self . params . model . time . steps_per_year == 0 : self . update_partner_targets () if self . enable_graph : network_components = [ set ( g . nodes ()) for g in self . connected_components ()] else : network_components = [] # Now create partnerships until available partnerships are out for bond in self . params . classes . bond_types : eligible_agents = deque ( [ a for a in self . all_agents if len ( a . partners [ bond ]) < a . target_partners [ bond ] ] ) attempts = { a : 0 for a in eligible_agents } while eligible_agents : agent = eligible_agents . popleft () if len ( agent . partners [ bond ]) < agent . target_partners [ bond ]: # no match if self . update_agent_partners ( agent , bond , network_components ): attempts [ agent ] += 1 # add agent back to eligible pool if ( len ( agent . partners [ bond ]) < agent . target_partners [ bond ] and attempts [ agent ] < self . params . calibration . partnership . break_point ): eligible_agents . append ( agent ) update_partner_targets ( self ) Update the target number of partners for each agent and bond type Source code in titan/population.py def update_partner_targets ( self ): \"\"\" Update the target number of partners for each agent and bond type \"\"\" for a in self . all_agents : for bond in self . params . classes . bond_types : a . target_partners [ bond ] = utils . poisson ( a . mean_num_partners [ bond ], self . np_random ) self . update_partnerability ( a ) update_partnerability ( self , a ) Update whether each agent in the population is currently able to form new relationships for each bond type Source code in titan/population.py def update_partnerability ( self , a ): \"\"\" Update whether each agent in the population is currently able to form new relationships for each bond type \"\"\" for bond in self . params . classes . bond_types . keys (): if a in self . partnerable_agents [ bond ]: if len ( a . partners [ bond ]) > ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . remove ( a ) elif len ( a . partners [ bond ]) < ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . add ( a ) Population Reading & Writing Released in v1.1.0 Populations can be saved to file so that they can be analysed in detail or re-used in a future run. run_titan.py allows this using the --savepop [path] option to save the population to the path, and the --poppath [path] option loads the population at the path. The population is saved after creation, but before the model has run. Saving the Population The population is represented as a series of csv files that save the attributes for the core entities (agents, relationships at this time). The population can be saved with only core attributes (e.g. race, sex_type, hiv) or with intervention attributes (e.g. prep, vaccinated) as well. intervention attributes are less likely to work as intended across versions of the model. titan.population_io.write ( pop , dir , intervention_attrs = False , compress = True ) Write a non-empty Population to file. Parameters: Name Type Description Default pop Population a non-empty agent population required dir str path to directory where files should be written required intervention_attrs bool whether to include intervention attributions in addition to core agent attributes (less likely to be backwards compatible if used with different versions of the model) False compress bool whether to compress and archive the csv True Returns: Type Description str path, or archive name if compress is true Source code in titan/population_io.py def write ( pop : Population , dir : str , intervention_attrs : bool = False , compress : bool = True ) -> str : \"\"\" Write a non-empty Population to file. args: pop: a non-empty agent population dir: path to directory where files should be written intervention_attrs: whether to include intervention attributions in addition to core agent attributes (less likely to be backwards compatible if used with different versions of the model) compress: whether to compress and archive the csv returns: path, or archive name if compress is true \"\"\" assert len ( pop . relationships ) > 0 , \"can't write empty population\" # open agent file agent_file = os . path . join ( dir , f \" { pop . id } _agents.csv\" ) if intervention_attrs : # get all attributes a = next ( iter ( pop . all_agents )) agent_attrs = [ k for k in a . __dict__ . keys () if k not in agent_exclude_attrs ] else : agent_attrs = agent_core_attrs with open ( agent_file , \"w\" , newline = \"\" ) as f : writer = csv . DictWriter ( f , fieldnames = agent_attrs ) writer . writeheader () for agent in pop . all_agents : writer . writerow ({ attr : repr ( getattr ( agent , attr )) for attr in agent_attrs }) # open relationship file rel_file = os . path . join ( dir , f \" { pop . id } _relationships.csv\" ) r = next ( iter ( pop . relationships )) rel_attrs = list ( r . __dict__ . keys ()) with open ( rel_file , \"w\" , newline = \"\" ) as f : writer = csv . DictWriter ( f , fieldnames = rel_attrs ) writer . writeheader () for rel in pop . relationships : writer . writerow ({ attr : repr ( getattr ( rel , attr )) for attr in rel_attrs }) if compress : archive_name = make_archive ( os . path . join ( dir , f \" { pop . id } _pop\" ), \"gztar\" , root_dir = dir , base_dir = \".\" ) os . remove ( agent_file ) os . remove ( rel_file ) return archive_name else : return dir Reading in/using a Saved Population A population can be created from the files saved, however, there is no validation done to ensure the params used when running on this population make sense/match what was originally used when creating it. Some things may validly change (e.g. interventions, reports needed, seeds), but others may result in strange behavior if changed (e.g. race distribution, what classes are in use). titan.population_io.read ( params , path ) Read a population from file and return a Population instance Parameters: Name Type Description Default params ObjMap the parameters used for creating this popultation required path str path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population required Returns: Type Description Population the re-constituted population Source code in titan/population_io.py def read ( params : ObjMap , path : str ) -> Population : \"\"\" Read a population from file and return a Population instance args: params: the parameters used for creating this popultation path: path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population returns: the re-constituted population \"\"\" if os . path . isfile ( path ): dir = mkdtemp () unpack_archive ( path , dir ) path = dir agent_file = glob . glob ( os . path . join ( path , \"*_agents.csv\" ))[ 0 ] rel_file = glob . glob ( os . path . join ( path , \"*_relationships.csv\" ))[ 0 ] assert os . path . isfile ( agent_file ), f \"can't find agents.csv in { dir } \" assert os . path . isfile ( rel_file ), f \"can't find relationships.csv in { dir } \" _ , agent_filename = os . path . split ( agent_file ) id = agent_filename [: 8 ] # don't create any agents on init params . model . num_pop = 0 pop = Population ( params , id = id ) # re-create all agents and add to population with open ( agent_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : a = create_agent ( row , params . classes . bond_types . keys (), pop . geography . locations ) pop . add_agent ( a ) # update num_pop to actual population params . model . num_pop = pop . all_agents . num_members () # re-create all relationships and add to population with open ( rel_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : r = create_relationship ( row , pop ) pop . add_relationship ( r ) return pop","title":"Population"},{"location":"api/population/#population","text":"The Population class is used to represent the population of agents the model is running on. On construction, it stochastically creates the population described in the params . At its core, it is a graph with nodes ( all_agents ) and edges ( relationships ), it can be formally backed by a NetworkX graph by enabling the graph in the prams file. This allows for some graph-specific logic to be applied throughout the running of the model (e.g. trimming components, writing network statistics).","title":"Population"},{"location":"api/population/#titan.population.Population.__init__","text":"Initialize Population object. Parameters: Name Type Description Default params ObjMap Model parameters required id Optional[str] 8 character identifier for a model None Source code in titan/population.py def __init__ ( self , params : ObjMap , id : Optional [ str ] = None ): \"\"\" Initialize Population object. args: params : Model parameters id: 8 character identifier for a model \"\"\" if id is None : self . id = nanoid . generate ( size = 8 ) else : self . id = id self . pop_seed = utils . get_check_rand_int ( params . model . seed . ppl ) # Init RNG for population creation to pop_seed self . pop_random = random . Random ( self . pop_seed ) self . np_random = np . random . RandomState ( self . pop_seed ) self . enable_graph = params . model . network . enable if self . enable_graph : self . graph = nx . Graph () else : self . graph = None self . params = params # pre-fetch param sub-sets for performance self . features = params . features # set up the population's locations and edges self . geography = Geography ( params ) # All agent set list self . all_agents = AgentSet ( \"AllAgents\" ) # HIV status agent sets self . hiv_agents = AgentSet ( \"HIV\" , parent = self . all_agents ) # High risk agent sets self . high_risk_agents = AgentSet ( \"HRisk\" , parent = self . all_agents ) # pwid agents (performance for partnering) self . pwid_agents = AgentSet ( \"PWID\" , parent = self . all_agents ) # agents who can take on a partner self . partnerable_agents : Dict [ str , Set [ Agent ]] = {} for bond_type in self . params . classes . bond_types . keys (): self . partnerable_agents [ bond_type ] = set () # who can sleep with whom self . sex_partners : Dict [ str , Set [ Agent ]] = {} for sex_type in self . params . classes . sex_types . keys (): self . sex_partners [ sex_type ] = set () self . relationships : Set [ Relationship ] = set () # keep track of prep agent counts by race self . prep_counts = { race : 0 for race in params . classes . races } agent_counts = { race : { so : 0 for so in params . classes . sex_types } for race in params . classes . races } self . dx_counts = deepcopy ( agent_counts ) self . haart_counts = deepcopy ( agent_counts ) # find average partnership durations self . mean_rel_duration : Dict [ str , int ] = get_mean_rel_duration ( self . params ) print ( \" \\t Creating agents\" ) # for each location in the population, create agents per that location's demographics init_time = - 1 * self . params . model . time . burn_steps for location in self . geography . locations . values (): for race in params . classes . races : for i in range ( round ( params . model . num_pop * location . ppl * location . params . demographics [ race ] . ppl ) ): agent = self . create_agent ( location , race , init_time ) self . add_agent ( agent ) if params . features . incar : print ( \" \\t Initializing Incarceration\" ) self . initialize_incarceration () # initialize relationships print ( \" \\t Creating Relationships\" ) self . update_partner_assignments ( 0 ) if self . enable_graph : self . trim_graph ()","title":"__init__()"},{"location":"api/population/#titan.population.Population.add_agent","text":"Adds an agent to the population Parameters: Name Type Description Default agent Agent The agent to be added required Source code in titan/population.py def add_agent ( self , agent : Agent ): \"\"\" Adds an agent to the population args: agent : The agent to be added \"\"\" # Add to all agent set self . all_agents . add_agent ( agent ) if agent . hiv : self . hiv_agents . add_agent ( agent ) if agent . high_risk : self . high_risk_agents . add_agent ( agent ) if agent . drug_type == \"Inj\" : self . pwid_agents . add_agent ( agent ) # who can sleep with this agent for sex_type in self . params . classes . sex_types [ agent . sex_type ] . sleeps_with : self . sex_partners [ sex_type ] . add ( agent ) if agent . prep : self . prep_counts [ agent . race ] += 1 if self . enable_graph : self . graph . add_node ( agent )","title":"add_agent()"},{"location":"api/population/#titan.population.Population.add_relationship","text":"Add a new relationship to the population. Parameters: Name Type Description Default rel Relationship The Relationship to be added required Source code in titan/population.py def add_relationship ( self , rel : Relationship ): \"\"\" Add a new relationship to the population. args: rel : The Relationship to be added \"\"\" self . relationships . add ( rel ) if self . enable_graph : self . graph . add_edge ( rel . agent1 , rel . agent2 , type = rel . bond_type )","title":"add_relationship()"},{"location":"api/population/#titan.population.Population.connected_components","text":"Get connected components in graph (if enabled) Returns: Type Description List list of connected components Source code in titan/population.py def connected_components ( self ) -> List : \"\"\" Get connected components in graph (if enabled) returns: list of connected components \"\"\" if self . enable_graph : return list ( self . graph . subgraph ( c ) . copy () for c in nx . connected_components ( self . graph ) ) else : raise ValueError ( \"Can't get connected_components, population doesn't have graph enabled.\" )","title":"connected_components()"},{"location":"api/population/#titan.population.Population.create_agent","text":"Create a new agent with randomly assigned attributes according to population demographcis [params.demographics] Parameters: Name Type Description Default location Location location the agent will live in required race str race of the new agent required time int current time step of the model required sex_type Optional[str] sex_type of the new agent None Returns: Type Description Agent a new agent Source code in titan/population.py def create_agent ( self , location : Location , race : str , time : int , sex_type : Optional [ str ] = None ) -> Agent : \"\"\" Create a new agent with randomly assigned attributes according to population demographcis [params.demographics] args: location: location the agent will live in race : race of the new agent time: current time step of the model sex_type : sex_type of the new agent returns: a new agent \"\"\" if sex_type is None : sex_type = utils . safe_random_choice ( location . pop_weights [ race ][ \"values\" ], self . pop_random , weights = location . pop_weights [ race ][ \"weights\" ], ) if sex_type is None : raise ValueError ( \"Agent must have sex type\" ) # Determine drugtype drug_type = utils . safe_random_choice ( location . drug_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = location . drug_weights [ race ][ sex_type ][ \"weights\" ], ) if drug_type is None : raise ValueError ( \"Agent must have drug type\" ) age , age_bin = self . get_age ( location , race ) agent = Agent ( sex_type , age , race , drug_type , location ) agent . age_bin = age_bin sex_role = utils . safe_random_choice ( location . role_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = location . role_weights [ race ][ sex_type ][ \"weights\" ], ) if sex_role is None : raise ValueError ( \"Agent must have sex role\" ) else : agent . sex_role = sex_role if self . features . msmw and sex_type == \"HM\" : if self . pop_random . random () < location . params . msmw . prob : agent . msmw = True agent_params = agent . location . params . demographics [ race ][ agent . population ] # HIV if ( self . pop_random . random () < agent_params . hiv . init and time >= self . params . hiv . init ): agent . hiv = True if self . pop_random . random () < agent_params . aids . init : agent . aids = True if self . pop_random . random () < agent_params . hiv . dx . init : agent . hiv_dx = True self . dx_counts [ agent . race ][ agent . sex_type ] += 1 if self . pop_random . random () < agent_params . haart . init : agent . haart = True self . haart_counts [ agent . race ][ agent . sex_type ] += 1 haart_adh = location . params . demographics [ race ][ sex_type ] . haart . adherence if self . pop_random . random () < haart_adh : adherence = 5 else : adherence = self . pop_random . randint ( 1 , 4 ) agent . haart_adherence = adherence agent . haart_time = 0 # if HIV, how long has the agent had it? Random sample agent . hiv_time = self . pop_random . randint ( 1 , location . params . hiv . max_init_time ) else : if ( self . features . prep and agent . prep_eligible () and time >= location . params . prep . start_time and self . pop_random . random () < location . params . prep . target ): agent . enroll_prep ( self . pop_random ) elif ( self . features . vaccine and location . params . vaccine . on_init and self . pop_random . random () < location . params . demographics [ agent . race ][ agent . sex_type ] . vaccine . init ): agent . vaccinate () # Check if agent is HR as baseline. if ( self . features . high_risk and self . pop_random . random () < location . params . demographics [ race ][ sex_type ] . high_risk . init ): agent . high_risk = True agent . high_risk_ever = True agent . high_risk_time = self . pop_random . randint ( 1 , location . params . high_risk . sex_based [ agent . sex_type ] . duration ) for bond , bond_def in location . params . classes . bond_types . items (): agent . partners [ bond ] = set () dist_info = agent_params . num_partners [ bond ] agent . mean_num_partners [ bond ] = ceil ( utils . safe_dist ( dist_info , self . np_random ) * utils . safe_divide ( agent . location . params . calibration . sex . partner , self . mean_rel_duration [ bond ], ) ) # so not zero if added mid-year agent . target_partners [ bond ] = agent . mean_num_partners [ bond ] if \"injection\" in bond_def . acts_allowed : assert agent . drug_type == \"Inj\" or agent . mean_num_partners [ bond ] == 0 if agent . target_partners [ bond ] > 0 : self . partnerable_agents [ bond ] . add ( agent ) if self . features . pca : if self . pop_random . random () < location . params . prep . pca . awareness . init : agent . prep_awareness = True attprob = self . pop_random . random () pvalue = 0.0 for bin , fields in location . params . prep . pca . attitude . items (): pvalue += fields . prob if attprob < pvalue : agent . prep_opinion = bin break return agent","title":"create_agent()"},{"location":"api/population/#titan.population.Population.get_age","text":"Given the population characteristics, get a random age to assign to an agent given the race of that agent Parameters: Name Type Description Default race str race of the agent whose age is being generated required Returns: Type Description Tuple[int, int] age and the bin the age came from Source code in titan/population.py def get_age ( self , location : Location , race : str ) -> Tuple [ int , int ]: \"\"\" Given the population characteristics, get a random age to assign to an agent given the race of that agent args: race : race of the agent whose age is being generated returns: age and the bin the age came from \"\"\" rand = self . pop_random . random () bins = location . params . demographics [ race ] . age for i in range ( 1 , 6 ): if rand < bins [ i ] . prob : min_age = bins [ i ] . min max_age = bins [ i ] . max break age = self . pop_random . randrange ( min_age , max_age ) return age , i","title":"get_age()"},{"location":"api/population/#titan.population.Population.initialize_incarceration","text":"Run incarceration assignment on a population. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. Source code in titan/population.py def initialize_incarceration ( self ): \"\"\" Run incarceration assignment on a population. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. \"\"\" for a in self . all_agents : incar_params = a . location . params . demographics [ a . race ][ a . sex_type ] . incar jail_duration = incar_params . duration . init prob_incar = incar_params . init if self . pop_random . random () < prob_incar : a . incar = True bin = current_p_value = 0 p = self . pop_random . random () while p > current_p_value : bin += 1 current_p_value += jail_duration [ bin ] . prob a . incar_time = self . pop_random . randrange ( jail_duration [ bin ] . min , jail_duration [ bin ] . max )","title":"initialize_incarceration()"},{"location":"api/population/#titan.population.Population.remove_agent","text":"Remove an agent from the population. Parameters: Name Type Description Default agent Agent Agent to remove required Source code in titan/population.py def remove_agent ( self , agent : Agent ): \"\"\" Remove an agent from the population. args: agent : Agent to remove \"\"\" self . all_agents . remove_agent ( agent ) for partner_type in self . sex_partners : if agent in self . sex_partners [ partner_type ]: self . sex_partners [ partner_type ] . remove ( agent ) if agent . prep : self . prep_counts [ agent . race ] -= 1 if agent . hiv_dx : self . dx_counts [ agent . race ][ agent . sex_type ] -= 1 if agent . haart : self . haart_counts [ agent . race ][ agent . sex_type ] -= 1 if self . enable_graph : self . graph . remove_node ( agent ) for bond in self . partnerable_agents . values (): if agent in bond : bond . remove ( agent )","title":"remove_agent()"},{"location":"api/population/#titan.population.Population.remove_relationship","text":"Remove a relationship from the population. Parameters: Name Type Description Default rel Relationship Relationship to remove required Source code in titan/population.py def remove_relationship ( self , rel : Relationship ): \"\"\" Remove a relationship from the population. args: rel : Relationship to remove \"\"\" self . relationships . remove ( rel ) # without this relationship, are agents partnerable again? self . update_partnerability ( rel . agent1 ) self . update_partnerability ( rel . agent2 ) if self . enable_graph : self . graph . remove_edge ( rel . agent1 , rel . agent2 )","title":"remove_relationship()"},{"location":"api/population/#titan.population.Population.trim_graph","text":"Initialize network with graph-based algorithm for relationship adding/pruning Source code in titan/population.py def trim_graph ( self ): \"\"\" Initialize network with graph-based algorithm for relationship adding/pruning \"\"\" if self . params . model . network . type == \"comp_size\" : def trim_component ( component , max_size ): for ag in component . nodes : if ( self . pop_random . random () < self . params . calibration . network . trim . prob ): for rel in copy ( ag . relationships ): if len ( ag . relationships ) == 1 : break # Make sure that agents stay part of the # network by keeping one bond rel . progress ( force = True ) self . remove_relationship ( rel ) component . remove_edge ( rel . agent1 , rel . agent2 ) # recurse on new sub-components sub_comps = list ( component . subgraph ( c ) . copy () for c in nx . connected_components ( component ) ) for sub_comp in sub_comps : if sub_comp . number_of_nodes () > max_size : trim_component ( component , max_size ) components = sorted ( self . connected_components (), key = len , reverse = True ) for comp in components : if ( comp . number_of_nodes () > self . params . model . network . component_size . max ): print ( \"TOO BIG\" , comp , comp . number_of_nodes ()) trim_component ( comp , self . params . model . network . component_size . max ) print ( \" \\t Total agents in graph: \" , self . graph . number_of_nodes ())","title":"trim_graph()"},{"location":"api/population/#titan.population.Population.update_agent_partners","text":"Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. Parameters: Name Type Description Default agent Agent Agent that is seeking a new partner required bond_type str What type of bond the agent is seeking to make required Returns: Type Description bool True if no match was found for agent (used for retries) Source code in titan/population.py def update_agent_partners ( self , agent : Agent , bond_type : str , components : List ) -> bool : \"\"\" Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. args: agent: Agent that is seeking a new partner bond_type: What type of bond the agent is seeking to make returns: True if no match was found for agent (used for retries) \"\"\" partnerable_agents = self . partnerable_agents [ bond_type ] if ( self . pop_random . random () < self . params . partnership . network . same_component . prob and agent . has_partners () ): # find agent's component agent_component : Set [ Agent ] = set () for comp in components : if agent in comp : agent_component = comp break partnerable_agents = partnerable_agents & agent_component partner = select_partner ( agent , partnerable_agents , self . sex_partners , self . pwid_agents , self . params , self . pop_random , bond_type , ) no_match = True if partner : duration = get_partnership_duration ( agent . location . params , self . np_random , bond_type ) relationship = Relationship ( agent , partner , duration , bond_type = bond_type ) self . add_relationship ( relationship ) # can partner still partner? if len ( partner . partners [ bond_type ]) > ( partner . target_partners [ bond_type ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond_type ] . remove ( partner ) no_match = False return no_match","title":"update_agent_partners()"},{"location":"api/population/#titan.population.Population.update_partner_assignments","text":"Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. Parameters: Name Type Description Default t int current time step of the model required Source code in titan/population.py def update_partner_assignments ( self , t : int ): \"\"\" Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. args: t: current time step of the model \"\"\" # update agent targets annually if t % self . params . model . time . steps_per_year == 0 : self . update_partner_targets () if self . enable_graph : network_components = [ set ( g . nodes ()) for g in self . connected_components ()] else : network_components = [] # Now create partnerships until available partnerships are out for bond in self . params . classes . bond_types : eligible_agents = deque ( [ a for a in self . all_agents if len ( a . partners [ bond ]) < a . target_partners [ bond ] ] ) attempts = { a : 0 for a in eligible_agents } while eligible_agents : agent = eligible_agents . popleft () if len ( agent . partners [ bond ]) < agent . target_partners [ bond ]: # no match if self . update_agent_partners ( agent , bond , network_components ): attempts [ agent ] += 1 # add agent back to eligible pool if ( len ( agent . partners [ bond ]) < agent . target_partners [ bond ] and attempts [ agent ] < self . params . calibration . partnership . break_point ): eligible_agents . append ( agent )","title":"update_partner_assignments()"},{"location":"api/population/#titan.population.Population.update_partner_targets","text":"Update the target number of partners for each agent and bond type Source code in titan/population.py def update_partner_targets ( self ): \"\"\" Update the target number of partners for each agent and bond type \"\"\" for a in self . all_agents : for bond in self . params . classes . bond_types : a . target_partners [ bond ] = utils . poisson ( a . mean_num_partners [ bond ], self . np_random ) self . update_partnerability ( a )","title":"update_partner_targets()"},{"location":"api/population/#titan.population.Population.update_partnerability","text":"Update whether each agent in the population is currently able to form new relationships for each bond type Source code in titan/population.py def update_partnerability ( self , a ): \"\"\" Update whether each agent in the population is currently able to form new relationships for each bond type \"\"\" for bond in self . params . classes . bond_types . keys (): if a in self . partnerable_agents [ bond ]: if len ( a . partners [ bond ]) > ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . remove ( a ) elif len ( a . partners [ bond ]) < ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . add ( a )","title":"update_partnerability()"},{"location":"api/population/#population-reading-writing","text":"Released in v1.1.0 Populations can be saved to file so that they can be analysed in detail or re-used in a future run. run_titan.py allows this using the --savepop [path] option to save the population to the path, and the --poppath [path] option loads the population at the path. The population is saved after creation, but before the model has run.","title":"Population Reading &amp; Writing"},{"location":"api/population/#saving-the-population","text":"The population is represented as a series of csv files that save the attributes for the core entities (agents, relationships at this time). The population can be saved with only core attributes (e.g. race, sex_type, hiv) or with intervention attributes (e.g. prep, vaccinated) as well. intervention attributes are less likely to work as intended across versions of the model.","title":"Saving the Population"},{"location":"api/population/#titan.population_io.write","text":"Write a non-empty Population to file. Parameters: Name Type Description Default pop Population a non-empty agent population required dir str path to directory where files should be written required intervention_attrs bool whether to include intervention attributions in addition to core agent attributes (less likely to be backwards compatible if used with different versions of the model) False compress bool whether to compress and archive the csv True Returns: Type Description str path, or archive name if compress is true Source code in titan/population_io.py def write ( pop : Population , dir : str , intervention_attrs : bool = False , compress : bool = True ) -> str : \"\"\" Write a non-empty Population to file. args: pop: a non-empty agent population dir: path to directory where files should be written intervention_attrs: whether to include intervention attributions in addition to core agent attributes (less likely to be backwards compatible if used with different versions of the model) compress: whether to compress and archive the csv returns: path, or archive name if compress is true \"\"\" assert len ( pop . relationships ) > 0 , \"can't write empty population\" # open agent file agent_file = os . path . join ( dir , f \" { pop . id } _agents.csv\" ) if intervention_attrs : # get all attributes a = next ( iter ( pop . all_agents )) agent_attrs = [ k for k in a . __dict__ . keys () if k not in agent_exclude_attrs ] else : agent_attrs = agent_core_attrs with open ( agent_file , \"w\" , newline = \"\" ) as f : writer = csv . DictWriter ( f , fieldnames = agent_attrs ) writer . writeheader () for agent in pop . all_agents : writer . writerow ({ attr : repr ( getattr ( agent , attr )) for attr in agent_attrs }) # open relationship file rel_file = os . path . join ( dir , f \" { pop . id } _relationships.csv\" ) r = next ( iter ( pop . relationships )) rel_attrs = list ( r . __dict__ . keys ()) with open ( rel_file , \"w\" , newline = \"\" ) as f : writer = csv . DictWriter ( f , fieldnames = rel_attrs ) writer . writeheader () for rel in pop . relationships : writer . writerow ({ attr : repr ( getattr ( rel , attr )) for attr in rel_attrs }) if compress : archive_name = make_archive ( os . path . join ( dir , f \" { pop . id } _pop\" ), \"gztar\" , root_dir = dir , base_dir = \".\" ) os . remove ( agent_file ) os . remove ( rel_file ) return archive_name else : return dir","title":"write()"},{"location":"api/population/#reading-inusing-a-saved-population","text":"A population can be created from the files saved, however, there is no validation done to ensure the params used when running on this population make sense/match what was originally used when creating it. Some things may validly change (e.g. interventions, reports needed, seeds), but others may result in strange behavior if changed (e.g. race distribution, what classes are in use).","title":"Reading in/using a Saved Population"},{"location":"api/population/#titan.population_io.read","text":"Read a population from file and return a Population instance Parameters: Name Type Description Default params ObjMap the parameters used for creating this popultation required path str path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population required Returns: Type Description Population the re-constituted population Source code in titan/population_io.py def read ( params : ObjMap , path : str ) -> Population : \"\"\" Read a population from file and return a Population instance args: params: the parameters used for creating this popultation path: path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population returns: the re-constituted population \"\"\" if os . path . isfile ( path ): dir = mkdtemp () unpack_archive ( path , dir ) path = dir agent_file = glob . glob ( os . path . join ( path , \"*_agents.csv\" ))[ 0 ] rel_file = glob . glob ( os . path . join ( path , \"*_relationships.csv\" ))[ 0 ] assert os . path . isfile ( agent_file ), f \"can't find agents.csv in { dir } \" assert os . path . isfile ( rel_file ), f \"can't find relationships.csv in { dir } \" _ , agent_filename = os . path . split ( agent_file ) id = agent_filename [: 8 ] # don't create any agents on init params . model . num_pop = 0 pop = Population ( params , id = id ) # re-create all agents and add to population with open ( agent_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : a = create_agent ( row , params . classes . bond_types . keys (), pop . geography . locations ) pop . add_agent ( a ) # update num_pop to actual population params . model . num_pop = pop . all_agents . num_members () # re-create all relationships and add to population with open ( rel_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : r = create_relationship ( row , pop ) pop . add_relationship ( r ) return pop","title":"read()"},{"location":"api/relationship/","text":"Class for agent relationships. __init__ ( self , agent1 , agent2 , duration , bond_type , id = None ) special Constructor for a Relationship Parameters: Name Type Description Default agent1 Agent first agent required agent2 Agent second agent required duration int target duration of relationship required bond_type str type of bond for the relationship [params.classes.bond_types] required id Optional[int] unique identifier None Source code in titan/agent.py def __init__ ( self , agent1 : Agent , agent2 : Agent , duration : int , bond_type : str , id : Optional [ int ] = None , ): \"\"\" Constructor for a Relationship args: agent1: first agent agent2: second agent duration: target duration of relationship bond_type: type of bond for the relationship [params.classes.bond_types] id: unique identifier \"\"\" # make sure these agents can be in a relationship assert agent1 != agent2 , \"Cannot create relationship with same agent\" for rel in agent1 . relationships : assert agent2 != rel . get_partner ( agent1 ), \"Agents already partnered!\" # self.id is unique ID number used to track each person agent. self . agent1 = agent1 self . agent2 = agent2 if id is not None : self . id = id else : self . id = self . next_rel_id self . update_id_counter ( self . id ) # TODO MAKE THIS INCREMENT WITH passed IDs # Relationship properties self . duration = duration self . total_duration = duration self . total_sex_acts = 0 self . bond_type = bond_type self . bond () bond ( self ) Bond two agents. Adds the relationship to each agent's relationships set, then adds each partner to the others' partner list. Source code in titan/agent.py def bond ( self ) -> None : \"\"\" Bond two agents. Adds the relationship to each agent's `relationships` set, then adds each partner to the others' partner list. \"\"\" # Append relationship to relationships list for each agent self . agent1 . relationships . add ( self ) self . agent2 . relationships . add ( self ) # Pair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . add ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . add ( self . agent1 ) get_partner ( self , agent ) Given an agent in the relationship, return the other agent Parameters: Name Type Description Default agent Agent one of the agents in the relationship required Returns: Type Description Agent the agent's partner Source code in titan/agent.py def get_partner ( self , agent : \"Agent\" ) -> \"Agent\" : \"\"\" Given an agent in the relationship, return the other agent args: agent: one of the agents in the relationship returns: the agent's partner \"\"\" if agent == self . agent1 : return self . agent2 elif agent == self . agent2 : return self . agent1 else : raise ValueError ( \"Agent must be in this relationship\" ) progress ( self , force = False ) Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if force is set to True Parameters: Name Type Description Default force bool whether to force the relationship to end False Source code in titan/agent.py def progress ( self , force : bool = False ) -> bool : \"\"\" Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if `force` is set to `True` args: force: whether to force the relationship to end \"\"\" if self . duration <= 0 or force : self . unbond () return True else : self . duration -= 1 return False unbond ( self ) Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. Source code in titan/agent.py def unbond ( self ): \"\"\" Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. \"\"\" # Remove relationship to relationships list for each agent self . agent1 . relationships . remove ( self ) self . agent2 . relationships . remove ( self ) # Unpair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . remove ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . remove ( self . agent1 )","title":"Relationship"},{"location":"api/relationship/#titan.agent.Relationship.__init__","text":"Constructor for a Relationship Parameters: Name Type Description Default agent1 Agent first agent required agent2 Agent second agent required duration int target duration of relationship required bond_type str type of bond for the relationship [params.classes.bond_types] required id Optional[int] unique identifier None Source code in titan/agent.py def __init__ ( self , agent1 : Agent , agent2 : Agent , duration : int , bond_type : str , id : Optional [ int ] = None , ): \"\"\" Constructor for a Relationship args: agent1: first agent agent2: second agent duration: target duration of relationship bond_type: type of bond for the relationship [params.classes.bond_types] id: unique identifier \"\"\" # make sure these agents can be in a relationship assert agent1 != agent2 , \"Cannot create relationship with same agent\" for rel in agent1 . relationships : assert agent2 != rel . get_partner ( agent1 ), \"Agents already partnered!\" # self.id is unique ID number used to track each person agent. self . agent1 = agent1 self . agent2 = agent2 if id is not None : self . id = id else : self . id = self . next_rel_id self . update_id_counter ( self . id ) # TODO MAKE THIS INCREMENT WITH passed IDs # Relationship properties self . duration = duration self . total_duration = duration self . total_sex_acts = 0 self . bond_type = bond_type self . bond ()","title":"__init__()"},{"location":"api/relationship/#titan.agent.Relationship.bond","text":"Bond two agents. Adds the relationship to each agent's relationships set, then adds each partner to the others' partner list. Source code in titan/agent.py def bond ( self ) -> None : \"\"\" Bond two agents. Adds the relationship to each agent's `relationships` set, then adds each partner to the others' partner list. \"\"\" # Append relationship to relationships list for each agent self . agent1 . relationships . add ( self ) self . agent2 . relationships . add ( self ) # Pair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . add ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . add ( self . agent1 )","title":"bond()"},{"location":"api/relationship/#titan.agent.Relationship.get_partner","text":"Given an agent in the relationship, return the other agent Parameters: Name Type Description Default agent Agent one of the agents in the relationship required Returns: Type Description Agent the agent's partner Source code in titan/agent.py def get_partner ( self , agent : \"Agent\" ) -> \"Agent\" : \"\"\" Given an agent in the relationship, return the other agent args: agent: one of the agents in the relationship returns: the agent's partner \"\"\" if agent == self . agent1 : return self . agent2 elif agent == self . agent2 : return self . agent1 else : raise ValueError ( \"Agent must be in this relationship\" )","title":"get_partner()"},{"location":"api/relationship/#titan.agent.Relationship.progress","text":"Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if force is set to True Parameters: Name Type Description Default force bool whether to force the relationship to end False Source code in titan/agent.py def progress ( self , force : bool = False ) -> bool : \"\"\" Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if `force` is set to `True` args: force: whether to force the relationship to end \"\"\" if self . duration <= 0 or force : self . unbond () return True else : self . duration -= 1 return False","title":"progress()"},{"location":"api/relationship/#titan.agent.Relationship.unbond","text":"Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. Source code in titan/agent.py def unbond ( self ): \"\"\" Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. \"\"\" # Remove relationship to relationships list for each agent self . agent1 . relationships . remove ( self ) self . agent2 . relationships . remove ( self ) # Unpair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . remove ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . remove ( self . agent1 )","title":"unbond()"},{"location":"api/reporting/","text":"Tabular Reports add_agent_to_stats ( stats , attrs , agent , key ) Update the stats dictionary counts for the key given the agent's attributes Parameters: Name Type Description Default stats Dict[str, Any] a nested dictionary of attributes to counts required attrs List[str] a list of attribute types (e.g. \"race\") required agent Agent the agent whose attribute values will be evaluated required key str the type of count to increment required Source code in titan/output.py def add_agent_to_stats ( stats : Dict [ str , Any ], attrs : List [ str ], agent : Agent , key : str ): \"\"\" Update the stats dictionary counts for the key given the agent's attributes args: stats: a nested dictionary of attributes to counts attrs: a list of attribute types (e.g. \"race\") agent: the agent whose attribute values will be evaluated key: the type of count to increment \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ str ( getattr ( agent , attr ))] stats_item [ key ] += 1 basicReport ( run_id , t , runseed , popseed , stats , params , outdir ) Standard report writer for basic agent statistics, columns include: Total : number of agents in the population HIV : number of agents with HIV AIDS : number of agents with AIDS Dx : number of agents with HIV who are diagnosed ART : number of agents on HAART nHR : number of agents who are high risk Incid : number of agents who HIV converted this time period HR_6mo : number of agents with HIV converted this time period who are high risk HR_Ev : number of agents with HIV converted this time period who have ever been high risk NewDiag : number of agents with HIV who were diagnosed this time period Deaths : number of agents who died this time period PrEP : number of agents enrolled in PrEP Vaccinated : number of agents who have been vaccinated LAI : number of agents enrolled in PrEP with a type of LAI Oral : number of agents enrolled in PrEP with a type of Oral Source code in titan/output.py def basicReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for basic agent statistics, columns include: * `Total`: number of agents in the population * `HIV`: number of agents with HIV * `AIDS`: number of agents with AIDS * `Dx`: number of agents with HIV who are diagnosed * `ART`: number of agents on HAART * `nHR`: number of agents who are high risk * `Incid`: number of agents who HIV converted this time period * `HR_6mo`: number of agents with HIV converted this time period who are high risk * `HR_Ev`: number of agents with HIV converted this time period who have ever been high risk * `NewDiag`: number of agents with HIV who were diagnosed this time period * `Deaths`: number of agents who died this time period * `PrEP`: number of agents enrolled in PrEP * `Vaccinated`: number of agents who have been vaccinated * `LAI`: number of agents enrolled in PrEP with a type of LAI * `Oral`: number of agents enrolled in PrEP with a type of Oral \"\"\" name_map = { \"numAgents\" : \"Total\" , \"numHIV\" : \"HIV\" , \"numAIDS\" : \"AIDS\" , \"numDiagnosed\" : \"Dx\" , \"numART\" : \"ART\" , \"numHR\" : \"nHR\" , \"inf_newInf\" : \"Incid\" , \"inf_HR6m\" : \"HR_6mo\" , \"inf_HRever\" : \"HR_Ev\" , \"newlyDiagnosed\" : \"NewDx\" , \"deaths\" : \"Deaths\" , \"numPrEP\" : \"PrEP\" , \"vaccinated\" : \"Vaccinated\" , \"injectable_prep\" : \"LAI\" , \"oral_prep\" : \"Oral\" , } write_report ( \"basicReport.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir ) deathReport ( run_id , t , runseed , popseed , stats , params , outdir ) Standard report writer for agent deaths, columns include: tot : total number of deaths at this timestep HIV : number of deaths of agents with HIV at this timestep Source code in titan/output.py def deathReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for agent deaths, columns include: * `tot`: total number of deaths at this timestep * `HIV`: number of deaths of agents with HIV at this timestep \"\"\" name_map = { \"deaths\" : \"tot\" , \"deaths_HIV\" : \"HIV\" , } write_report ( \"DeathReport.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir ) get_agg_val ( stats , attrs , key ) Get the value of a key in stats given the attribute values Parameters: Name Type Description Default stats Dict a nested dictionary of attributes to count required attrs List a list of attribute values to find the count for required key str the type of count to get the value of required Returns: Type Description int the count of key for the given attributes Source code in titan/output.py def get_agg_val ( stats : Dict , attrs : List , key : str ) -> int : \"\"\" Get the value of a key in stats given the attribute values args: stats: a nested dictionary of attributes to count attrs: a list of attribute values to find the count for key: the type of count to get the value of returns: the count of key for the given attributes \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ attr ] return stats_item [ key ] get_aggregates ( params ) Get iterator over all attribute combinations for output classes Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description Iterator iterator over attribute combinations Source code in titan/output.py def get_aggregates ( params : ObjMap ) -> Iterator : \"\"\" Get iterator over all attribute combinations for output classes args: params: model parameters returns: iterator over attribute combinations \"\"\" return itertools . product ( * [ list ( k for k in params . classes [ clss ]) for clss in params . outputs . classes ] ) get_stats ( all_agents , new_prep_agents , new_hiv , new_hiv_dx , new_high_risk , new_incar_release , deaths , params ) Get the current statistics for a model based on the population, and tracking agent sets from the model. Parameters: Name Type Description Default all_agents AgentSet all of the agents in the population required new_prep_agents AgentSet agents who are newly on prep this timestep required new_hiv AgentSet agents are newly hiv this timestep required new_hiv_dx AgentSet agents who are newly diagnosed with hiv this timestep required new_high_risk AgentSet agents who are newly high risk this timestep required new_incar_release AgentSet agents are released from incarceration this timestep required deaths List[titan.agent.Agent] agents who died this timestep required params ObjMap model parameters required Returns: Type Description Dict nested dictionary of agent attributes to counts of various items Source code in titan/output.py def get_stats ( all_agents : AgentSet , new_prep_agents : AgentSet , new_hiv : AgentSet , new_hiv_dx : AgentSet , new_high_risk : AgentSet , new_incar_release : AgentSet , deaths : List [ Agent ], params : ObjMap , ) -> Dict : \"\"\" Get the current statistics for a model based on the population, and tracking agent sets from the model. args: all_agents: all of the agents in the population new_prep_agents: agents who are newly on prep this timestep new_hiv: agents are newly hiv this timestep new_hiv_dx: agents who are newly diagnosed with hiv this timestep new_high_risk: agents who are newly high risk this timestep new_incar_release: agents are released from incarceration this timestep deaths: agents who died this timestep params: model parameters returns: nested dictionary of agent attributes to counts of various items \"\"\" stats = setup_aggregates ( params , params . outputs . classes ) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] # attribute version (non-plural) # Incarceration metrics for a in new_incar_release : add_agent_to_stats ( stats , attrs , a , \"newRelease\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"newReleaseHIV\" ) # Newly infected tracker statistics (with HR within 6mo and HR ever bool check) for a in new_hiv : add_agent_to_stats ( stats , attrs , a , \"inf_newInf\" ) if a . high_risk_ever : add_agent_to_stats ( stats , attrs , a , \"inf_HRever\" ) if a . high_risk : add_agent_to_stats ( stats , attrs , a , \"inf_HR6m\" ) for a in all_agents : add_agent_to_stats ( stats , attrs , a , \"numAgents\" ) if a . prep : add_agent_to_stats ( stats , attrs , a , \"numPrEP\" ) if a . prep_type == \"Inj\" : add_agent_to_stats ( stats , attrs , a , \"injectable_prep\" ) elif a . prep_type == \"Oral\" : add_agent_to_stats ( stats , attrs , a , \"oral_prep\" ) if a . incar : add_agent_to_stats ( stats , attrs , a , \"incar\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"incarHIV\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"numHIV\" ) if a . aids : add_agent_to_stats ( stats , attrs , a , \"numAIDS\" ) if a . hiv_dx : add_agent_to_stats ( stats , attrs , a , \"numDiagnosed\" ) if a . haart : add_agent_to_stats ( stats , attrs , a , \"numART\" ) if a . vaccine : add_agent_to_stats ( stats , attrs , a , \"vaccinated\" ) # Newly PrEP tracker statistics for a in new_prep_agents : add_agent_to_stats ( stats , attrs , a , \"newNumPrEP\" ) # Newly diagnosed tracker statistics for a in new_hiv_dx : add_agent_to_stats ( stats , attrs , a , \"newlyDiagnosed\" ) # Newly HR agents for a in new_high_risk : add_agent_to_stats ( stats , attrs , a , \"newHR\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"newHR_HIV\" ) if a . aids : add_agent_to_stats ( stats , attrs , a , \"newHR_AIDS\" ) if a . hiv_dx : add_agent_to_stats ( stats , attrs , a , \"newHR_dx\" ) if a . haart : add_agent_to_stats ( stats , attrs , a , \"newHR_ART\" ) for a in deaths : add_agent_to_stats ( stats , attrs , a , \"deaths\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"deaths_HIV\" ) return stats incarReport ( run_id , t , runseed , popseed , stats , params , outdir ) Standard report writer for agent incarcerations, columns include: tot : total number of incarcerated agents at this timestep HIV : number of incarcerated agents with HIV at this timestep rlsd : number of agents released at this timestep rlsdHIV : number of agents with HIV released at this timestep Source code in titan/output.py def incarReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for agent incarcerations, columns include: * `tot`: total number of incarcerated agents at this timestep * `HIV`: number of incarcerated agents with HIV at this timestep * `rlsd`: number of agents released at this timestep * `rlsdHIV`: number of agents with HIV released at this timestep \"\"\" name_map = { \"incar\" : \"tot\" , \"incarHIV\" : \"HIV\" , \"newRelease\" : \"rlsd\" , \"newReleaseHIV\" : \"rlsdHIV\" , } write_report ( \"IncarReport.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir ) newlyhighriskReport ( run_id , t , runseed , popseed , stats , params , outdir ) Standard report writer for newly high risk agents, columns include: newHR : number of agents that became high risk at this timestep newHR_HIV : number of agents with HIV that became high risk at this timestep newHR_AIDS : number of agents with AIDS that became high risk at this timestep newHR_Tested : number of agents with diagnosed HIV that became high risk at this timestep newHR_ART : number of agents on HAART that became high risk at this timestep Source code in titan/output.py def newlyhighriskReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for newly high risk agents, columns include: * `newHR`: number of agents that became high risk at this timestep * `newHR_HIV`: number of agents with HIV that became high risk at this timestep * `newHR_AIDS`: number of agents with AIDS that became high risk at this timestep * `newHR_Tested`: number of agents with diagnosed HIV that became high risk at this timestep * `newHR_ART`: number of agents on HAART that became high risk at this timestep \"\"\" name_map = { \"newHR\" : \"newHR\" , \"newHR_HIV\" : \"newHR_HIV\" , \"newHR_AIDS\" : \"newHR_AIDS\" , \"newHR_dx\" : \"newHR_Diagnosed\" , \"newHR_ART\" : \"newHR_ART\" , } write_report ( \"newlyHR_Report.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir , ) print_components ( run_id , t , runseed , popseed , components , outdir , races ) Write stats describing the components (sub-graphs) in a graph to file Parameters: Name Type Description Default run_id str unique identifer for this run of the model required t int current timestep required runseed int integer used to seed the model's random number generator required popseed int integer used to seed the population's random number generator required components List a list of graph components required outdir str path where the file should be saved required races list the races in the population required Source code in titan/output.py def print_components ( run_id : str , t : int , runseed : int , popseed : int , components : List , outdir : str , races : list , ): \"\"\" Write stats describing the components (sub-graphs) in a graph to file args: run_id: unique identifer for this run of the model t: current timestep runseed: integer used to seed the model's random number generator popseed: integer used to seed the population's random number generator components: a list of graph components outdir: path where the file should be saved races: the races in the population \"\"\" f = open ( os . path . join ( outdir , f \" { run_id } _componentReport_ALL.txt\" ), \"a\" ) race_count : Dict [ str , int ] = {} race_list = [] header = \"\" for race in races : race_list . append ( race ) header += \" \\t \" + race # if this is a new file, write the header info if f . tell () == 0 : f . write ( \"run_id \\t runseed \\t popseed \\t t \\t compID \\t totalN \\t Nhiv \\t Nprep \\t NtrtHIV\" \" \\t Comp_Status \\t PCA \\t Oral \\t Injectable \\t Aware \\t nidu \\t centrality \\t Density\" \" \\t EffectiveSize\" + header + \" \\n \" ) comp_id = 0 for comp in components : for race in races : race_count [ race ] = 0 assert comp . number_of_nodes () >= 0 tot_agents = ( nhiv ) = ntrthiv = nprep = injectable_prep = oral = aware = pca = nidu = 0 component_status = \"control\" trt_comp = trt_agent = False for agent in comp . nodes (): tot_agents += 1 race_count [ agent . race ] += 1 if agent . hiv : nhiv += 1 if agent . intervention_ever : ntrthiv += 1 if agent . prep : nprep += 1 if agent . prep_type == \"Inj\" : injectable_prep += 1 elif agent . prep_type == \"Oral\" : oral += 1 if agent . pca_suitable and agent . pca : pca += 1 if agent . intervention_ever : # treatment component trt_agent = True if agent . random_trial_enrolled : trt_comp = True if agent . prep_awareness : aware += 1 if agent . drug_type == \"NonInj\" : nidu += 1 comp_centrality = ( sum ( betweenness_centrality ( comp ) . values ()) / comp . number_of_nodes () ) average_size = sum ( effective_size ( comp ) . values ()) / comp . number_of_nodes () comp_density = density ( comp ) if trt_comp : if trt_agent : component_status = \"treatment\" else : component_status = \"treatment_no_eligible\" race_str = \"\" for race in race_list : race_str += \" \\t \" + str ( race_count [ race ]) f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t { comp_id } \\t { tot_agents } \\t \" f \" { nhiv } \\t \" f \" { nprep } \\t { ntrthiv } \\t { component_status } \\t { pca } \\t { oral } \\t { injectable_prep } \" f \" \\t { aware } \\t { nidu } \\t { comp_centrality : .4f } \\t { comp_density : .4f } \" f \" \\t { average_size : .4f }{ race_str } \\n \" ) comp_id += 1 f . close () setup_aggregates ( params , classes ) Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: \"numAgents\" \"inf_HR6m\" \"inf_HRever\" \"inf_newInf\" \"newHR\" \"newHR_HIV\" \"newHR_AIDS\" \"newHR_dx\" \"newHR_ART\" \"newRelease\" \"newReleaseHIV\" \"numHIV\" \"numTested\" \"numAIDS\" \"numART\" \"numHR\" \"newlyTested\" \"deaths\" \"deaths_HIV\" \"incar\" \"incarHIV\" \"numPrEP\" \"newNumPrEP\" \"vaccinated\" \"injectable_prep\" \"oral_prep\" Parameters: Name Type Description Default params ObjMap model parameters required classes List[str] which classes to aggregate by [params.outputs.classes] required Returns: Type Description Dict dictionary of class values to counts Source code in titan/output.py def setup_aggregates ( params : ObjMap , classes : List [ str ]) -> Dict : \"\"\" Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: * \"numAgents\" * \"inf_HR6m\" * \"inf_HRever\" * \"inf_newInf\" * \"newHR\" * \"newHR_HIV\" * \"newHR_AIDS\" * \"newHR_dx\" * \"newHR_ART\" * \"newRelease\" * \"newReleaseHIV\" * \"numHIV\" * \"numTested\" * \"numAIDS\" * \"numART\" * \"numHR\" * \"newlyTested\" * \"deaths\" * \"deaths_HIV\" * \"incar\" * \"incarHIV\" * \"numPrEP\" * \"newNumPrEP\" * \"vaccinated\" * \"injectable_prep\" * \"oral_prep\" args: params: model parameters classes: which classes to aggregate by [params.outputs.classes] returns: dictionary of class values to counts \"\"\" if classes == []: return { \"numAgents\" : 0 , \"inf_HR6m\" : 0 , \"inf_HRever\" : 0 , \"inf_newInf\" : 0 , \"newHR\" : 0 , \"newHR_HIV\" : 0 , \"newHR_AIDS\" : 0 , \"newHR_dx\" : 0 , \"newHR_ART\" : 0 , \"newRelease\" : 0 , \"newReleaseHIV\" : 0 , \"numHIV\" : 0 , \"numDiagnosed\" : 0 , \"numAIDS\" : 0 , \"numART\" : 0 , \"numHR\" : 0 , \"newlyDiagnosed\" : 0 , \"deaths\" : 0 , \"deaths_HIV\" : 0 , \"incar\" : 0 , \"incarHIV\" : 0 , \"numPrEP\" : 0 , \"newNumPrEP\" : 0 , \"vaccinated\" : 0 , \"injectable_prep\" : 0 , \"oral_prep\" : 0 , } stats = {} clss , * rem_clss = classes # head, tail keys = [ k for k in params . classes [ clss ]] for key in keys : stats [ key ] = setup_aggregates ( params , rem_clss ) return stats write_report ( file_name , name_map , run_id , t , runseed , popseed , stats , params , outdir ) Core function for writing reports, writes header if file is new, then data based on the params and name_map Parameters: Name Type Description Default file_name str Name of the file to write, including the extension (e.g. MyReport.txt ) required name_map Dict[str, str] Map from keys in the stats dictionary to column headers in this report required run_id str unique identifier for this model required t int current timestep required runseed int integer used to seed the random number generator for the model required popseed int integer used to seed the random number generator for the population required stats Dict nested dictionary of agent attributes to counts required params ObjMap model parameters required outdir str path of where to save this file required Source code in titan/output.py def write_report ( file_name : str , name_map : Dict [ str , str ], run_id : str , t : int , runseed : int , popseed : int , stats : Dict , params : ObjMap , outdir : str , ): \"\"\" Core function for writing reports, writes header if file is new, then data based on the `params` and `name_map` args: file_name: Name of the file to write, including the extension (e.g. `MyReport.txt`) name_map: Map from keys in the stats dictionary to column headers in this report run_id: unique identifier for this model t: current timestep runseed: integer used to seed the random number generator for the model popseed: integer used to seed the random number generator for the population stats: nested dictionary of agent attributes to counts params: model parameters outdir: path of where to save this file \"\"\" f = open ( os . path . join ( outdir , file_name ), \"a\" ) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] if f . tell () == 0 : f . write ( \"run_id \\t rseed \\t pseed \\t t \\t \" ) # start header # attributes in stats f . write ( \" \\t \" . join ( attrs )) # report specific fields for name in name_map . values (): f . write ( f \" \\t { name } \" ) f . write ( \" \\n \" ) for agg in get_aggregates ( params ): f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t \" ) f . write ( \" \\t \" . join ( agg )) # write attribute values for key , name in name_map . items (): f . write ( f \" \\t { ( get_agg_val ( stats , agg , key )) } \" ) f . write ( \" \\n \" ) f . close ()","title":"Reporting"},{"location":"api/reporting/#tabular-reports","text":"","title":"Tabular Reports"},{"location":"api/reporting/#titan.output.add_agent_to_stats","text":"Update the stats dictionary counts for the key given the agent's attributes Parameters: Name Type Description Default stats Dict[str, Any] a nested dictionary of attributes to counts required attrs List[str] a list of attribute types (e.g. \"race\") required agent Agent the agent whose attribute values will be evaluated required key str the type of count to increment required Source code in titan/output.py def add_agent_to_stats ( stats : Dict [ str , Any ], attrs : List [ str ], agent : Agent , key : str ): \"\"\" Update the stats dictionary counts for the key given the agent's attributes args: stats: a nested dictionary of attributes to counts attrs: a list of attribute types (e.g. \"race\") agent: the agent whose attribute values will be evaluated key: the type of count to increment \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ str ( getattr ( agent , attr ))] stats_item [ key ] += 1","title":"add_agent_to_stats()"},{"location":"api/reporting/#titan.output.basicReport","text":"Standard report writer for basic agent statistics, columns include: Total : number of agents in the population HIV : number of agents with HIV AIDS : number of agents with AIDS Dx : number of agents with HIV who are diagnosed ART : number of agents on HAART nHR : number of agents who are high risk Incid : number of agents who HIV converted this time period HR_6mo : number of agents with HIV converted this time period who are high risk HR_Ev : number of agents with HIV converted this time period who have ever been high risk NewDiag : number of agents with HIV who were diagnosed this time period Deaths : number of agents who died this time period PrEP : number of agents enrolled in PrEP Vaccinated : number of agents who have been vaccinated LAI : number of agents enrolled in PrEP with a type of LAI Oral : number of agents enrolled in PrEP with a type of Oral Source code in titan/output.py def basicReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for basic agent statistics, columns include: * `Total`: number of agents in the population * `HIV`: number of agents with HIV * `AIDS`: number of agents with AIDS * `Dx`: number of agents with HIV who are diagnosed * `ART`: number of agents on HAART * `nHR`: number of agents who are high risk * `Incid`: number of agents who HIV converted this time period * `HR_6mo`: number of agents with HIV converted this time period who are high risk * `HR_Ev`: number of agents with HIV converted this time period who have ever been high risk * `NewDiag`: number of agents with HIV who were diagnosed this time period * `Deaths`: number of agents who died this time period * `PrEP`: number of agents enrolled in PrEP * `Vaccinated`: number of agents who have been vaccinated * `LAI`: number of agents enrolled in PrEP with a type of LAI * `Oral`: number of agents enrolled in PrEP with a type of Oral \"\"\" name_map = { \"numAgents\" : \"Total\" , \"numHIV\" : \"HIV\" , \"numAIDS\" : \"AIDS\" , \"numDiagnosed\" : \"Dx\" , \"numART\" : \"ART\" , \"numHR\" : \"nHR\" , \"inf_newInf\" : \"Incid\" , \"inf_HR6m\" : \"HR_6mo\" , \"inf_HRever\" : \"HR_Ev\" , \"newlyDiagnosed\" : \"NewDx\" , \"deaths\" : \"Deaths\" , \"numPrEP\" : \"PrEP\" , \"vaccinated\" : \"Vaccinated\" , \"injectable_prep\" : \"LAI\" , \"oral_prep\" : \"Oral\" , } write_report ( \"basicReport.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir )","title":"basicReport()"},{"location":"api/reporting/#titan.output.deathReport","text":"Standard report writer for agent deaths, columns include: tot : total number of deaths at this timestep HIV : number of deaths of agents with HIV at this timestep Source code in titan/output.py def deathReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for agent deaths, columns include: * `tot`: total number of deaths at this timestep * `HIV`: number of deaths of agents with HIV at this timestep \"\"\" name_map = { \"deaths\" : \"tot\" , \"deaths_HIV\" : \"HIV\" , } write_report ( \"DeathReport.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir )","title":"deathReport()"},{"location":"api/reporting/#titan.output.get_agg_val","text":"Get the value of a key in stats given the attribute values Parameters: Name Type Description Default stats Dict a nested dictionary of attributes to count required attrs List a list of attribute values to find the count for required key str the type of count to get the value of required Returns: Type Description int the count of key for the given attributes Source code in titan/output.py def get_agg_val ( stats : Dict , attrs : List , key : str ) -> int : \"\"\" Get the value of a key in stats given the attribute values args: stats: a nested dictionary of attributes to count attrs: a list of attribute values to find the count for key: the type of count to get the value of returns: the count of key for the given attributes \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ attr ] return stats_item [ key ]","title":"get_agg_val()"},{"location":"api/reporting/#titan.output.get_aggregates","text":"Get iterator over all attribute combinations for output classes Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description Iterator iterator over attribute combinations Source code in titan/output.py def get_aggregates ( params : ObjMap ) -> Iterator : \"\"\" Get iterator over all attribute combinations for output classes args: params: model parameters returns: iterator over attribute combinations \"\"\" return itertools . product ( * [ list ( k for k in params . classes [ clss ]) for clss in params . outputs . classes ] )","title":"get_aggregates()"},{"location":"api/reporting/#titan.output.get_stats","text":"Get the current statistics for a model based on the population, and tracking agent sets from the model. Parameters: Name Type Description Default all_agents AgentSet all of the agents in the population required new_prep_agents AgentSet agents who are newly on prep this timestep required new_hiv AgentSet agents are newly hiv this timestep required new_hiv_dx AgentSet agents who are newly diagnosed with hiv this timestep required new_high_risk AgentSet agents who are newly high risk this timestep required new_incar_release AgentSet agents are released from incarceration this timestep required deaths List[titan.agent.Agent] agents who died this timestep required params ObjMap model parameters required Returns: Type Description Dict nested dictionary of agent attributes to counts of various items Source code in titan/output.py def get_stats ( all_agents : AgentSet , new_prep_agents : AgentSet , new_hiv : AgentSet , new_hiv_dx : AgentSet , new_high_risk : AgentSet , new_incar_release : AgentSet , deaths : List [ Agent ], params : ObjMap , ) -> Dict : \"\"\" Get the current statistics for a model based on the population, and tracking agent sets from the model. args: all_agents: all of the agents in the population new_prep_agents: agents who are newly on prep this timestep new_hiv: agents are newly hiv this timestep new_hiv_dx: agents who are newly diagnosed with hiv this timestep new_high_risk: agents who are newly high risk this timestep new_incar_release: agents are released from incarceration this timestep deaths: agents who died this timestep params: model parameters returns: nested dictionary of agent attributes to counts of various items \"\"\" stats = setup_aggregates ( params , params . outputs . classes ) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] # attribute version (non-plural) # Incarceration metrics for a in new_incar_release : add_agent_to_stats ( stats , attrs , a , \"newRelease\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"newReleaseHIV\" ) # Newly infected tracker statistics (with HR within 6mo and HR ever bool check) for a in new_hiv : add_agent_to_stats ( stats , attrs , a , \"inf_newInf\" ) if a . high_risk_ever : add_agent_to_stats ( stats , attrs , a , \"inf_HRever\" ) if a . high_risk : add_agent_to_stats ( stats , attrs , a , \"inf_HR6m\" ) for a in all_agents : add_agent_to_stats ( stats , attrs , a , \"numAgents\" ) if a . prep : add_agent_to_stats ( stats , attrs , a , \"numPrEP\" ) if a . prep_type == \"Inj\" : add_agent_to_stats ( stats , attrs , a , \"injectable_prep\" ) elif a . prep_type == \"Oral\" : add_agent_to_stats ( stats , attrs , a , \"oral_prep\" ) if a . incar : add_agent_to_stats ( stats , attrs , a , \"incar\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"incarHIV\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"numHIV\" ) if a . aids : add_agent_to_stats ( stats , attrs , a , \"numAIDS\" ) if a . hiv_dx : add_agent_to_stats ( stats , attrs , a , \"numDiagnosed\" ) if a . haart : add_agent_to_stats ( stats , attrs , a , \"numART\" ) if a . vaccine : add_agent_to_stats ( stats , attrs , a , \"vaccinated\" ) # Newly PrEP tracker statistics for a in new_prep_agents : add_agent_to_stats ( stats , attrs , a , \"newNumPrEP\" ) # Newly diagnosed tracker statistics for a in new_hiv_dx : add_agent_to_stats ( stats , attrs , a , \"newlyDiagnosed\" ) # Newly HR agents for a in new_high_risk : add_agent_to_stats ( stats , attrs , a , \"newHR\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"newHR_HIV\" ) if a . aids : add_agent_to_stats ( stats , attrs , a , \"newHR_AIDS\" ) if a . hiv_dx : add_agent_to_stats ( stats , attrs , a , \"newHR_dx\" ) if a . haart : add_agent_to_stats ( stats , attrs , a , \"newHR_ART\" ) for a in deaths : add_agent_to_stats ( stats , attrs , a , \"deaths\" ) if a . hiv : add_agent_to_stats ( stats , attrs , a , \"deaths_HIV\" ) return stats","title":"get_stats()"},{"location":"api/reporting/#titan.output.incarReport","text":"Standard report writer for agent incarcerations, columns include: tot : total number of incarcerated agents at this timestep HIV : number of incarcerated agents with HIV at this timestep rlsd : number of agents released at this timestep rlsdHIV : number of agents with HIV released at this timestep Source code in titan/output.py def incarReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for agent incarcerations, columns include: * `tot`: total number of incarcerated agents at this timestep * `HIV`: number of incarcerated agents with HIV at this timestep * `rlsd`: number of agents released at this timestep * `rlsdHIV`: number of agents with HIV released at this timestep \"\"\" name_map = { \"incar\" : \"tot\" , \"incarHIV\" : \"HIV\" , \"newRelease\" : \"rlsd\" , \"newReleaseHIV\" : \"rlsdHIV\" , } write_report ( \"IncarReport.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir )","title":"incarReport()"},{"location":"api/reporting/#titan.output.newlyhighriskReport","text":"Standard report writer for newly high risk agents, columns include: newHR : number of agents that became high risk at this timestep newHR_HIV : number of agents with HIV that became high risk at this timestep newHR_AIDS : number of agents with AIDS that became high risk at this timestep newHR_Tested : number of agents with diagnosed HIV that became high risk at this timestep newHR_ART : number of agents on HAART that became high risk at this timestep Source code in titan/output.py def newlyhighriskReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for newly high risk agents, columns include: * `newHR`: number of agents that became high risk at this timestep * `newHR_HIV`: number of agents with HIV that became high risk at this timestep * `newHR_AIDS`: number of agents with AIDS that became high risk at this timestep * `newHR_Tested`: number of agents with diagnosed HIV that became high risk at this timestep * `newHR_ART`: number of agents on HAART that became high risk at this timestep \"\"\" name_map = { \"newHR\" : \"newHR\" , \"newHR_HIV\" : \"newHR_HIV\" , \"newHR_AIDS\" : \"newHR_AIDS\" , \"newHR_dx\" : \"newHR_Diagnosed\" , \"newHR_ART\" : \"newHR_ART\" , } write_report ( \"newlyHR_Report.txt\" , name_map , run_id , t , runseed , popseed , stats , params , outdir , )","title":"newlyhighriskReport()"},{"location":"api/reporting/#titan.output.print_components","text":"Write stats describing the components (sub-graphs) in a graph to file Parameters: Name Type Description Default run_id str unique identifer for this run of the model required t int current timestep required runseed int integer used to seed the model's random number generator required popseed int integer used to seed the population's random number generator required components List a list of graph components required outdir str path where the file should be saved required races list the races in the population required Source code in titan/output.py def print_components ( run_id : str , t : int , runseed : int , popseed : int , components : List , outdir : str , races : list , ): \"\"\" Write stats describing the components (sub-graphs) in a graph to file args: run_id: unique identifer for this run of the model t: current timestep runseed: integer used to seed the model's random number generator popseed: integer used to seed the population's random number generator components: a list of graph components outdir: path where the file should be saved races: the races in the population \"\"\" f = open ( os . path . join ( outdir , f \" { run_id } _componentReport_ALL.txt\" ), \"a\" ) race_count : Dict [ str , int ] = {} race_list = [] header = \"\" for race in races : race_list . append ( race ) header += \" \\t \" + race # if this is a new file, write the header info if f . tell () == 0 : f . write ( \"run_id \\t runseed \\t popseed \\t t \\t compID \\t totalN \\t Nhiv \\t Nprep \\t NtrtHIV\" \" \\t Comp_Status \\t PCA \\t Oral \\t Injectable \\t Aware \\t nidu \\t centrality \\t Density\" \" \\t EffectiveSize\" + header + \" \\n \" ) comp_id = 0 for comp in components : for race in races : race_count [ race ] = 0 assert comp . number_of_nodes () >= 0 tot_agents = ( nhiv ) = ntrthiv = nprep = injectable_prep = oral = aware = pca = nidu = 0 component_status = \"control\" trt_comp = trt_agent = False for agent in comp . nodes (): tot_agents += 1 race_count [ agent . race ] += 1 if agent . hiv : nhiv += 1 if agent . intervention_ever : ntrthiv += 1 if agent . prep : nprep += 1 if agent . prep_type == \"Inj\" : injectable_prep += 1 elif agent . prep_type == \"Oral\" : oral += 1 if agent . pca_suitable and agent . pca : pca += 1 if agent . intervention_ever : # treatment component trt_agent = True if agent . random_trial_enrolled : trt_comp = True if agent . prep_awareness : aware += 1 if agent . drug_type == \"NonInj\" : nidu += 1 comp_centrality = ( sum ( betweenness_centrality ( comp ) . values ()) / comp . number_of_nodes () ) average_size = sum ( effective_size ( comp ) . values ()) / comp . number_of_nodes () comp_density = density ( comp ) if trt_comp : if trt_agent : component_status = \"treatment\" else : component_status = \"treatment_no_eligible\" race_str = \"\" for race in race_list : race_str += \" \\t \" + str ( race_count [ race ]) f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t { comp_id } \\t { tot_agents } \\t \" f \" { nhiv } \\t \" f \" { nprep } \\t { ntrthiv } \\t { component_status } \\t { pca } \\t { oral } \\t { injectable_prep } \" f \" \\t { aware } \\t { nidu } \\t { comp_centrality : .4f } \\t { comp_density : .4f } \" f \" \\t { average_size : .4f }{ race_str } \\n \" ) comp_id += 1 f . close ()","title":"print_components()"},{"location":"api/reporting/#titan.output.setup_aggregates","text":"Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: \"numAgents\" \"inf_HR6m\" \"inf_HRever\" \"inf_newInf\" \"newHR\" \"newHR_HIV\" \"newHR_AIDS\" \"newHR_dx\" \"newHR_ART\" \"newRelease\" \"newReleaseHIV\" \"numHIV\" \"numTested\" \"numAIDS\" \"numART\" \"numHR\" \"newlyTested\" \"deaths\" \"deaths_HIV\" \"incar\" \"incarHIV\" \"numPrEP\" \"newNumPrEP\" \"vaccinated\" \"injectable_prep\" \"oral_prep\" Parameters: Name Type Description Default params ObjMap model parameters required classes List[str] which classes to aggregate by [params.outputs.classes] required Returns: Type Description Dict dictionary of class values to counts Source code in titan/output.py def setup_aggregates ( params : ObjMap , classes : List [ str ]) -> Dict : \"\"\" Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: * \"numAgents\" * \"inf_HR6m\" * \"inf_HRever\" * \"inf_newInf\" * \"newHR\" * \"newHR_HIV\" * \"newHR_AIDS\" * \"newHR_dx\" * \"newHR_ART\" * \"newRelease\" * \"newReleaseHIV\" * \"numHIV\" * \"numTested\" * \"numAIDS\" * \"numART\" * \"numHR\" * \"newlyTested\" * \"deaths\" * \"deaths_HIV\" * \"incar\" * \"incarHIV\" * \"numPrEP\" * \"newNumPrEP\" * \"vaccinated\" * \"injectable_prep\" * \"oral_prep\" args: params: model parameters classes: which classes to aggregate by [params.outputs.classes] returns: dictionary of class values to counts \"\"\" if classes == []: return { \"numAgents\" : 0 , \"inf_HR6m\" : 0 , \"inf_HRever\" : 0 , \"inf_newInf\" : 0 , \"newHR\" : 0 , \"newHR_HIV\" : 0 , \"newHR_AIDS\" : 0 , \"newHR_dx\" : 0 , \"newHR_ART\" : 0 , \"newRelease\" : 0 , \"newReleaseHIV\" : 0 , \"numHIV\" : 0 , \"numDiagnosed\" : 0 , \"numAIDS\" : 0 , \"numART\" : 0 , \"numHR\" : 0 , \"newlyDiagnosed\" : 0 , \"deaths\" : 0 , \"deaths_HIV\" : 0 , \"incar\" : 0 , \"incarHIV\" : 0 , \"numPrEP\" : 0 , \"newNumPrEP\" : 0 , \"vaccinated\" : 0 , \"injectable_prep\" : 0 , \"oral_prep\" : 0 , } stats = {} clss , * rem_clss = classes # head, tail keys = [ k for k in params . classes [ clss ]] for key in keys : stats [ key ] = setup_aggregates ( params , rem_clss ) return stats","title":"setup_aggregates()"},{"location":"api/reporting/#titan.output.write_report","text":"Core function for writing reports, writes header if file is new, then data based on the params and name_map Parameters: Name Type Description Default file_name str Name of the file to write, including the extension (e.g. MyReport.txt ) required name_map Dict[str, str] Map from keys in the stats dictionary to column headers in this report required run_id str unique identifier for this model required t int current timestep required runseed int integer used to seed the random number generator for the model required popseed int integer used to seed the random number generator for the population required stats Dict nested dictionary of agent attributes to counts required params ObjMap model parameters required outdir str path of where to save this file required Source code in titan/output.py def write_report ( file_name : str , name_map : Dict [ str , str ], run_id : str , t : int , runseed : int , popseed : int , stats : Dict , params : ObjMap , outdir : str , ): \"\"\" Core function for writing reports, writes header if file is new, then data based on the `params` and `name_map` args: file_name: Name of the file to write, including the extension (e.g. `MyReport.txt`) name_map: Map from keys in the stats dictionary to column headers in this report run_id: unique identifier for this model t: current timestep runseed: integer used to seed the random number generator for the model popseed: integer used to seed the random number generator for the population stats: nested dictionary of agent attributes to counts params: model parameters outdir: path of where to save this file \"\"\" f = open ( os . path . join ( outdir , file_name ), \"a\" ) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] if f . tell () == 0 : f . write ( \"run_id \\t rseed \\t pseed \\t t \\t \" ) # start header # attributes in stats f . write ( \" \\t \" . join ( attrs )) # report specific fields for name in name_map . values (): f . write ( f \" \\t { name } \" ) f . write ( \" \\n \" ) for agg in get_aggregates ( params ): f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t \" ) f . write ( \" \\t \" . join ( agg )) # write attribute values for key , name in name_map . items (): f . write ( f \" \\t { ( get_agg_val ( stats , agg , key )) } \" ) f . write ( \" \\n \" ) f . close ()","title":"write_report()"},{"location":"api/utilities/","text":"General Utilities binom_0 ( n , p ) Mirrors scipy binom.pmf as used in code Source code in titan/utils.py def binom_0 ( n : int , p : float ): \"\"\" Mirrors scipy binom.pmf as used in code \"\"\" return ( 1 - p ) ** n get_check_rand_int ( seed ) Check the value passed of a seed, make sure it's an int, if 0, get a random seed Parameters: Name Type Description Default seed int integer to check or replace with a seed required Returns: Type Description int validated seed Source code in titan/utils.py def get_check_rand_int ( seed : int ) -> int : \"\"\" Check the value passed of a seed, make sure it's an int, if 0, get a random seed args: seed: integer to check or replace with a seed returns: validated seed \"\"\" if type ( seed ) is not int or seed < 0 : raise ValueError ( \"Random seed must be positive integer\" ) elif seed == 0 : return random . randint ( 1 , 1000000 ) else : return seed get_param_from_path ( params , param_path , delimiter ) Given a params object and a delimited path, get the leaf of the params tree and the last key to access it Source code in titan/utils.py def get_param_from_path ( params , param_path , delimiter ): \"\"\" Given a params object and a delimited path, get the leaf of the params tree and the last key to access it \"\"\" path = param_path . split ( delimiter ) path_params = params for p in path [: - 1 ]: path_params = path_params [ p ] return path_params , path [ - 1 ] memo ( f ) Decorator to memoize a function (caches results given args, only use if deterministic) Source code in titan/utils.py def memo ( f ): \"\"\" Decorator to memoize a function (caches results given args, only use if deterministic) \"\"\" cache = {} @wraps ( f ) def wrap ( * arg ): if arg not in cache : cache [ arg ] = f ( * arg ) return cache [ arg ] return wrap override_param ( params , param_path , value , delimiter = '|' ) Given the params and a parameter path in the format prep|target, change the current value to new value Source code in titan/utils.py def override_param ( params , param_path , value , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|target, change the current value to new value \"\"\" override_item , last_key = get_param_from_path ( params , param_path , delimiter ) old_val = override_item [ last_key ] print ( f \"overriding - { param_path } : { old_val } => { value } \" ) override_item [ last_key ] = value poisson ( mu , np_rand ) Mirrors scipy poisson.rvs function as used in code Source code in titan/utils.py def poisson ( mu : float , np_rand ): \"\"\" Mirrors scipy poisson.rvs function as used in code \"\"\" return np_rand . poisson ( mu ) safe_dist ( dist_info , rand_gen ) Draw a value from a distribution as defined in dist_info . Parameters: Name Type Description Default dist_info ObjMap a definition of a distribution to use [params.classes.distributions] required rand_gen random number generator required Returns: Type Description Union[int, float] a value drawn from the distribution Source code in titan/utils.py def safe_dist ( dist_info : ObjMap , rand_gen ) -> Union [ int , float ]: \"\"\" Draw a value from a distribution as defined in `dist_info`. args: dist_info: a definition of a distribution to use [params.classes.distributions] rand_gen: random number generator returns: a value drawn from the distribution \"\"\" # gather arguments args = [] for i in range ( 1 , len ( dist_info . vars ) + 1 ): val = dist_info . vars [ i ] . value type_caster = eval ( dist_info . vars [ i ] . value_type ) val = type_caster ( val ) args . append ( val ) dist_type = dist_info . dist_type try : # does dist exist in numpy? dist = getattr ( rand_gen , dist_type ) value = dist ( * args ) except AttributeError : try : # does dist exist in distributions.py dist = getattr ( distributions , dist_type ) value = dist ( rand_gen , * args ) except AttributeError : raise AttributeError ( f \"Distribution type { dist_type } not found!\" ) if hasattr ( value , \"__iter__\" ): # check if value is any type of sequence return value [ 0 ] else : return value safe_divide ( numerator , denominator ) Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. Parameters: Name Type Description Default numerator int number being divided required denominator int number doing the dividing required Returns: Type Description float resulting number Source code in titan/utils.py def safe_divide ( numerator : int , denominator : int ) -> float : \"\"\" Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. args: numerator: number being divided denominator: number doing the dividing returns: resulting number \"\"\" if denominator == 0 : return 0.0 else : return 1.0 * numerator / denominator safe_random_choice ( seq , rand_gen , weights = None ) Return None or a random choice from a collection of items Parameters: Name Type Description Default seq Collection[~T] collection to select a random item from required rand_gen random number generator required weights an optional collection of weights to use instead of a uniform distribution None Returns: Type Description Optional[~T] an item, or None if the collection is empty Source code in titan/utils.py def safe_random_choice ( seq : Collection [ T ], rand_gen , weights = None ) -> Optional [ T ]: \"\"\" Return None or a random choice from a collection of items args: seq: collection to select a random item from rand_gen: random number generator weights: an optional collection of weights to use instead of a uniform distribution returns: an item, or `None` if the collection is empty \"\"\" if not seq : return None if isinstance ( seq , set ): seq = tuple ( seq ) choices = rand_gen . choices ( seq , weights = weights ) return choices [ 0 ] safe_shuffle ( seq , rand_gen ) Return None or a shuffled sequence Parameters: Name Type Description Default seq Collection[~T] collection to shuffle required rand_gen random number generator required Returns: Type Description Optional[Collection[~T]] shuffled sequence, or None if empty Source code in titan/utils.py def safe_shuffle ( seq : Collection [ T ], rand_gen ) -> Optional [ Collection [ T ]]: \"\"\" Return None or a shuffled sequence args: seq: collection to shuffle rand_gen: random number generator returns: shuffled sequence, or `None` if empty \"\"\" if seq : if isinstance ( seq , set ): rand_gen . shuffle ( list ( seq )) return seq else : rand_gen . shuffle ( seq ) return seq else : return None scale_param ( params , param_path , scalar , delimiter = '|' ) Given the params and a parameter path in the format prep|target, scale the current value by the scalar Source code in titan/utils.py def scale_param ( params , param_path , scalar , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|target, scale the current value by the scalar \"\"\" scaling_item , last_key = get_param_from_path ( params , param_path , delimiter ) old_val = scaling_item [ last_key ] print ( f \"scaling - { param_path } : { old_val } => { old_val * scalar } \" ) scaling_item [ last_key ] = old_val * scalar Probability Distributions This file contains distributions that don't exist in numpy. pert ( np_random , low , peak , high , temperature ) A pert distribution, inspired by tensorflow arguments must be so that: low < peak < high temperature > 0 The support is [low, high] . The peak must fit in that interval: low < peak < high . The temperature is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. Parameters: Name Type Description Default np_random random number generator (used to get beta) required low distribution low value required peak modal point in distribution required high distribution high value required temperature scaling factor required Source code in titan/distributions.py def pert ( np_random , low , peak , high , temperature ): \"\"\" A pert distribution, inspired by [tensorflow](https://github.com/tensorflow/probability/blob/c833ee5cd9f60f3257366b25447b9e50210b0590/tensorflow_probability/python/distributions/pert.py#L137) arguments must be so that: * low < peak < high * temperature > 0 The support is `[low, high]`. The `peak` must fit in that interval: `low < peak < high`. The `temperature` is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. args: np_random: random number generator (used to get beta) low: distribution low value peak: modal point in distribution high: distribution high value temperature: scaling factor \"\"\" assert low < peak < high assert temperature > 0 scale = high - low alpha = 1.0 + temperature * ( peak - low ) / scale beta = 1.0 + temperature * ( high - peak ) / scale return low + scale * np_random . beta ( alpha , beta ) set_value ( np_random , value ) A distribution that always returns the value passed Parameters: Name Type Description Default np_random random number generator (to conform to distribution interface) required value value to return required Source code in titan/distributions.py def set_value ( np_random , value ): \"\"\" A distribution that always returns the value passed args: np_random: random number generator (to conform to distribution interface) value: value to return \"\"\" return value Params ObjMap A dictionary-like class which allows accessing members either using standard dictionary notation or dots. Note the hash function is hard-coded - beware. __hash__ ( self ) special Return hash(self). Source code in titan/parse_params.py def __hash__ ( self ): return 1234567890 build_yaml ( path ) Read in a yaml or folder of yamls into a dictionary. Source code in titan/parse_params.py def build_yaml ( path ): \"\"\" Read in a yaml or folder of yamls into a dictionary. \"\"\" yml = {} if os . path . isdir ( path ): for file in os . listdir ( path ): if \".yml\" in file or \".yaml\" in file : with open ( os . path . join ( path , file )) as f : this_yml = yaml . safe_load ( f ) yml . update ( this_yml ) else : with open ( path ) as f : assert \".yml\" in path or \".yaml\" in path this_yml = yaml . safe_load ( f ) yml . update ( this_yml ) return yml check_item ( val , d , key_path , keys = None , pops = None ) Checks if an item meets the requirements of the field's definition. Source code in titan/parse_params.py def check_item ( val , d , key_path , keys = None , pops = None ): \"\"\" Checks if an item meets the requirements of the field's definition. \"\"\" if \"min\" in d : assert val >= d [ \"min\" ], f \" { val } must be greater than { d [ 'min' ] } [ { key_path } ]\" if \"max\" in d : assert val <= d [ \"max\" ], f \" { val } must be less than { d [ 'max' ] } [ { key_path } ]\" if d [ \"type\" ] == \"int\" : assert isinstance ( val , int ), f \" { val } must be an integer [ { key_path } ]\" if d [ \"type\" ] == \"float\" : if isinstance ( val , int ): val = float ( val ) assert isinstance ( val , float ), f \" { val } must be a float [ { key_path } ]\" if d [ \"type\" ] == \"boolean\" : assert isinstance ( val , bool ), f \" { val } must be a bool [ { key_path } ]\" if d [ \"type\" ] == \"enum\" : if \"values\" in d : values = d [ \"values\" ] elif \"class\" in d : values = pops [ d [ \"class\" ]] assert val in values , f \" { val } not in { values } [ { key_path } ]\" if d [ \"type\" ] == \"array\" : if \"values\" in d : values = d [ \"values\" ] elif \"class\" in d : values = pops [ d [ \"class\" ]] assert isinstance ( val , list ), f \" { val } must be an array [ { key_path } ]\" assert all ( x in values for x in val ), f \" { val } not in { values } [ { key_path } ]\" if d [ \"type\" ] == \"keys\" : assert isinstance ( val , list ), f \" { val } must be an array of keys [ { key_path } ]\" assert all ( x in keys for x in val ), f \" { keys } not in { keys } [ { key_path } ]\" return val check_params ( params ) Consistency checks for param populations Source code in titan/parse_params.py def check_params ( params ): \"\"\" Consistency checks for param populations \"\"\" race_pop = 0 for race in params . classes . races : r_dems = params . demographics [ race ] race_pop += r_dems . ppl sex_type_pop = 0 for st , st_dems in r_dems . items (): if st in list ( params . classes . sex_types . keys ()): sex_type_pop += st_dems . ppl assert math . isclose ( sex_type_pop , 1 , abs_tol = 0.001 ), f \"ppl of { race } 's sex_types must add to 1. Currently adding to { sex_type_pop } \" assert math . isclose ( race_pop , 1 , abs_tol = 0.001 ), f \"ppl of races must add to 1\" create_params ( setting_path , param_path , outdir , use_base = True , error_on_unused = False ) Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. Parameters: Name Type Description Default setting_path Optional[str] path to a settings file or directory or None required param_path str path to parameter file or directory required outdir str path to directory where computed params will be saved required use_base bool whether to use the base setting True error_on_unused bool throw a hard error if there are unused parameters, otherwise warnings are only printed False Returns: Type Description ObjMap computed/validated model paramters with defaults filled in where needed Source code in titan/parse_params.py def create_params ( setting_path : Optional [ str ], param_path : str , outdir : str , use_base : bool = True , error_on_unused : bool = False , ) -> ObjMap : \"\"\" Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. args: setting_path: path to a settings file or directory or `None` param_path: path to parameter file or directory outdir: path to directory where computed params will be saved use_base: whether to use the base setting error_on_unused: throw a hard error if there are unused parameters, otherwise warnings are only printed returns: computed/validated model paramters with defaults filled in where needed \"\"\" filename = getsourcefile ( warn_unused_params ) if filename is not None : parent = Path ( filename ) . resolve () . parent else : raise Exception ( \"can't find where I am in the code?\" ) root = os . path . join ( parent , \"params\" ) defs = build_yaml ( root ) params = build_yaml ( param_path ) # merge setting and params if setting_path is not None : setting = build_yaml ( setting_path ) params = merge ( setting , params ) if use_base : base_dir = os . path . join ( parent , \"..\" , \"settings\" , \"base\" ) base = build_yaml ( base_dir ) params = merge ( base , params ) pops = parse_classes ( defs , params ) parsed = parse_params ( defs , params , \"\" , pops ) with open ( os . path . join ( outdir , \"params.yml\" ), \"w\" ) as f : yaml . dump ( parsed , f ) parsed = ObjMap ( parsed ) check_params ( parsed ) print ( \" \\n Checking for unused parameters...\" ) num_unused = warn_unused_params ( parsed , params , base , \"\" ) print ( f \" { num_unused } unused parameters found\" ) if error_on_unused : assert ( num_unused == 0 ), \"There are unused parameters passed to the model (see print statements)\" return parsed get_bins ( key , d , key_path , param , pops ) Get and validate a type == bin definition Source code in titan/parse_params.py def get_bins ( key , d , key_path , param , pops ): \"\"\" Get and validate a type == bin definition \"\"\" if key not in param : return d [ \"default\" ] bins = merge ( d [ \"default\" ], param [ key ]) parsed_bins = {} for bin , val in bins . items (): try : int ( bin ) except ValueError : print ( \"Bins must be integers\" ) raise for field , defn in d [ \"fields\" ] . items (): assert field in val , f \" { field } must be in { val } [ { key_path } . { bin } ]\" val [ field ] = check_item ( val [ field ], defn , f \" { key_path } . { bin } . { field } \" , pops = pops ) parsed_bins [ int ( bin )] = val return parsed_bins get_defn ( key , d , key_path , param , pops ) Get and validate a type == definition definition Source code in titan/parse_params.py def get_defn ( key , d , key_path , param , pops ): \"\"\" Get and validate a type == definition definition \"\"\" if key not in param or param [ key ] == {}: parsed = d [ \"default\" ] else : parsed = param [ key ] # check definitions for k , val in parsed . items (): for field , defn in d [ \"fields\" ] . items (): if field not in val : if \"default\" in defn : val [ field ] = defn [ \"default\" ] else : assert field in val , f \" { field } must be in { val } [ { key_path } ]\" val [ field ] = check_item ( val [ field ], defn , f \" { key_path } . { field } \" , keys = parsed . keys (), pops = pops ) return parsed get_item ( key , d , key_path , param , pops = None ) Get and check item from the params, falling back on the definitions default. Source code in titan/parse_params.py def get_item ( key , d , key_path , param , pops = None ): \"\"\" Get and check item from the params, falling back on the definitions default. \"\"\" if key in param : val = param [ key ] return check_item ( val , d , f \" { key_path } \" , pops = pops ) else : return d [ \"default\" ] merge ( d1 , d2 ) return new merged dict of dicts Source code in titan/parse_params.py def merge ( d1 , d2 ): \"\"\"return new merged dict of dicts\"\"\" if isinstance ( d1 , collections . abc . Mapping ) and isinstance ( d2 , collections . abc . Mapping ): for k , v in d1 . items (): if k in d2 : d2 [ k ] = merge ( v , d2 [ k ]) d3 = d1 . copy () d3 . update ( d2 ) return d3 else : return d2 parse_classes ( defs , params ) Parse the classes definition first as it is needed in parsing the full params. Source code in titan/parse_params.py def parse_classes ( defs , params ): \"\"\" Parse the classes definition first as it is needed in parsing the full params. \"\"\" # add sex types to populations if \"sex_types\" in params . get ( \"classes\" , []): params [ \"classes\" ][ \"populations\" ] = params [ \"classes\" ] . get ( \"populations\" , defs [ \"classes\" ][ \"populations\" ][ \"default\" ] ) + list ( params [ \"classes\" ][ \"sex_types\" ] . keys ()) sex_type_keys = list ( defs [ \"classes\" ][ \"sex_types\" ][ \"default\" ] . keys ()) defs [ \"classes\" ][ \"populations\" ][ \"default\" ] += sex_type_keys defs [ \"classes\" ][ \"populations\" ][ \"values\" ] += sex_type_keys return parse_params ( defs [ \"classes\" ], params . get ( \"classes\" , {}), \"\" , {}) parse_params ( defs , params , key_path , pops ) Recursively parse the passed params, using the definitions to validate and provide defaults. Source code in titan/parse_params.py def parse_params ( defs , params , key_path , pops ): \"\"\" Recursively parse the passed params, using the definitions to validate and provide defaults. \"\"\" parsed = {} # params is a scalar, return it if not isinstance ( params , dict ): return params # handles case of bin as direct default item if \"default\" in defs : if defs [ \"type\" ] == \"bin\" : return get_bins ( \"dummy\" , defs , key_path , { \"dummy\" : params }, pops ) elif defs [ \"type\" ] == \"definition\" : return get_defn ( \"dummy\" , defs , key_path , { \"dummy\" : params }, pops ) for k , v in defs . items (): # assumes all v are dicts, as otherwise it would have returned if \"default\" in v : if v [ \"type\" ] == \"sub-dict\" : parsed [ k ] = {} field = v [ \"keys\" ][ 0 ] for val in pops [ field ]: parsed [ k ][ val ] = parse_params ( v [ \"default\" ], params . get ( k , {}) . get ( val , {}), f \" { key_path } . { k } . { val } \" , pops , ) if len ( v [ \"keys\" ]) > 1 : field2 = v [ \"keys\" ][ 1 ] for val2 in pops [ field2 ]: parsed [ k ][ val ][ val2 ] = parse_params ( v [ \"default\" ], params . get ( k , {}) . get ( val , {}) . get ( val2 , {}), f \" { key_path } . { k } . { val } . { val2 } \" , pops , ) elif v [ \"type\" ] == \"bin\" : parsed [ k ] = get_bins ( k , v , f \" { key_path } . { k } \" , params , pops ) elif v [ \"type\" ] == \"definition\" : parsed [ k ] = get_defn ( k , v , f \" { key_path } . { k } \" , params , pops ) else : parsed [ k ] = get_item ( k , v , f \" { key_path } . { k } \" , params , pops ) else : parsed [ k ] = parse_params ( v , params . get ( k , {}), f \" { key_path } . { k } \" , pops ) return parsed warn_unused_params ( parsed , params , base , key_path ) Compare the original params to what was parsed and print warnings for any original params that are unused in the final parsed parasms. This excludes unused params from base as those are unavoidable. Source code in titan/parse_params.py def warn_unused_params ( parsed , params , base , key_path ): \"\"\" Compare the original params to what was parsed and print warnings for any original params that are unused in the final parsed parasms. This excludes unused params from base as those are unavoidable. \"\"\" # both values, return count = 0 if not isinstance ( parsed , dict ) and not isinstance ( params , dict ): return count # params has keys, parsed doesn't elif not isinstance ( parsed , dict ): print ( f \"[ { key_path } ] has unused params: { params } \" ) count += 1 return count # parsed has keys, params doesn't elif not isinstance ( params , dict ): print ( f \"[ { key_path } ] has sub-keys, got unused params: { params } \" ) count += 1 return count for k , v in params . items (): if k in parsed : count += warn_unused_params ( parsed [ k ], params [ k ], base . get ( k , {}), f \" { key_path } . { k } \" ) elif k not in base : print ( f \"[ { key_path } . { k } ] is unused\" ) count += 1 return count Partnering get_mean_rel_duration ( params ) Find the average partnership duration by bond type Source code in titan/partnering.py def get_mean_rel_duration ( params : ObjMap ): \"\"\" Find the average partnership duration by bond type \"\"\" mean_rel_duration : Dict [ str , int ] = {} for bond in params . partnership . duration : if params . partnership . duration [ bond ] . type == \"bins\" : weights = [] vals = [] dur_bins = params . partnership . duration [ bond ] . bins for bins in dur_bins : if bins > 1 : weights . append ( dur_bins [ bins ] . prob - dur_bins [ bins - 1 ] . prob ) else : weights . append ( dur_bins [ bins ] . prob ) vals . append ( np . average ([ dur_bins [ bins ] . min , dur_bins [ bins ] . max ])) mean_rel_duration [ bond ] = np . average ( vals , weights = weights ) else : mean_rel_duration [ bond ] = params . partnership . duration [ bond ] . distribution . mean return mean_rel_duration get_partnership_duration ( params , rand_gen , bond_type ) Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] Parameters: Name Type Description Default params ObjMap model parameters required rand_gen random number generator required bond_type type of bond for the relationship whose duration is being determined required Returns: Type Description int number of time steps the partnership should endure Source code in titan/partnering.py def get_partnership_duration ( params : ObjMap , rand_gen , bond_type ) -> int : \"\"\" Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] args: params: model parameters rand_gen: random number generator bond_type: type of bond for the relationship whose duration is being determined returns: number of time steps the partnership should endure \"\"\" if params . partnership . duration [ bond_type ] . type == \"bins\" : dur_info = params . partnership . duration [ bond_type ] . bins diceroll = rand_gen . random () dur_bin = dur_info [ 5 ] for i in range ( 1 , 5 ): if diceroll < dur_info [ i ] . prob : dur_bin = dur_info [ i ] break duration = rand_gen . randint ( dur_bin . min , dur_bin . max ) else : dist = params . partnership . duration [ bond_type ] . distribution duration = utils . safe_dist ( dist , rand_gen ) return duration select_partner ( agent , partnerable_agents , sex_partners , pwid_agents , params , rand_gen , bond_type ) Get a partner for the agent. Parameters: Name Type Description Default agent Agent agent in need of a partner required partnerable_agents Set[titan.agent.Agent] agents that can be selected as a partner required sex_partners Dict mapping from sex_type to agents in the population that can sleep with that sex_type required pwid_agents AgentSet agents with drug_type===\"Inj\" required params ObjMap model parameters required rand_gen random number generator required bond_type type of relationship that is being formed with the partner required Returns: Type Description Optional[titan.agent.Agent] new partner or None Source code in titan/partnering.py def select_partner ( agent : Agent , partnerable_agents : Set [ Agent ], sex_partners : Dict , pwid_agents : AgentSet , params : ObjMap , rand_gen , bond_type , ) -> Optional [ Agent ]: \"\"\" Get a partner for the agent. args: agent : agent in need of a partner partnerable_agents: agents that can be selected as a partner sex_partners: mapping from sex_type to agents in the population that can sleep with that sex_type pwid_agents: agents with `drug_type===\"Inj\"` params: model parameters rand_gen: random number generator bond_type: type of relationship that is being formed with the partner returns: new partner or `None` \"\"\" def assort ( eligible_partners , assort_params ): partner_types = list ( assort_params . partner_values . keys ()) partner_weights = [ assort_params . partner_values [ p ] for p in partner_types ] partner_type = utils . safe_random_choice ( partner_types , rand_gen , weights = partner_weights ) if partner_type == \"__other__\" : # remove all the specified (not selected) values and remove those # partners from the eligible set for p in partner_types : if p != \"__other__\" : eligible_partners = { partner for partner in eligible_partners if str ( getattr ( partner , assort_params . attribute )) != p } else : eligible_partners = { partner for partner in eligible_partners if str ( getattr ( partner , assort_params . attribute )) == partner_type } return eligible_partners eligible = copy ( partnerable_agents ) eligible -= agent . get_partners () eligible -= { agent } acts_allowed = params . classes . bond_types [ bond_type ] . acts_allowed if \"injection\" in acts_allowed : eligible &= pwid_agents . members if \"sex\" in acts_allowed : eligible &= sex_partners [ agent . sex_type ] # short circuit to avoid attempting to assort with no eligible partners if not eligible : return None if params . features . assort_mix : for assort_def in params . assort_mix . values (): if getattr ( agent , assort_def . attribute ) == assort_def . agent_value : eligible = assort ( eligible , assort_def ) random_partner = utils . safe_random_choice ( eligible , rand_gen ) return random_partner sex_possible ( agent_sex_type , partner_sex_type , sex_types ) Determine if sex is possible. Parameters: Name Type Description Default agent_sex_type str name of agent's sex type required partner_sex_type str name of partner's sex type required Returns: Type Description bool whether sex is possible between agents of these sex types Source code in titan/partnering.py @utils . memo def sex_possible ( agent_sex_type : str , partner_sex_type : str , sex_types : ObjMap ) -> bool : \"\"\" Determine if sex is possible. args: agent_sex_type: name of agent's sex type partner_sex_type: name of partner's sex type returns: whether sex is possible between agents of these sex types \"\"\" # Check input if agent_sex_type not in sex_types : raise ValueError ( f \"Invalid agent_sex_type! { agent_sex_type } \" ) if partner_sex_type not in sex_types : raise ValueError ( f \"Invalid partner_sex_type! { partner_sex_type } \" ) agent_match = agent_sex_type in sex_types [ partner_sex_type ] . sleeps_with partner_match = partner_sex_type in sex_types [ agent_sex_type ] . sleeps_with return agent_match and partner_match Complex Probabilities adherence_prob ( adherence ) Mapping from HAART adherence levels to probabilities. Parameters: Name Type Description Default adherence int HAART adherence level required Returns: Type Description float probability of agent transitioning from HIV+ to AIDS Source code in titan/probabilities.py @utils . memo def adherence_prob ( adherence : int ) -> float : \"\"\" Mapping from HAART adherence levels to probabilities. args: adherence: HAART adherence level returns: probability of agent transitioning from HIV+ to AIDS \"\"\" if adherence == 1 : return 0.0051 elif adherence == 2 : return 0.0039 elif adherence == 3 : return 0.0032 elif adherence == 4 : return 0.0025 elif adherence == 5 : return 0.0008 else : return 0.0051 get_death_rate ( hiv , aids , drug_type , haart_adh , race , location , steps_per_year ) Find the death rate of an agent given a set of attributes. Parameters: Name Type Description Default hiv bool whether the agent is HIV+ required aids bool whether the agent has AIDS required drug_type str whether the PWID base death rate should be used or the base one required haart_adh int level of HAART adherence required race str the race of the agent required location Location agent's location required steps_per_year int the number of model steps in a year required Returns: Type Description float the probability of an agent with these characteristics dying in a given time step Source code in titan/probabilities.py @utils . memo def get_death_rate ( hiv : bool , aids : bool , drug_type : str , haart_adh : int , race : str , location : Location , steps_per_year : int , ) -> float : \"\"\" Find the death rate of an agent given a set of attributes. args: hiv: whether the agent is HIV+ aids: whether the agent has AIDS drug_type: whether the PWID base death rate should be used or the base one haart_adh: level of HAART adherence race: the race of the agent location: agent's location steps_per_year: the number of model steps in a year returns: the probability of an agent with these characteristics dying in a given time step \"\"\" param = location . params . demographics if drug_type == \"Inj\" : death_param = param [ race ] . PWID . death_rate else : death_param = param [ race ] . death_rate p = death_param . base if aids : p *= death_param . aids elif hiv : if haart_adh == 5 : p *= death_param . haart_adherent else : p *= death_param . hiv # putting it into per 1 person-month from per 1000 person years return p / ( steps_per_year * 1000.0 )","title":"Utility Functions"},{"location":"api/utilities/#general-utilities","text":"","title":"General Utilities"},{"location":"api/utilities/#titan.utils.binom_0","text":"Mirrors scipy binom.pmf as used in code Source code in titan/utils.py def binom_0 ( n : int , p : float ): \"\"\" Mirrors scipy binom.pmf as used in code \"\"\" return ( 1 - p ) ** n","title":"binom_0()"},{"location":"api/utilities/#titan.utils.get_check_rand_int","text":"Check the value passed of a seed, make sure it's an int, if 0, get a random seed Parameters: Name Type Description Default seed int integer to check or replace with a seed required Returns: Type Description int validated seed Source code in titan/utils.py def get_check_rand_int ( seed : int ) -> int : \"\"\" Check the value passed of a seed, make sure it's an int, if 0, get a random seed args: seed: integer to check or replace with a seed returns: validated seed \"\"\" if type ( seed ) is not int or seed < 0 : raise ValueError ( \"Random seed must be positive integer\" ) elif seed == 0 : return random . randint ( 1 , 1000000 ) else : return seed","title":"get_check_rand_int()"},{"location":"api/utilities/#titan.utils.get_param_from_path","text":"Given a params object and a delimited path, get the leaf of the params tree and the last key to access it Source code in titan/utils.py def get_param_from_path ( params , param_path , delimiter ): \"\"\" Given a params object and a delimited path, get the leaf of the params tree and the last key to access it \"\"\" path = param_path . split ( delimiter ) path_params = params for p in path [: - 1 ]: path_params = path_params [ p ] return path_params , path [ - 1 ]","title":"get_param_from_path()"},{"location":"api/utilities/#titan.utils.memo","text":"Decorator to memoize a function (caches results given args, only use if deterministic) Source code in titan/utils.py def memo ( f ): \"\"\" Decorator to memoize a function (caches results given args, only use if deterministic) \"\"\" cache = {} @wraps ( f ) def wrap ( * arg ): if arg not in cache : cache [ arg ] = f ( * arg ) return cache [ arg ] return wrap","title":"memo()"},{"location":"api/utilities/#titan.utils.override_param","text":"Given the params and a parameter path in the format prep|target, change the current value to new value Source code in titan/utils.py def override_param ( params , param_path , value , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|target, change the current value to new value \"\"\" override_item , last_key = get_param_from_path ( params , param_path , delimiter ) old_val = override_item [ last_key ] print ( f \"overriding - { param_path } : { old_val } => { value } \" ) override_item [ last_key ] = value","title":"override_param()"},{"location":"api/utilities/#titan.utils.poisson","text":"Mirrors scipy poisson.rvs function as used in code Source code in titan/utils.py def poisson ( mu : float , np_rand ): \"\"\" Mirrors scipy poisson.rvs function as used in code \"\"\" return np_rand . poisson ( mu )","title":"poisson()"},{"location":"api/utilities/#titan.utils.safe_dist","text":"Draw a value from a distribution as defined in dist_info . Parameters: Name Type Description Default dist_info ObjMap a definition of a distribution to use [params.classes.distributions] required rand_gen random number generator required Returns: Type Description Union[int, float] a value drawn from the distribution Source code in titan/utils.py def safe_dist ( dist_info : ObjMap , rand_gen ) -> Union [ int , float ]: \"\"\" Draw a value from a distribution as defined in `dist_info`. args: dist_info: a definition of a distribution to use [params.classes.distributions] rand_gen: random number generator returns: a value drawn from the distribution \"\"\" # gather arguments args = [] for i in range ( 1 , len ( dist_info . vars ) + 1 ): val = dist_info . vars [ i ] . value type_caster = eval ( dist_info . vars [ i ] . value_type ) val = type_caster ( val ) args . append ( val ) dist_type = dist_info . dist_type try : # does dist exist in numpy? dist = getattr ( rand_gen , dist_type ) value = dist ( * args ) except AttributeError : try : # does dist exist in distributions.py dist = getattr ( distributions , dist_type ) value = dist ( rand_gen , * args ) except AttributeError : raise AttributeError ( f \"Distribution type { dist_type } not found!\" ) if hasattr ( value , \"__iter__\" ): # check if value is any type of sequence return value [ 0 ] else : return value","title":"safe_dist()"},{"location":"api/utilities/#titan.utils.safe_divide","text":"Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. Parameters: Name Type Description Default numerator int number being divided required denominator int number doing the dividing required Returns: Type Description float resulting number Source code in titan/utils.py def safe_divide ( numerator : int , denominator : int ) -> float : \"\"\" Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. args: numerator: number being divided denominator: number doing the dividing returns: resulting number \"\"\" if denominator == 0 : return 0.0 else : return 1.0 * numerator / denominator","title":"safe_divide()"},{"location":"api/utilities/#titan.utils.safe_random_choice","text":"Return None or a random choice from a collection of items Parameters: Name Type Description Default seq Collection[~T] collection to select a random item from required rand_gen random number generator required weights an optional collection of weights to use instead of a uniform distribution None Returns: Type Description Optional[~T] an item, or None if the collection is empty Source code in titan/utils.py def safe_random_choice ( seq : Collection [ T ], rand_gen , weights = None ) -> Optional [ T ]: \"\"\" Return None or a random choice from a collection of items args: seq: collection to select a random item from rand_gen: random number generator weights: an optional collection of weights to use instead of a uniform distribution returns: an item, or `None` if the collection is empty \"\"\" if not seq : return None if isinstance ( seq , set ): seq = tuple ( seq ) choices = rand_gen . choices ( seq , weights = weights ) return choices [ 0 ]","title":"safe_random_choice()"},{"location":"api/utilities/#titan.utils.safe_shuffle","text":"Return None or a shuffled sequence Parameters: Name Type Description Default seq Collection[~T] collection to shuffle required rand_gen random number generator required Returns: Type Description Optional[Collection[~T]] shuffled sequence, or None if empty Source code in titan/utils.py def safe_shuffle ( seq : Collection [ T ], rand_gen ) -> Optional [ Collection [ T ]]: \"\"\" Return None or a shuffled sequence args: seq: collection to shuffle rand_gen: random number generator returns: shuffled sequence, or `None` if empty \"\"\" if seq : if isinstance ( seq , set ): rand_gen . shuffle ( list ( seq )) return seq else : rand_gen . shuffle ( seq ) return seq else : return None","title":"safe_shuffle()"},{"location":"api/utilities/#titan.utils.scale_param","text":"Given the params and a parameter path in the format prep|target, scale the current value by the scalar Source code in titan/utils.py def scale_param ( params , param_path , scalar , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|target, scale the current value by the scalar \"\"\" scaling_item , last_key = get_param_from_path ( params , param_path , delimiter ) old_val = scaling_item [ last_key ] print ( f \"scaling - { param_path } : { old_val } => { old_val * scalar } \" ) scaling_item [ last_key ] = old_val * scalar","title":"scale_param()"},{"location":"api/utilities/#probability-distributions","text":"This file contains distributions that don't exist in numpy.","title":"Probability Distributions"},{"location":"api/utilities/#titan.distributions.pert","text":"A pert distribution, inspired by tensorflow arguments must be so that: low < peak < high temperature > 0 The support is [low, high] . The peak must fit in that interval: low < peak < high . The temperature is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. Parameters: Name Type Description Default np_random random number generator (used to get beta) required low distribution low value required peak modal point in distribution required high distribution high value required temperature scaling factor required Source code in titan/distributions.py def pert ( np_random , low , peak , high , temperature ): \"\"\" A pert distribution, inspired by [tensorflow](https://github.com/tensorflow/probability/blob/c833ee5cd9f60f3257366b25447b9e50210b0590/tensorflow_probability/python/distributions/pert.py#L137) arguments must be so that: * low < peak < high * temperature > 0 The support is `[low, high]`. The `peak` must fit in that interval: `low < peak < high`. The `temperature` is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. args: np_random: random number generator (used to get beta) low: distribution low value peak: modal point in distribution high: distribution high value temperature: scaling factor \"\"\" assert low < peak < high assert temperature > 0 scale = high - low alpha = 1.0 + temperature * ( peak - low ) / scale beta = 1.0 + temperature * ( high - peak ) / scale return low + scale * np_random . beta ( alpha , beta )","title":"pert()"},{"location":"api/utilities/#titan.distributions.set_value","text":"A distribution that always returns the value passed Parameters: Name Type Description Default np_random random number generator (to conform to distribution interface) required value value to return required Source code in titan/distributions.py def set_value ( np_random , value ): \"\"\" A distribution that always returns the value passed args: np_random: random number generator (to conform to distribution interface) value: value to return \"\"\" return value","title":"set_value()"},{"location":"api/utilities/#params","text":"","title":"Params"},{"location":"api/utilities/#titan.parse_params.ObjMap","text":"A dictionary-like class which allows accessing members either using standard dictionary notation or dots. Note the hash function is hard-coded - beware.","title":"ObjMap"},{"location":"api/utilities/#titan.parse_params.ObjMap.__hash__","text":"Return hash(self). Source code in titan/parse_params.py def __hash__ ( self ): return 1234567890","title":"__hash__()"},{"location":"api/utilities/#titan.parse_params.build_yaml","text":"Read in a yaml or folder of yamls into a dictionary. Source code in titan/parse_params.py def build_yaml ( path ): \"\"\" Read in a yaml or folder of yamls into a dictionary. \"\"\" yml = {} if os . path . isdir ( path ): for file in os . listdir ( path ): if \".yml\" in file or \".yaml\" in file : with open ( os . path . join ( path , file )) as f : this_yml = yaml . safe_load ( f ) yml . update ( this_yml ) else : with open ( path ) as f : assert \".yml\" in path or \".yaml\" in path this_yml = yaml . safe_load ( f ) yml . update ( this_yml ) return yml","title":"build_yaml()"},{"location":"api/utilities/#titan.parse_params.check_item","text":"Checks if an item meets the requirements of the field's definition. Source code in titan/parse_params.py def check_item ( val , d , key_path , keys = None , pops = None ): \"\"\" Checks if an item meets the requirements of the field's definition. \"\"\" if \"min\" in d : assert val >= d [ \"min\" ], f \" { val } must be greater than { d [ 'min' ] } [ { key_path } ]\" if \"max\" in d : assert val <= d [ \"max\" ], f \" { val } must be less than { d [ 'max' ] } [ { key_path } ]\" if d [ \"type\" ] == \"int\" : assert isinstance ( val , int ), f \" { val } must be an integer [ { key_path } ]\" if d [ \"type\" ] == \"float\" : if isinstance ( val , int ): val = float ( val ) assert isinstance ( val , float ), f \" { val } must be a float [ { key_path } ]\" if d [ \"type\" ] == \"boolean\" : assert isinstance ( val , bool ), f \" { val } must be a bool [ { key_path } ]\" if d [ \"type\" ] == \"enum\" : if \"values\" in d : values = d [ \"values\" ] elif \"class\" in d : values = pops [ d [ \"class\" ]] assert val in values , f \" { val } not in { values } [ { key_path } ]\" if d [ \"type\" ] == \"array\" : if \"values\" in d : values = d [ \"values\" ] elif \"class\" in d : values = pops [ d [ \"class\" ]] assert isinstance ( val , list ), f \" { val } must be an array [ { key_path } ]\" assert all ( x in values for x in val ), f \" { val } not in { values } [ { key_path } ]\" if d [ \"type\" ] == \"keys\" : assert isinstance ( val , list ), f \" { val } must be an array of keys [ { key_path } ]\" assert all ( x in keys for x in val ), f \" { keys } not in { keys } [ { key_path } ]\" return val","title":"check_item()"},{"location":"api/utilities/#titan.parse_params.check_params","text":"Consistency checks for param populations Source code in titan/parse_params.py def check_params ( params ): \"\"\" Consistency checks for param populations \"\"\" race_pop = 0 for race in params . classes . races : r_dems = params . demographics [ race ] race_pop += r_dems . ppl sex_type_pop = 0 for st , st_dems in r_dems . items (): if st in list ( params . classes . sex_types . keys ()): sex_type_pop += st_dems . ppl assert math . isclose ( sex_type_pop , 1 , abs_tol = 0.001 ), f \"ppl of { race } 's sex_types must add to 1. Currently adding to { sex_type_pop } \" assert math . isclose ( race_pop , 1 , abs_tol = 0.001 ), f \"ppl of races must add to 1\"","title":"check_params()"},{"location":"api/utilities/#titan.parse_params.create_params","text":"Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. Parameters: Name Type Description Default setting_path Optional[str] path to a settings file or directory or None required param_path str path to parameter file or directory required outdir str path to directory where computed params will be saved required use_base bool whether to use the base setting True error_on_unused bool throw a hard error if there are unused parameters, otherwise warnings are only printed False Returns: Type Description ObjMap computed/validated model paramters with defaults filled in where needed Source code in titan/parse_params.py def create_params ( setting_path : Optional [ str ], param_path : str , outdir : str , use_base : bool = True , error_on_unused : bool = False , ) -> ObjMap : \"\"\" Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. args: setting_path: path to a settings file or directory or `None` param_path: path to parameter file or directory outdir: path to directory where computed params will be saved use_base: whether to use the base setting error_on_unused: throw a hard error if there are unused parameters, otherwise warnings are only printed returns: computed/validated model paramters with defaults filled in where needed \"\"\" filename = getsourcefile ( warn_unused_params ) if filename is not None : parent = Path ( filename ) . resolve () . parent else : raise Exception ( \"can't find where I am in the code?\" ) root = os . path . join ( parent , \"params\" ) defs = build_yaml ( root ) params = build_yaml ( param_path ) # merge setting and params if setting_path is not None : setting = build_yaml ( setting_path ) params = merge ( setting , params ) if use_base : base_dir = os . path . join ( parent , \"..\" , \"settings\" , \"base\" ) base = build_yaml ( base_dir ) params = merge ( base , params ) pops = parse_classes ( defs , params ) parsed = parse_params ( defs , params , \"\" , pops ) with open ( os . path . join ( outdir , \"params.yml\" ), \"w\" ) as f : yaml . dump ( parsed , f ) parsed = ObjMap ( parsed ) check_params ( parsed ) print ( \" \\n Checking for unused parameters...\" ) num_unused = warn_unused_params ( parsed , params , base , \"\" ) print ( f \" { num_unused } unused parameters found\" ) if error_on_unused : assert ( num_unused == 0 ), \"There are unused parameters passed to the model (see print statements)\" return parsed","title":"create_params()"},{"location":"api/utilities/#titan.parse_params.get_bins","text":"Get and validate a type == bin definition Source code in titan/parse_params.py def get_bins ( key , d , key_path , param , pops ): \"\"\" Get and validate a type == bin definition \"\"\" if key not in param : return d [ \"default\" ] bins = merge ( d [ \"default\" ], param [ key ]) parsed_bins = {} for bin , val in bins . items (): try : int ( bin ) except ValueError : print ( \"Bins must be integers\" ) raise for field , defn in d [ \"fields\" ] . items (): assert field in val , f \" { field } must be in { val } [ { key_path } . { bin } ]\" val [ field ] = check_item ( val [ field ], defn , f \" { key_path } . { bin } . { field } \" , pops = pops ) parsed_bins [ int ( bin )] = val return parsed_bins","title":"get_bins()"},{"location":"api/utilities/#titan.parse_params.get_defn","text":"Get and validate a type == definition definition Source code in titan/parse_params.py def get_defn ( key , d , key_path , param , pops ): \"\"\" Get and validate a type == definition definition \"\"\" if key not in param or param [ key ] == {}: parsed = d [ \"default\" ] else : parsed = param [ key ] # check definitions for k , val in parsed . items (): for field , defn in d [ \"fields\" ] . items (): if field not in val : if \"default\" in defn : val [ field ] = defn [ \"default\" ] else : assert field in val , f \" { field } must be in { val } [ { key_path } ]\" val [ field ] = check_item ( val [ field ], defn , f \" { key_path } . { field } \" , keys = parsed . keys (), pops = pops ) return parsed","title":"get_defn()"},{"location":"api/utilities/#titan.parse_params.get_item","text":"Get and check item from the params, falling back on the definitions default. Source code in titan/parse_params.py def get_item ( key , d , key_path , param , pops = None ): \"\"\" Get and check item from the params, falling back on the definitions default. \"\"\" if key in param : val = param [ key ] return check_item ( val , d , f \" { key_path } \" , pops = pops ) else : return d [ \"default\" ]","title":"get_item()"},{"location":"api/utilities/#titan.parse_params.merge","text":"return new merged dict of dicts Source code in titan/parse_params.py def merge ( d1 , d2 ): \"\"\"return new merged dict of dicts\"\"\" if isinstance ( d1 , collections . abc . Mapping ) and isinstance ( d2 , collections . abc . Mapping ): for k , v in d1 . items (): if k in d2 : d2 [ k ] = merge ( v , d2 [ k ]) d3 = d1 . copy () d3 . update ( d2 ) return d3 else : return d2","title":"merge()"},{"location":"api/utilities/#titan.parse_params.parse_classes","text":"Parse the classes definition first as it is needed in parsing the full params. Source code in titan/parse_params.py def parse_classes ( defs , params ): \"\"\" Parse the classes definition first as it is needed in parsing the full params. \"\"\" # add sex types to populations if \"sex_types\" in params . get ( \"classes\" , []): params [ \"classes\" ][ \"populations\" ] = params [ \"classes\" ] . get ( \"populations\" , defs [ \"classes\" ][ \"populations\" ][ \"default\" ] ) + list ( params [ \"classes\" ][ \"sex_types\" ] . keys ()) sex_type_keys = list ( defs [ \"classes\" ][ \"sex_types\" ][ \"default\" ] . keys ()) defs [ \"classes\" ][ \"populations\" ][ \"default\" ] += sex_type_keys defs [ \"classes\" ][ \"populations\" ][ \"values\" ] += sex_type_keys return parse_params ( defs [ \"classes\" ], params . get ( \"classes\" , {}), \"\" , {})","title":"parse_classes()"},{"location":"api/utilities/#titan.parse_params.parse_params","text":"Recursively parse the passed params, using the definitions to validate and provide defaults. Source code in titan/parse_params.py def parse_params ( defs , params , key_path , pops ): \"\"\" Recursively parse the passed params, using the definitions to validate and provide defaults. \"\"\" parsed = {} # params is a scalar, return it if not isinstance ( params , dict ): return params # handles case of bin as direct default item if \"default\" in defs : if defs [ \"type\" ] == \"bin\" : return get_bins ( \"dummy\" , defs , key_path , { \"dummy\" : params }, pops ) elif defs [ \"type\" ] == \"definition\" : return get_defn ( \"dummy\" , defs , key_path , { \"dummy\" : params }, pops ) for k , v in defs . items (): # assumes all v are dicts, as otherwise it would have returned if \"default\" in v : if v [ \"type\" ] == \"sub-dict\" : parsed [ k ] = {} field = v [ \"keys\" ][ 0 ] for val in pops [ field ]: parsed [ k ][ val ] = parse_params ( v [ \"default\" ], params . get ( k , {}) . get ( val , {}), f \" { key_path } . { k } . { val } \" , pops , ) if len ( v [ \"keys\" ]) > 1 : field2 = v [ \"keys\" ][ 1 ] for val2 in pops [ field2 ]: parsed [ k ][ val ][ val2 ] = parse_params ( v [ \"default\" ], params . get ( k , {}) . get ( val , {}) . get ( val2 , {}), f \" { key_path } . { k } . { val } . { val2 } \" , pops , ) elif v [ \"type\" ] == \"bin\" : parsed [ k ] = get_bins ( k , v , f \" { key_path } . { k } \" , params , pops ) elif v [ \"type\" ] == \"definition\" : parsed [ k ] = get_defn ( k , v , f \" { key_path } . { k } \" , params , pops ) else : parsed [ k ] = get_item ( k , v , f \" { key_path } . { k } \" , params , pops ) else : parsed [ k ] = parse_params ( v , params . get ( k , {}), f \" { key_path } . { k } \" , pops ) return parsed","title":"parse_params()"},{"location":"api/utilities/#titan.parse_params.warn_unused_params","text":"Compare the original params to what was parsed and print warnings for any original params that are unused in the final parsed parasms. This excludes unused params from base as those are unavoidable. Source code in titan/parse_params.py def warn_unused_params ( parsed , params , base , key_path ): \"\"\" Compare the original params to what was parsed and print warnings for any original params that are unused in the final parsed parasms. This excludes unused params from base as those are unavoidable. \"\"\" # both values, return count = 0 if not isinstance ( parsed , dict ) and not isinstance ( params , dict ): return count # params has keys, parsed doesn't elif not isinstance ( parsed , dict ): print ( f \"[ { key_path } ] has unused params: { params } \" ) count += 1 return count # parsed has keys, params doesn't elif not isinstance ( params , dict ): print ( f \"[ { key_path } ] has sub-keys, got unused params: { params } \" ) count += 1 return count for k , v in params . items (): if k in parsed : count += warn_unused_params ( parsed [ k ], params [ k ], base . get ( k , {}), f \" { key_path } . { k } \" ) elif k not in base : print ( f \"[ { key_path } . { k } ] is unused\" ) count += 1 return count","title":"warn_unused_params()"},{"location":"api/utilities/#partnering","text":"","title":"Partnering"},{"location":"api/utilities/#titan.partnering.get_mean_rel_duration","text":"Find the average partnership duration by bond type Source code in titan/partnering.py def get_mean_rel_duration ( params : ObjMap ): \"\"\" Find the average partnership duration by bond type \"\"\" mean_rel_duration : Dict [ str , int ] = {} for bond in params . partnership . duration : if params . partnership . duration [ bond ] . type == \"bins\" : weights = [] vals = [] dur_bins = params . partnership . duration [ bond ] . bins for bins in dur_bins : if bins > 1 : weights . append ( dur_bins [ bins ] . prob - dur_bins [ bins - 1 ] . prob ) else : weights . append ( dur_bins [ bins ] . prob ) vals . append ( np . average ([ dur_bins [ bins ] . min , dur_bins [ bins ] . max ])) mean_rel_duration [ bond ] = np . average ( vals , weights = weights ) else : mean_rel_duration [ bond ] = params . partnership . duration [ bond ] . distribution . mean return mean_rel_duration","title":"get_mean_rel_duration()"},{"location":"api/utilities/#titan.partnering.get_partnership_duration","text":"Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] Parameters: Name Type Description Default params ObjMap model parameters required rand_gen random number generator required bond_type type of bond for the relationship whose duration is being determined required Returns: Type Description int number of time steps the partnership should endure Source code in titan/partnering.py def get_partnership_duration ( params : ObjMap , rand_gen , bond_type ) -> int : \"\"\" Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] args: params: model parameters rand_gen: random number generator bond_type: type of bond for the relationship whose duration is being determined returns: number of time steps the partnership should endure \"\"\" if params . partnership . duration [ bond_type ] . type == \"bins\" : dur_info = params . partnership . duration [ bond_type ] . bins diceroll = rand_gen . random () dur_bin = dur_info [ 5 ] for i in range ( 1 , 5 ): if diceroll < dur_info [ i ] . prob : dur_bin = dur_info [ i ] break duration = rand_gen . randint ( dur_bin . min , dur_bin . max ) else : dist = params . partnership . duration [ bond_type ] . distribution duration = utils . safe_dist ( dist , rand_gen ) return duration","title":"get_partnership_duration()"},{"location":"api/utilities/#titan.partnering.select_partner","text":"Get a partner for the agent. Parameters: Name Type Description Default agent Agent agent in need of a partner required partnerable_agents Set[titan.agent.Agent] agents that can be selected as a partner required sex_partners Dict mapping from sex_type to agents in the population that can sleep with that sex_type required pwid_agents AgentSet agents with drug_type===\"Inj\" required params ObjMap model parameters required rand_gen random number generator required bond_type type of relationship that is being formed with the partner required Returns: Type Description Optional[titan.agent.Agent] new partner or None Source code in titan/partnering.py def select_partner ( agent : Agent , partnerable_agents : Set [ Agent ], sex_partners : Dict , pwid_agents : AgentSet , params : ObjMap , rand_gen , bond_type , ) -> Optional [ Agent ]: \"\"\" Get a partner for the agent. args: agent : agent in need of a partner partnerable_agents: agents that can be selected as a partner sex_partners: mapping from sex_type to agents in the population that can sleep with that sex_type pwid_agents: agents with `drug_type===\"Inj\"` params: model parameters rand_gen: random number generator bond_type: type of relationship that is being formed with the partner returns: new partner or `None` \"\"\" def assort ( eligible_partners , assort_params ): partner_types = list ( assort_params . partner_values . keys ()) partner_weights = [ assort_params . partner_values [ p ] for p in partner_types ] partner_type = utils . safe_random_choice ( partner_types , rand_gen , weights = partner_weights ) if partner_type == \"__other__\" : # remove all the specified (not selected) values and remove those # partners from the eligible set for p in partner_types : if p != \"__other__\" : eligible_partners = { partner for partner in eligible_partners if str ( getattr ( partner , assort_params . attribute )) != p } else : eligible_partners = { partner for partner in eligible_partners if str ( getattr ( partner , assort_params . attribute )) == partner_type } return eligible_partners eligible = copy ( partnerable_agents ) eligible -= agent . get_partners () eligible -= { agent } acts_allowed = params . classes . bond_types [ bond_type ] . acts_allowed if \"injection\" in acts_allowed : eligible &= pwid_agents . members if \"sex\" in acts_allowed : eligible &= sex_partners [ agent . sex_type ] # short circuit to avoid attempting to assort with no eligible partners if not eligible : return None if params . features . assort_mix : for assort_def in params . assort_mix . values (): if getattr ( agent , assort_def . attribute ) == assort_def . agent_value : eligible = assort ( eligible , assort_def ) random_partner = utils . safe_random_choice ( eligible , rand_gen ) return random_partner","title":"select_partner()"},{"location":"api/utilities/#titan.partnering.sex_possible","text":"Determine if sex is possible. Parameters: Name Type Description Default agent_sex_type str name of agent's sex type required partner_sex_type str name of partner's sex type required Returns: Type Description bool whether sex is possible between agents of these sex types Source code in titan/partnering.py @utils . memo def sex_possible ( agent_sex_type : str , partner_sex_type : str , sex_types : ObjMap ) -> bool : \"\"\" Determine if sex is possible. args: agent_sex_type: name of agent's sex type partner_sex_type: name of partner's sex type returns: whether sex is possible between agents of these sex types \"\"\" # Check input if agent_sex_type not in sex_types : raise ValueError ( f \"Invalid agent_sex_type! { agent_sex_type } \" ) if partner_sex_type not in sex_types : raise ValueError ( f \"Invalid partner_sex_type! { partner_sex_type } \" ) agent_match = agent_sex_type in sex_types [ partner_sex_type ] . sleeps_with partner_match = partner_sex_type in sex_types [ agent_sex_type ] . sleeps_with return agent_match and partner_match","title":"sex_possible()"},{"location":"api/utilities/#complex-probabilities","text":"","title":"Complex Probabilities"},{"location":"api/utilities/#titan.probabilities.adherence_prob","text":"Mapping from HAART adherence levels to probabilities. Parameters: Name Type Description Default adherence int HAART adherence level required Returns: Type Description float probability of agent transitioning from HIV+ to AIDS Source code in titan/probabilities.py @utils . memo def adherence_prob ( adherence : int ) -> float : \"\"\" Mapping from HAART adherence levels to probabilities. args: adherence: HAART adherence level returns: probability of agent transitioning from HIV+ to AIDS \"\"\" if adherence == 1 : return 0.0051 elif adherence == 2 : return 0.0039 elif adherence == 3 : return 0.0032 elif adherence == 4 : return 0.0025 elif adherence == 5 : return 0.0008 else : return 0.0051","title":"adherence_prob()"},{"location":"api/utilities/#titan.probabilities.get_death_rate","text":"Find the death rate of an agent given a set of attributes. Parameters: Name Type Description Default hiv bool whether the agent is HIV+ required aids bool whether the agent has AIDS required drug_type str whether the PWID base death rate should be used or the base one required haart_adh int level of HAART adherence required race str the race of the agent required location Location agent's location required steps_per_year int the number of model steps in a year required Returns: Type Description float the probability of an agent with these characteristics dying in a given time step Source code in titan/probabilities.py @utils . memo def get_death_rate ( hiv : bool , aids : bool , drug_type : str , haart_adh : int , race : str , location : Location , steps_per_year : int , ) -> float : \"\"\" Find the death rate of an agent given a set of attributes. args: hiv: whether the agent is HIV+ aids: whether the agent has AIDS drug_type: whether the PWID base death rate should be used or the base one haart_adh: level of HAART adherence race: the race of the agent location: agent's location steps_per_year: the number of model steps in a year returns: the probability of an agent with these characteristics dying in a given time step \"\"\" param = location . params . demographics if drug_type == \"Inj\" : death_param = param [ race ] . PWID . death_rate else : death_param = param [ race ] . death_rate p = death_param . base if aids : p *= death_param . aids elif hiv : if haart_adh == 5 : p *= death_param . haart_adherent else : p *= death_param . hiv # putting it into per 1 person-month from per 1000 person years return p / ( steps_per_year * 1000.0 )","title":"get_death_rate()"}]}